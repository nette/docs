Tag-uri Latte
*************

.[perex]
Prezentare generală și descrierea tuturor tag-urilor (sau etichetelor ori macro-urilor) sistemului de șabloane Latte, care vă sunt disponibile în mod standard.

.[table-latte-tags language-latte]
|## Afișare
| `{$var}`, `{...}` sau `{=...}`  | [afișează variabila sau expresia escapată |#Vypisování]
| `{$var\|filter}`                 | [afișează folosind filtre |#Filtry]
| `{l}` sau `{r}`                 | afișează caracterul `{` sau `}`

.[table-latte-tags language-latte]
|## Condiții
| `{if}` … `{elseif}` … `{else}` … `{/if}`    | [condiția if|#if-elseif-else]
| `{ifset}` … `{elseifset}` … `{/ifset}`      | [condiția ifset|#ifset-elseifset]
| `{ifchanged}` … `{/ifchanged}`              | [testează dacă a avut loc o schimbare |#ifchanged]
| `{switch}` `{case}` `{default}` `{/switch}` | [condiția switch|#switch-case-default]
| `n:else`                                    | [conținut alternativ pentru condiții |#n:else]

.[table-latte-tags language-latte]
|## Bucle
| `{foreach}` … `{/foreach}`     | [#foreach]
| `{for}` … `{/for}`             | [#for]
| `{while}` … `{/while}`         | [#while]
| `{continueIf $cond}`           | [continuă cu următoarea iterație |#continueif-skipif-breakif]
| `{skipIf $cond}`               | [sare peste iterație |#continueif-skipif-breakif]
| `{breakIf $cond}`              | [întreruperea buclei |#continueif-skipif-breakif]
| `{exitIf $cond}`               | [terminare timpurie |#exitif]
| `{first}` … `{/first}`         | [este prima trecere? |#first-last-sep]
| `{last}` … `{/last}`           | [este ultima trecere? |#first-last-sep]
| `{sep}` … `{/sep}`             | [va urma o altă trecere? |#first-last-sep]
| `{iterateWhile}` … `{/iterateWhile}` | [foreach structurat|#iterateWhile]
| `$iterator`                    | [variabilă specială în interiorul foreach |#$iterator]

.[table-latte-tags language-latte]
|## Includerea altor șabloane
| `{include 'file.latte'}`       | [încarcă șablonul dintr-un alt fișier |#include]
| `{sandbox 'file.latte'}`       | [încarcă șablonul în modul sandbox |#sandbox]

.[table-latte-tags language-latte]
|## Blocuri, layout-uri, moștenirea șabloanelor
| `{block}`                      | [bloc anonim|#block]
| `{block blockname}`            | [definește un bloc |template-inheritance#bloky]
| `{define blockname}`           | [definește un bloc pentru utilizare ulterioară |template-inheritance#definice]
| `{include blockname}`          | [randarea blocului|template-inheritance#Vykreslení bloků]
| `{include blockname from 'file.latte'}` | [randează blocul dintr-un fișier |template-inheritance#Vykreslení bloků]
| `{import 'file.latte'}`        | [încarcă blocurile dintr-un șablon |template-inheritance#horizontální znovupoužití]
| `{layout 'file.latte'}` / `{extends}` | [specifică fișierul cu layout-ul |template-inheritance#Layoutová dědičnost]
| `{embed}` … `{/embed}`         | [încarcă șablonul sau blocul și permite suprascrierea blocurilor |template-inheritance#jednotková dědičnost]
| `{ifset blockname}` … `{/ifset}`   | [condiție, dacă există blocul |template-inheritance#Kontrola existence bloků]

.[table-latte-tags language-latte]
|## Gestionarea excepțiilor
| `{try}` … `{else}` … `{/try}`  | [capturarea excepțiilor |#try]
| `{rollback}`                   | [anularea blocului try |#rollback]

.[table-latte-tags language-latte]
|## Variabile
| `{var $foo = value}`           | [creează o variabilă |#var-default]
| `{default $foo = value}`       | [creează o variabilă, dacă nu există |#var-default]
| `{parameters}`                 | [declară variabile, tipuri și valori implicite |#parameters]
| `{capture}` … `{/capture}`     | [capturează blocul într-o variabilă |#capture]

.[table-latte-tags language-latte]
|## Tipuri
| `{varType}`                    | [declară tipul variabilei |type-system#varType]
| `{varPrint}`                   | [sugerează tipurile variabilelor |type-system#varPrint]
| `{templateType}`               | [declară tipurile variabilelor conform clasei |type-system#templateType]
| `{templatePrint}`              | [sugerează clasa cu tipurile variabilelor |type-system#templatePrint]

.[table-latte-tags language-latte]
|## Traduceri
| `{_...}`                       | [afișează traducerea |#překlady]
| `{translate}` … `{/translate}` | [traduce conținutul |#překlady]

.[table-latte-tags language-latte]
|## Altele
| `{contentType}`                | [comută escaparea și trimite antetul HTTP |#contenttype]
| `{debugbreak}`                 | [plasează un breakpoint în cod |#debugbreak]
| `{do}`                         | [execută codul, dar nu afișează nimic |#do]
| `{dump}`                       | [afisează variabilele în Tracy Bar |#dump]
| `{php}`                        | [execută orice cod PHP|#php]
| `{spaceless}` … `{/spaceless}` | [elimină spațiile redundante |#spaceless]
| `{syntax}`                     | [schimbarea sintaxei în timpul rulării |#syntax]
| `{trace}`                      | [afișează stack trace |#trace]

.[table-latte-tags language-latte]
|## Ajutoare pentru coderul HTML
| `n:class`                      | [scriere dinamică a atributului HTML class |#n:class]
| `n:attr`                       | [scriere dinamică a oricăror atribute HTML |#n:attr]
| `n:tag`                        | [scriere dinamică a numelui elementului HTML |#n:tag]
| `n:ifcontent`                  | [omite tag-ul HTML gol |#n:ifcontent]

.[table-latte-tags language-latte]
|## Disponibile doar în Nette Framework
| `n:href`                       | [link utilizat în elementele HTML `<a>` |application:creating-links#V šabloně presenteru]
| `{link}`                       | [afișează linkul |application:creating-links#V šabloně presenteru]
| `{plink}`                      | [afișează linkul către presenter |application:creating-links#V šabloně presenteru]
| `{control}`                    | [randează componenta |application:components#Vykreslení]
| `{snippet}` … `{/snippet}`     | [fragment care poate fi trimis prin AJAX |application:ajax#snippety-v-latte]
| `{snippetArea}`                | [înveliș pentru fragmente |application:ajax#oblasti-snippetu]
| `{cache}` … `{/cache}`         | [cachează o parte a șablonului |caching:#cachovani-v-latte]

.[table-latte-tags language-latte]
|## Disponibile doar cu Nette Forms
| `{form}` … `{/form}`           | [randează tag-urile formularului |forms:rendering#form]
| `{label}` … `{/label}`         | [randează eticheta elementului de formular |forms:rendering#label-input]
| `{input}`                      | [randează elementul de formular |forms:rendering#label-input]
| `{inputError}`                 | [afișează mesajul de eroare al elementului de formular |forms:rendering#inputError]
| `n:name`                       | [activează elementul de formular |forms:rendering#n:name]
| `{formContainer}` … `{/formContainer}` | [randarea containerului de formular |forms:rendering#specialni-pripady]


Afișare
=======


`{$var}` `{...}` `{=...}`
-------------------------

În Latte se folosește tag-ul `{=...}` pentru afișarea oricărei expresii în ieșire. Latte ține la confortul dvs., așa că dacă expresia începe cu o variabilă sau un apel de funcție, nu este nevoie să scrieți egalul. Ceea ce în practică înseamnă că aproape niciodată nu este nevoie să îl scrieți:

```latte
Nume: {$name} {$surname}<br>
Vârstă: {date('Y') - $birth}<br>
```

Ca expresie puteți scrie orice cunoașteți din PHP. Nu trebuie, pur și simplu, să învățați un nou limbaj. De exemplu:


```latte
{='0' . ($num ?? $num * 3) . ', ' . PHP_VERSION}
```

Vă rugăm, nu căutați niciun sens în exemplul anterior, dar dacă găsiți vreunul, scrieți-ne :-)


Escaparea ieșirii
-----------------

Care este cea mai importantă sarcină a unui sistem de șabloane? Prevenirea găurilor de securitate. Și exact asta face Latte întotdeauna când afișați ceva. Escapează automat:

```latte
<p>{='one < two'}</p>   {* afișează: '<p>one &lt; two</p>' *}
```

Pentru a fi exacți, Latte folosește escaparea contextuală sensibilă, ceea ce este un lucru atât de important și unic, încât i-am dedicat [un capitol separat|safety-first#Kontextově sensitivní escapování].

Și ce se întâmplă dacă afișați conținut codificat în HTML dintr-o sursă de încredere? Atunci puteți dezactiva ușor escaparea:

```latte
{$trustedHtmlString|noescape}
```

.[warning]
Utilizarea incorectă a filtrului `noescape` poate duce la vulnerabilitatea XSS! Nu-l utilizați niciodată dacă nu sunteți **absolut sigur** de ceea ce faceți și că șirul afișat provine dintr-o sursă de încredere.


Afișarea în JavaScript
----------------------

Datorită escapării contextuale sensibile, este minunat de ușor să afișați variabile în interiorul JavaScriptului, iar Latte se ocupă de escaparea corectă.

Variabila nu trebuie să fie doar un șir, este suportat orice tip de date, care apoi este codificat ca JSON:

```latte
{var $foo = ['hello', true, 1]}
<script>
	alert({$foo});
</script>
```

Generează:

```latte
<script>
	alert(["hello", true, 1]);
</script>
```

Acesta este și motivul pentru care **nu se scriu ghilimele** în jurul variabilei: Latte le adaugă singur pentru șiruri. Și dacă doriți să inserați o variabilă șir într-un alt șir, pur și simplu le concatenați:

```latte
<script>
	alert('Hello ' + {$name} + '!');  // OK

	alert({="Hello $name!"});         // OK

	alert('Hello {$name} !');         // EROARE!
</script>
```


Filtre
------

Expresia afișată poate fi modificată prin [filtre|syntax#filtry]. Astfel, de exemplu, convertim un șir în majuscule și îl scurtăm la maximum 30 de caractere:

```latte
{$string|upper|truncate:30}
```

Puteți aplica filtre și pe părți parțiale ale expresiei în acest mod:

```latte
{$left . ($middle|upper) . $right}
```


Condiții
========


`{if}` `{elseif}` `{else}`
--------------------------

Condițiile se comportă la fel ca omologii lor din PHP. Puteți folosi în ele aceleași expresii pe care le cunoașteți din PHP, nu trebuie să învățați un nou limbaj.

```latte
{if $product->inStock > Stock::Minimum}
	În stoc
{elseif $product->isOnWay()}
	Pe drum
{else}
	Indisponibil
{/if}
```

Ca orice tag pereche, și perechea `{if} ... {/if}` poate fi scrisă și sub formă de [n:atribut|syntax#n:atributy], de exemplu:

```latte
<p n:if="$count > 0">În stoc {$count} bucăți</p>
```

Știați că la n:atribute puteți adăuga prefixul `tag-`? Atunci condiția se va aplica doar la afișarea tag-urilor HTML, iar conținutul dintre ele se va afișa întotdeauna:

```latte
<a href="..." n:tag-if="$clickable">Hello</a>

{* afișează 'Hello' când $clickable este fals *}
{* afișează '<a href="...">Hello</a>' când $clickable este adevărat *}
```

Grozav.


`n:else` .{data-version:3.0.11}
-------------------------------

Dacă scrieți condiția `{if} ... {/if}` sub formă de [n:atribut|syntax#n:atributy], aveți posibilitatea de a specifica și o ramură alternativă folosind `n:else`:

```latte
<strong n:if="$count > 0">În stoc {$count} bucăți</strong>

<em n:else>indisponibil</em>
```

Atributul `n:else` poate fi folosit și în pereche cu [`n:ifset` |#ifset-elseifset], [`n:foreach` |#foreach], [`n:try` |#try], [`n:ifcontent` |#n:ifcontent] și [`n:ifchanged` |#ifchanged].


`{/if $cond}`
-------------

Poate vă va surprinde că expresia din condiția `{if}` poate fi specificată și în tag-ul de închidere. Acest lucru este util în situațiile în care, la deschiderea condiției, încă nu cunoaștem valoarea sa. Să numim asta decizie amânată.

De exemplu, începem să afișăm un tabel cu înregistrări din baza de date și abia după finalizarea afișării realizăm că în baza de date nu a existat nicio înregistrare. Atunci punem condiția în tag-ul de închidere `{/if}` și dacă nu există nicio înregistrare, nimic din toate acestea nu se va afișa:

```latte
{if}
	<h1>Listarea rândurilor din baza de date</h1>

	<table>
	{foreach $resultSet as $row}
		...
	{/foreach}
	</table>
{/if isset($row)}
```

Util, nu-i așa?

În condiția amânată se poate folosi și `{else}`, dar nu `{elseif}`.


`{ifset}` `{elseifset}`
-----------------------

.[note]
Vezi și [`{ifset block}` |template-inheritance#Kontrola existence bloků]

Folosind condiția `{ifset $var}`, verificăm dacă variabila (sau mai multe variabile) există și are o valoare non-*null*. De fapt, este același lucru cu `if (isset($var))` în PHP. Ca orice tag pereche, poate fi scris și sub formă de [n:atribut|syntax#n:atributy], așa că să arătăm asta ca exemplu:

```latte
<meta name="robots" content={$robots} n:ifset="$robots">
```


`{ifchanged}`
-------------

`{ifchanged}` verifică dacă valoarea unei variabile s-a schimbat de la ultima iterație într-o buclă (foreach, for sau while).

Dacă specificăm una sau mai multe variabile în tag, va verifica dacă vreuna dintre ele s-a schimbat și va afișa conținutul în consecință. De exemplu, următorul exemplu afișează prima literă a numelui ca titlu de fiecare dată când se schimbă la afișarea numelor:

```latte
{foreach ($names|sort) as $name}
	{ifchanged $name[0]} <h2>{$name[0]}</h2> {/ifchanged}

	<p>{$name}</p>
{/foreach}
```

Dacă însă nu specificăm niciun argument, se va verifica conținutul randat față de starea sa anterioară. Acest lucru înseamnă că, în exemplul anterior, putem omite liniștit argumentul din tag. Și, desigur, putem folosi și [n:atribut|syntax#n:atributy]:

```latte
{foreach ($names|sort) as $name}
	<h2 n:ifchanged>{$name[0]}</h2>

	<p>{$name}</p>
{/foreach}
```

În interiorul `{ifchanged}` se poate specifica și clauza `{else}`.


`{switch}` `{case}` `{default}`
-------------------------------
Compară valoarea cu mai multe opțiuni. Este un echivalent al instrucțiunii condiționale `switch`, pe care o cunoașteți din PHP. Cu toate acestea, Latte o îmbunătățește:

- folosește comparare strictă (`===`)
- nu necesită `break`

Este deci echivalentul exact al structurii `match` introdusă în PHP 8.0.

```latte
{switch $transport}
	{case train}
		Cu trenul
	{case plane}
		Cu avionul
	{default}
		Altfel
{/switch}
```

Clauza `{case}` poate conține mai multe valori separate prin virgule:

```latte
{switch $status}
{case $status::New}<b>element nou</b>
{case $status::Sold, $status::Unknown}<i>indisponibil</i>
{/switch}
```


Bucle
=====

În Latte găsiți toate buclele pe care le cunoașteți din PHP: foreach, for și while.


`{foreach}`
-----------

Bucla se scrie exact la fel ca în PHP:

```latte
{foreach $langs as $code => $lang}
	<span>{$lang}</span>
{/foreach}
```

În plus, are câteva caracteristici utile despre care vom vorbi acum.

Latte, de exemplu, verifică dacă variabilele create nu suprascriu accidental variabile globale cu același nume. Salvează situații în care contați pe faptul că `$lang` conține limba curentă a paginii și nu realizați că `foreach $langs as $lang` v-a suprascris acea variabilă.

Bucla foreach poate fi scrisă și foarte elegant și concis folosind [n:atribut|syntax#n:atributy]:

```latte
<ul>
	<li n:foreach="$items as $item">{$item->name}</li>
</ul>
```

Știați că la n:atribute puteți adăuga prefixul `inner-`? Atunci doar interiorul elementului se va repeta în buclă:

```latte
<div n:inner-foreach="$items as $item">
	<h4>{$item->title}</h4>
	<p>{$item->description}</p>
</div>
```

Deci se va afișa ceva de genul:

```latte
<div>
	<h4>Foo</h4>
	<p>Lorem ipsum.</p>
	<h4>Bar</h4>
	<p>Sit dolor.</p>
</div>
```


`{else}` .{toc: foreach-else}
-----------------------------

În interiorul buclei `foreach` se poate specifica clauza `{else}`, al cărei conținut se afișează dacă bucla este goală:

```latte
<ul>
	{foreach $people as $person}
		<li>{$person->name}</li>
	{else}
		<li><em>Ne pare rău, nu există utilizatori în această listă</em></li>
	{/foreach}
</ul>
```


`$iterator`
-----------

În interiorul buclei `foreach`, Latte creează variabila `$iterator`, cu ajutorul căreia putem afla informații utile despre bucla în curs:

- `$iterator->first` - este prima trecere prin buclă?
- `$iterator->last` - este ultima trecere?
- `$iterator->counter` - a câta trecere este, numărând de la unu?
- `$iterator->counter0` - a câta trecere este, numărând de la zero?
- `$iterator->odd` - este o trecere impară?
- `$iterator->even` - este o trecere pară?
- `$iterator->parent` - iteratorul care îl înconjoară pe cel curent
- `$iterator->nextValue` - elementul următor din buclă
- `$iterator->nextKey` - cheia elementului următor din buclă


```latte
{foreach $rows as $row}
	{if $iterator->first}<table>{/if}

	<tr id="row-{$iterator->counter}">
		<td>{$row->name}</td>
		<td>{$row->email}</td>
	</tr>

	{if $iterator->last}</table>{/if}
{/foreach}
```

Latte este inteligent și `$iterator->last` funcționează nu doar pentru array-uri, ci și atunci când bucla parcurge un iterator general, unde numărul de elemente nu este cunoscut în avans.


`{first}` `{last}` `{sep}`
--------------------------

Aceste tag-uri pot fi folosite în interiorul buclei `{foreach}`. Conținutul `{first}` se randează dacă este prima trecere.
Conținutul `{last}` se randează… ghiciți? Da, dacă este ultima trecere. Sunt de fapt prescurtări pentru `{if $iterator->first}` și `{if $iterator->last}`.

Tag-urile pot fi folosite și elegant ca [n:atribut|syntax#n:atributy]:

```latte
{foreach $rows as $row}
	{first}<h1>List of names</h1>{/first}

	<p>{$row->name}</p>

	<hr n:last>
{/foreach}
```

Conținutul tag-ului `{sep}` se randează dacă trecerea nu este ultima, fiind util pentru randarea separatoarelor, de exemplu, virgule între elementele afișate:

```latte
{foreach $items as $item} {$item} {sep}, {/sep} {/foreach}
```

Este destul de practic, nu-i așa?


`{iterateWhile}`
----------------

Simplifică gruparea datelor liniare în timpul iterării într-o buclă foreach, efectuând iterația într-o buclă imbricată atâta timp cât condiția este îndeplinită. [Citiți un tutorial detaliat|cookbook/grouping].

Poate înlocui elegant și `{first}` și `{last}` din exemplul de mai sus:

```latte
{foreach $rows as $row}
	<table>

	{iterateWhile}
	<tr id="row-{$iterator->counter}">
		<td>{$row->name}</td>
		<td>{$row->email}</td>
	</tr>
	{/iterateWhile true}

	</table>
{/foreach}
```

Vezi și filtrele [batch|filters#batch] și [group|filters#group].


`{for}`
-------

Bucla o scriem exact la fel ca în PHP:

```latte
{for $i = 0; $i < 10; $i++}
	<span>Element {$i}</span>
{/for}
```

Tag-ul poate fi folosit și ca [n:atribut|syntax#n:atributy]:

```latte
<h1 n:for="$i = 0; $i < 10; $i++">{$i}</h1>
```


`{while}`
---------

Bucla o scriem din nou exact la fel ca în PHP:

```latte
{while $row = $result->fetch()}
	<span>{$row->title}</span>
{/while}
```

Sau ca [n:atribut|syntax#n:atributy]:

```latte
<span n:while="$row = $result->fetch()">
	{$row->title}
</span>
```

Este posibilă și varianta cu condiția în tag-ul de închidere, care corespunde în PHP buclei do-while:

```latte
{while}
	<span>{$item->title}</span>
{/while $item = $item->getNext()}
```


`{continueIf}` `{skipIf}` `{breakIf}`
-------------------------------------

Pentru controlul oricărei bucle se pot folosi tag-urile `{continueIf ?}` și `{breakIf ?}`, care trec la elementul următor, respectiv încheie bucla la îndeplinirea condiției:

```latte
{foreach $rows as $row}
	{continueIf $row->date < $now}
	{breakIf $row->parent === null}
	...
{/foreach}
```


Tag-ul `{skipIf}` este foarte similar cu `{continueIf}`, dar nu incrementează contorul `$iterator->counter`, astfel încât dacă îl afișăm și în același timp sărim peste unele elemente, nu vor exista goluri în numerotare. De asemenea, clauza `{else}` se randează dacă sărim peste toate elementele.

```latte
<ul>
	{foreach $people as $person}
		{skipIf $person->age < 18}
		<li>{$iterator->counter}. {$person->name}</li>
	{else}
		<li><em>Ne pare rău, nu există adulți în această listă</em></li>
	{/foreach}
</ul>
```


`{exitIf}` .{data-version:3.0.5}
--------------------------------

Încheie randarea șablonului sau a blocului la îndeplinirea condiției (așa-numitul "early exit").

```latte
{exitIf !$messages}

<h1>Mesaje</h1>
<div n:foreach="$messages as $message">
   {$message}
</div>
```


Includerea șablonului
=====================


`{include 'file.latte'}` .{toc: include}
----------------------------------------

.[note]
Vezi și [`{include block}` |template-inheritance#Vykreslení bloků]

Tag-ul `{include}` încarcă și randează șablonul specificat. Dacă am vorbi în limbajul limbii noastre preferate PHP, este ceva de genul:

```php
<?php include 'header.phtml'; ?>
```

Șabloanele incluse nu au acces la variabilele contextului activ, au acces doar la variabilele globale.

Puteți transmite variabile în șablonul inclus în acest mod:

```latte
{include 'template.latte', foo: 'bar', id: 123}
```

Numele șablonului poate fi orice expresie PHP:

```latte
{include $someVar}
{include $ajax ? 'ajax.latte' : 'not-ajax.latte'}
```

Conținutul inclus poate fi modificat folosind [filtre|syntax#filtry]. Următorul exemplu elimină tot HTML-ul și modifică dimensiunea literelor:

```latte
<title>{include 'heading.latte' |stripHtml|capitalize}</title>
```

În mod implicit, [moștenirea șabloanelor|template-inheritance] nu figurează în niciun fel în acest caz. Chiar dacă în șablonul inclus putem folosi blocuri, nu se va produce înlocuirea blocurilor corespunzătoare din șablonul în care se include. Gândiți-vă la șabloanele incluse ca la părți separate și izolate ale paginilor sau modulelor. Acest comportament poate fi schimbat folosind modificatorul `with blocks`:

```latte
{include 'template.latte' with blocks}
```

Relația dintre numele fișierului specificat în tag și fișierul de pe disc este responsabilitatea [loaderului|loaders].


`{sandbox}`
-----------

La includerea unui șablon creat de utilizatorul final, ar trebui să luați în considerare modul sandbox (mai multe informații în [documentația sandbox |sandbox]):

```latte
{sandbox 'untrusted.latte', level: 3, data: $menu}
```


`{block}`
=========

.[note]
Vezi și [`{block name}` |template-inheritance#bloky]

Blocurile fără nume servesc ca o modalitate de a aplica [filtre|syntax#filtry] pe o parte a șablonului. De exemplu, astfel se poate aplica filtrul [strip|filters#strip], care elimină spațiile inutile:

```latte
{block|strip}
<ul>
	<li>Hello World</li>
</ul>
{/block}
```


Gestionarea excepțiilor
=======================


`{try}`
-------

Datorită acestui tag, este extrem de ușor să creați șabloane robuste.

Dacă în timpul randării blocului `{try}` apare o excepție, întregul bloc este anulat și randarea va continua după el:

```latte
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
{/try}
```

Conținutul din clauza opțională `{else}` se randează doar când apare o excepție:

```latte
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
	{else}
	<p>Ne pare rău, nu s-au putut încărca tweet-urile.</p>
{/try}
```

Tag-ul poate fi folosit și ca [n:atribut|syntax#n:atributy]:

```latte
<ul n:try>
	...
</ul>
```

Este posibil, de asemenea, să definiți propriul [handler de excepții|develop#exception handler], de exemplu, pentru logare.


`{rollback}`
------------

Blocul `{try}` poate fi oprit și sărit și manual folosind `{rollback}`. Datorită acestui fapt, nu trebuie să verificați în prealabil toate datele de intrare și abia în timpul randării puteți decide că nu doriți să randați deloc obiectul:

```latte
{try}
<ul>
	{foreach $people as $person}
 		{skipIf $person->age < 18}
 		<li>{$person->name}</li>
	{else}
		{rollback}
	{/foreach}
</ul>
{/try}
```


Variabile
=========


`{var}` `{default}`
-------------------

Variabile noi creăm în șablon cu tag-ul `{var}`:

```latte
{var $name = 'John Smith'}
{var $age = 27}

{* Declarație multiplă *}
{var $name = 'John Smith', $age = 27}
```

Tag-ul `{default}` funcționează similar, dar creează variabile doar dacă nu există. Dacă variabila există deja și conține valoarea `null`, nu va fi suprascrisă:

```latte
{default $lang = 'cs'}
```

Puteți specifica și [tipurile variabilelor|type-system]. Deocamdată sunt informative și Latte nu le verifică.

```latte
{var string $name = $article->getTitle()}
{default int $id = 0}
```


`{parameters}`
--------------

Așa cum o funcție își declară parametrii, și un șablon poate declara la început variabilele sale:

```latte
{parameters
	$a,
	?int $b,
	int|string $c = 10
}
```

Variabilele `$a` și `$b` fără valoare implicită specificată au automat valoarea implicită `null`. Tipurile declarate sunt deocamdată informative și Latte nu le verifică.

Alte variabile decât cele declarate nu sunt transferate în șablon. Prin aceasta se diferențiază de tag-ul `{default}`.


`{capture}`
-----------

Capturează ieșirea într-o variabilă:

```latte
{capture $var}
<ul>
	<li>Hello World</li>
</ul>
{/capture}

<p>Capturat: {$var}</p>
```

Tag-ul poate fi, la fel ca orice tag pereche, scris și ca [n:atribut|syntax#n:atributy]:

```latte
<ul n:capture="$var">
	<li>Hello World</li>
</ul>
```

Ieșirea HTML se salvează în variabila `$var` sub formă de obiect `Latte\Runtime\Html`, pentru a [preveni escaparea nedorită |develop#vypnuti-auto-escapovani-promenne] la afișare.


Altele
======


`{contentType}`
---------------

Cu acest tag specificați ce tip de conținut reprezintă șablonul. Opțiunile sunt:

- `html` (tip implicit)
- `xml`
- `javascript`
- `css`
- `calendar` (iCal)
- `text`

Utilizarea sa este importantă, deoarece setează [escaparea contextuală sensibilă |safety-first#Kontextově sensitivní escapování] și doar așa poate escapa corect. De exemplu, `{contentType xml}` comută în modul XML, `{contentType text}` dezactivează complet escaparea.

Dacă parametrul este un tip MIME complet, cum ar fi `application/xml`, atunci trimite și antetul HTTP `Content-Type` către browser:

```latte
{contentType application/xml}
<?xml version="1.0"?>
<rss version="2.0">
	<channel>
		<title>RSS feed</title>
		<item>
			...
		</item>
	</channel>
</rss>
```


`{debugbreak}`
--------------

Indică locul unde execuția programului va fi suspendată și debuggerul va fi pornit, pentru ca programatorul să poată inspecta mediul de rulare și să verifice dacă programul funcționează conform așteptărilor. Suportă [Xdebug |https://xdebug.org/]. Se poate adăuga o condiție care determină când programul trebuie suspendat.

```latte
{debugbreak}                {* suspendă programul *}

{debugbreak $counter == 1}  {* suspendă programul la îndeplinirea condiției *}
```


`{do}`
------

Execută cod PHP și nu afișează nimic. La fel ca la toate celelalte tag-uri, prin cod PHP se înțelege o singură expresie, vezi [limitările PHP |syntax#Omezení PHP v Latte].

```latte
{do $num++}
```


`{dump}`
--------

Afișează variabila sau contextul curent.

```latte
{dump $name} {* Afișează variabila $name *}

{dump}       {* Afișează toate variabilele definite curent *}
```

.[caution]
Necesită biblioteca [Tracy|tracy:].


`{php}`
-------

Permite executarea oricărui cod PHP. Tag-ul trebuie activat folosind extensia [RawPhpExtension |develop#RawPhpExtension].


`{spaceless}`
-------------

Elimină spațiul alb inutil din ieșire. Funcționează similar cu filtrul [spaceless|filters#spaceless].

```latte
{spaceless}
	<ul>
		<li>Hello</li>
	</ul>
{/spaceless}
```

Generează

```latte
<ul> <li>Hello</li> </ul>
```

Tag-ul poate fi scris și ca [n:atribut|syntax#n:atributy].


`{syntax}`
----------

Tag-urile Latte nu trebuie să fie delimitate doar de acolade simple. Putem alege și alt delimitator, chiar și în timpul rulării. Pentru aceasta servește `{syntax …}`, unde ca parametru se poate specifica:

- double: `{{...}}`
- off: dezactivează complet procesarea tag-urilor Latte

Folosind n:atribute, se poate dezactiva Latte, de exemplu, doar pentru un bloc JavaScript:

```latte
<script n:syntax="off">
	var obj = {var: 123}; // acesta nu mai este un tag
</script>
```

Latte poate fi folosit foarte convenabil și în interiorul JavaScriptului, trebuie doar evitate construcțiile ca în acest exemplu, unde o literă urmează imediat după `{`, vezi [Latte în interiorul JavaScriptului sau CSS|recipes#Latte uvnitř JavaScriptu nebo CSS].

Dacă dezactivați Latte folosind `{syntax off}` (adică prin tag, nu prin n:atribut), va ignora consecvent toate tag-urile până la `{/syntax}`


{trace}
-------

Aruncă o excepție `Latte\RuntimeException`, al cărei stack trace este în spiritul șabloanelor. Adică, în loc de apeluri de funcții și metode, conține apeluri de blocuri și includeri de șabloane. Dacă utilizați un instrument pentru afișarea clară a excepțiilor aruncate, cum ar fi [Tracy|tracy:], vi se va afișa clar call stack-ul, inclusiv toți argumentii transmiși.


Ajutoare pentru coderul HTML
============================


n:class
-------

Datorită `n:class`, generați foarte ușor atributul HTML `class` exact conform așteptărilor.

Exemplu: am nevoie ca elementul activ să aibă clasa `active`:

```latte
{foreach $items as $item}
	<a n:class="$item->isActive() ? active">...</a>
{/foreach}
```

Și în plus, ca primul element să aibă clasele `first` și `main`:

```latte
{foreach $items as $item}
	<a n:class="$item->isActive() ? active, $iterator->first ? 'first main'">...</a>
{/foreach}
```

Și toate elementele trebuie să aibă clasa `list-item`:

```latte
{foreach $items as $item}
	<a n:class="$item->isActive() ? active, $iterator->first ? 'first main', list-item">...</a>
{/foreach}
```

Uimitor de simplu, nu-i așa?


n:attr
------

Atributul `n:attr` poate genera orice atribute HTML cu aceeași eleganță ca [n:class|#n:class].

```latte
{foreach $data as $item}
	<input type="checkbox" n:attr="value: $item->getValue(), checked: $item->isActive()">
{/foreach}
```

În funcție de valorile returnate, afișează de ex.:

```latte
<input type="checkbox">

<input type="checkbox" value="Hello">

<input type="checkbox" value="Hello" checked>
```


n:tag
-----

Atributul `n:tag` poate schimba dinamic numele elementului HTML.

```latte
<h1 n:tag="$heading" class="main">{$title}</h1>
```

Dacă `$heading === null`, se va afișa neschimbat tag-ul `<h1>`. Altfel, numele elementului se schimbă în valoarea variabilei, deci pentru `$heading === 'h3'` se va afișa:

```latte
<h3 class="main">...</h3>
```

Deoarece Latte este un sistem de șabloane sigur, verifică dacă noul nume al tag-ului este valid și nu conține valori nedorite sau dăunătoare.


n:ifcontent
-----------

Previne afișarea unui element HTML gol, adică un element care nu conține nimic altceva decât spații.

```latte
<div>
	<div class="error" n:ifcontent>{$error}</div>
</div>
```

Afișează în funcție de valoarea variabilei `$error`:

```latte
{* $error = '' *}
<div>
</div>

{* $error = 'Required' *}
<div>
	<div class="error">Required</div>
</div>
```


Traduceri
=========

Pentru ca tag-urile de traducere să funcționeze, trebuie [activat traducătorul|develop#TranslatorExtension]. Pentru traducere puteți folosi și filtrul [`translate`|filters#translate].


`{_...}`
--------

Traduce valorile în alte limbi.

```latte
<a href="basket">{_'Košík'}</a>
<span>{_$item}</span>
```

Traducătorului i se pot transmite și alți parametri:

```latte
<a href="basket">{_'Košík', domain: order}</a>
```


`{translate}`
-------------

Traduce părți ale șablonului:

```latte
<h1>{translate}Comandă{/translate}</h1>

{translate domain: order}Lorem ipsum ...{/translate}
```

Tag-ul poate fi scris și ca [n:atribut|syntax#n:atributy], pentru traducerea interiorului elementului:

```latte
<h1 n:translate>Comandă</h1>
```
