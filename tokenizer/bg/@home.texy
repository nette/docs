Tokenizer: Токенизация на низове
********************************

.[perex]
Tokenizer е прост инструмент, който използва регулярни изрази за разделяне на даден низ на токени. Може би се питате за какво е това? Можете да създадете свои собствени езици.

*(За по-опитни програмисти)*

Монтаж:

```shell
composer require nette/tokenizer
```


Токенизация на низове .[#toc-string-tokenization]
-------------------------------------------------

Нека създадем прост токенизатор, който разделя низовете на числа, интервали и букви.

```php
$tokenizer = new Nette\Tokenizer\Tokenizer([
	T_DNUMBER => '\d+',
	T_WHITESPACE => '\s+',
	T_STRING => '\w+',
]);
```

Подсказка: Ако се чудите откъде идват константите T_, те са "вътрешният тип:https://www.php.net/manual/tokens.php", който се използва за анализ на кода. Те покриват повечето от обичайните имена на символи, които обикновено са ни необходими. Не забравяйте, че значението им не е гарантирано, затова не използвайте числата за сравнение.

Сега, когато му подадем низ, той ще върне [поток от |api:Nette\Tokenizer\Stream] [символи |api:Nette\Tokenizer\Token].

```php
$stream = $tokenizer->tokenize("say \n123");
```

Полученият масив от токени `$stream->tokens` ще изглежда така

```php
[
	new Token('say', T_STRING, 0),
	new Token(" \n", T_WHITESPACE, 3),
	new Token('123', T_DNUMBER, 5),
]
```

Можете също така да получите достъп до свойствата на отделните токени:

```php
$firstToken = $stream->tokens[0];
$firstToken->value; // значение
$firstToken->type; // значение T_STRING
$firstToken->offset; // позиция в строке: 0
```

Просто, нали?


Обработка на токени .[#toc-processing-the-tokens]
-------------------------------------------------

Вече знаем как да създаваме токени от низ. Нека ги обработим ефективно с помощта на [поток |api:Nette\Tokenizer\Stream]. Той има много страхотни методи, ако трябва да преместите жетони наоколо!

Нека се опитаме да анализираме една проста анотация от PHPDoc и да създадем обект от нея. Какви регулярни изрази ни трябват за токените? Всички анотации започват с `@`, последвани от име, интервали и стойност.

- `@` за началото на анотацията
- `\s+` за пространства
- `\w+` за струнни инструменти

.[note]
Никога не използвайте улавящи подшаблони в регулярни изрази на Tokenizer, като например `'(ab)+c'`, а само не улавящи `'(?:ab)+c'`.

Това би трябвало да работи с прости анотации, нали? Сега нека покажем входния низ, който ще се опитаме да анализираме.

```php
$input = '
	@author David Grudl
	@package Nette
';
```

Нека създадем клас `Parser`, който ще приеме низ и ще върне масив от двойки '['име, стойност |имя, значение]''. Това ще бъде много просто.

```php
use Nette\Tokenizer\Tokenizer;
use Nette\Tokenizer\Stream;

class Parser
{
	const T_AT = 1;
	const T_WHITESPACE = 2;
	const T_STRING = 3;

	private Tokenizer $tokenizer;
	private Stream $stream;

	public function __construct()
	{
		$this->tokenizer = new Tokenizer([
			self::T_AT => '@',
			self::T_WHITESPACE => '\s+',
			self::T_STRING => '\w+',
		]);
	}

	public function parse(string $input): array
	{
		$this->stream = $this->tokenizer->tokenize($input);

		$result = [];
		while ($this->stream->nextToken()) {
			if ($this->stream->isCurrent(self::T_AT)) {
				$result[] = $this->parseAnnotation();
			}
		}

		return $result;
	}

	private function parseAnnotation(): array
	{
		$name = $this->stream->joinUntil(self::T_WHITESPACE);
		$this->stream->nextUntil(self::T_STRING);
		$content = $this->stream->joinUntil(self::T_AT);

		return [$name, trim($content)];
	}
}
```

```php
$parser = new Parser;
$annotations = $parser->parse($input);
```

И така, какво прави методът `parse()`? Той преминава през токените и търси `@`, с которого начинаются аннотации. Вызов `nextToken()` и премества курсора към следващия токен. Методът `isCurrent()` проверява дали текущият символ в курсора е от дадения тип. След това, ако `@` найден, метод `parse()` извика `parseAnnotation()`, който очаква анотациите да бъдат в много специфичен формат.

Първо, с помощта на метода `joinUntil()`, нишката продължава да движи курсора и да добавя стойности на токени към буфера, докато не открие токен от правилния тип, след което спира и връща изхода на буфера. Тъй като на дадена позиция има само един символ от тип `T_STRING` и това е `'name'`, променливата `$name` ще съдържа стойността `'name'`.

Методът `nextUntil()` е подобен на `joinUntil()`, но при него няма буфер. Той премества курсора само докато намери символ. Затова това извикване просто пропуска всички интервали след името на анотацията.

И след това има още един `joinUntil()`, който търси следния `@`. Этот конкретный вызов вернет ``David Grudl\n`.

И ето, че цялата анотация е уредена! Вероятно `$content` завършва с интервали, така че трябва да го отрежем. Сега можем да върнем тази конкретна анотация като двойка `[$name, $content]`.

Опитайте да копирате кода и да го стартирате. Ако нулирате променливата `$annotations`, ще получите подобен резултат.

```
array (2)
   0 => array (2)
   |  0 => 'author'
   |  1 => 'David Grudl'
   1 => array (2)
   |  0 => 'package'
   |  1 => 'Nette'
```


Методи за стрийминг .[#toc-stream-methods]
------------------------------------------

Потокът може да върне текущия токен с помощта на метода `currentToken()` или само неговата стойност с помощта на `currentValue()`.

`nextToken()` премества курсора и връща символа. Ако не му дадете никакви аргументи, той просто връща следващия символ.

`nextValue()` подобно на `nextToken()`, но връща само стойността на маркера.

Повечето методи приемат и няколко аргумента, така че можете да търсите няколко типа едновременно.

```php
// итерация до тех пор, пока не будет найдена строка или пробел, затем возвращает следующий токен
$token = $stream->nextToken(T_STRING, T_WHITESPACE);

// получить следующий токен
$token = $stream->nextToken();
```

Можете също така да търсите по стойност на токена.

```php
// перемещайте курсор, пока не найдете лексему, содержащую только '@', затем остановитесь и верните её обратно
$token = $stream->nextToken('@');
```

`nextUntil()` премества курсора и връща масив от всички срещнати лексеми, докато намери правилната лексема, но спира преди нея. Тя може да приема няколко аргумента.

`joinUntil()` Подобно на `nextUntil()`, но конкатенира всички подадени токени и връща низ.

`joinAll()` просто конкатенира всички останали стойности на символите и ги връща. Премества курсора до края на потока от символи

`nextAll()` като `joinAll()`, но връща масив от токени.

`isCurrent()` проверява дали текущият токен или стойността на текущия токен е равна на един от дадените аргументи.

```php
// является ли текущий поток токеном '@' или типом T_AT?
$stream->isCurrent(T_AT, '@');
```

`isNext()` като `isCurrent()`, но проверява следващия символ.

`isPrev()` Подобно на `isCurrent()`, но проверява предишния символ.

А последният метод `reset()` нулира курсора, за да можете отново да обхождате потока от символи.


{{leftbar: utils:@left-menu}}
