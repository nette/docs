Comment fonctionnent les applications ?
***************************************

<div class=perex>

Vous Ãªtes en train de lire le document de base de la documentation Nette. Vous y apprendrez tous les principes des applications web. Nice de A Ã  Z, du moment de la naissance jusqu'au dernier souffle du script PHP. AprÃ¨s la lecture, vous saurez :

- comment tout cela fonctionne
- ce qu'est Bootstrap, Presenter et le conteneur DI
- Ã  quoi ressemble la structure des rÃ©pertoires

</div>


Structure du rÃ©pertoire .[#toc-directory-structure]
===================================================

Ouvrez un exemple de squelette d'une application web appelÃ©e [WebProject |https://github.com/nette/web-project] et vous pouvez observer les fichiers sur lesquels on Ã©crit.

La structure des rÃ©pertoires ressemble Ã  ceci :

/--pre
<b>web-project/</b>
â”œâ”€â”€ <b>app/</b>                      â† rÃ©pertoire avec application
â”‚   â”œâ”€â”€ <b>Presenters/</b>           â† classes d'presenter
â”‚   â”‚   â”œâ”€â”€ <b>HomepagePresenter.php</b>  â† Homepage classe des prÃ©sentateurs
â”‚   â”‚   â””â”€â”€ <b>templates/</b>        â† rÃ©pertoire des modÃ¨les
â”‚   â”‚       â”œâ”€â”€ <b>@layout.latte</b> â† modÃ¨le de disposition partagÃ©e
â”‚   â”‚       â””â”€â”€ <b>Homepage/</b>     â† ModÃ¨les pour le prÃ©sentateur de la page d'accueil
â”‚   â”‚           â””â”€â”€ <b>default.latte</b>  â† modÃ¨le pour l'action `default`
â”‚   â”œâ”€â”€ <b>Router/</b>               â† configuration des adresses URL
â”‚   â””â”€â”€ <b>Bootstrap.php</b>         â† classe de dÃ©marrage Bootstrap
â”œâ”€â”€ <b>bin/</b>                      â† scripts pour la ligne de commande
â”œâ”€â”€ <b>config/</b>                   â† configuration files
â”‚   â”œâ”€â”€ <b>common.neon</b>
â”‚   â””â”€â”€ <b>local.neon</b>
â”œâ”€â”€ <b>log/</b>                      â† journaux d'erreurs
â”œâ”€â”€ <b>temp/</b>                     â† fichiers temporaires, cache, â€¦
â”œâ”€â”€ <b>vendor/</b>                   â† bibliothÃ¨ques installÃ©es par Composer
â”‚   â”œâ”€â”€ ...
â”‚   â””â”€â”€ <b>autoload.php</b>          â† autoloading of libs installed by Composer
â”œâ”€â”€ <b>www/</b>                      â† rÃ©pertoire public, racine du document du projet
â”‚   â”œâ”€â”€ <b>.htaccess</b>             â† rÃ¨gles du mod_rewrite, etc.
â”‚   â””â”€â”€ <b>index.php</b>             â† fichier initial qui lance l'application
â””â”€â”€ <b>.htaccess</b>                 â† interdit l'accÃ¨s Ã  tous les rÃ©pertoires sauf www
\--

Vous pouvez modifier la structure des rÃ©pertoires de n'importe quelle maniÃ¨re, renommer ou dÃ©placer des dossiers, puis modifier simplement les chemins d'accÃ¨s Ã  `log/` et `temp/` dans le fichier `Bootstrap.php` et le chemin d'accÃ¨s Ã  ce fichier dans `composer.json` dans la section `autoload`. Rien de plus, pas de reconfiguration compliquÃ©e, pas de changements constants. Nette dispose d'une [autodÃ©tection intelligente |bootstrap#development-vs-production-mode].

Pour les applications un peu plus importantes, nous pouvons diviser les dossiers contenant des prÃ©sentateurs et des modÃ¨les en sous-rÃ©pertoires (sur le disque) et en espaces de noms (dans le code), que nous appelons [modules].

Le rÃ©pertoire `www/` est le rÃ©pertoire public ou la racine du document du projet. Vous pouvez le renommer sans avoir Ã  dÃ©finir quoi que ce soit d'autre du cÃ´tÃ© de l'application. Il suffit de [configurer l'hÃ©bergement |nette:troubleshooting#How to change or remove www directory from URL] pour que le document-root aille dans ce rÃ©pertoire.

Vous pouvez Ã©galement tÃ©lÃ©charger directement le projet Web, y compris Nette, en utilisant [Composer |best-practices:composer]:

```shell
composer create-project nette/web-project
```

Sous Linux ou macOS, dÃ©finissez les [droits d'Ã©criture |nette:troubleshooting#Setting directory permissions] pour les rÃ©pertoires `log/` et `temp/`.

L'application WebProject est prÃªte Ã  fonctionner, il n'est pas nÃ©cessaire de configurer quoi que ce soit d'autre et vous pouvez la visualiser directement dans le navigateur en accÃ©dant au dossier `www/`.


Demande HTTP .[#toc-http-request]
=================================

Tout commence lorsqu'un utilisateur ouvre la page dans un navigateur et que le navigateur frappe le serveur avec une requÃªte HTTP. La requÃªte est dirigÃ©e vers un fichier PHP situÃ© dans le rÃ©pertoire public `www/`, qui est `index.php`. Supposons qu'il s'agisse d'une requÃªte vers `https://example.com/product/123` et sera exÃ©cutÃ©e.

Sa tÃ¢che est la suivante :

1) initialiser l'environnement
2) rÃ©cupÃ©rer l'usine
3) lancer l'application Nette qui traite la demande.

Quel genre d'usine ? Nous ne produisons pas de tracteurs, mais des sites web ! Attendez, je vais vous expliquer tout de suite.

Par "initialiser l'environnement", nous voulons dire, par exemple, que [Tracy |tracy:] est activÃ©, qui est un outil Ã©tonnant pour consigner ou visualiser les erreurs. Il enregistre les erreurs sur le serveur de production et les affiche directement sur le serveur de dÃ©veloppement. Par consÃ©quent, l'initialisation doit Ã©galement dÃ©cider si le site fonctionne en mode production ou en mode dÃ©veloppement. Pour ce faire, Nette utilise l'autodÃ©tection : si vous exÃ©cutez le site sur localhost, il fonctionne en mode dÃ©veloppeur. Vous n'avez rien Ã  configurer et l'application est prÃªte Ã  Ãªtre dÃ©ployÃ©e aussi bien en dÃ©veloppement qu'en production. Ces Ã©tapes sont rÃ©alisÃ©es et dÃ©crites en dÃ©tail dans le chapitre sur la [classe Bootstrap |bootstrap].

Le troisiÃ¨me point (oui, nous avons sautÃ© le deuxiÃ¨me, mais nous y reviendrons) consiste Ã  dÃ©marrer l'application. Le traitement des demandes HTTP dans Nette est effectuÃ© par la classe `Nette\Application\Application` (ci-aprÃ¨s dÃ©nommÃ©e `Application`), donc lorsque nous disons "lancer une application", nous voulons dire appeler une mÃ©thode portant le nom `run()` sur un objet de cette classe.

Nette est un mentor qui vous guide pour Ã©crire des applications propres grÃ¢ce Ã  des mÃ©thodologies Ã©prouvÃ©es. Et la plus Ã©prouvÃ©e est appelÃ©e **injection de dÃ©pendance**, en abrÃ©gÃ© DI. Pour l'instant, nous ne voulons pas vous ennuyer avec l'explication de DI, car il y a un [chapitre sÃ©parÃ© |dependency-injection:introduction], la chose importante ici est que les objets clÃ©s seront gÃ©nÃ©ralement crÃ©Ã©s par une usine pour les objets appelÃ©s **conteneur DI** (abrÃ©gÃ© DIC). Oui, c'est la fabrique dont on a parlÃ© il y a un moment. Et elle crÃ©e Ã©galement l'objet `Application` pour nous, donc nous avons d'abord besoin d'un conteneur. Nous l'obtenons en utilisant la classe `Configurator` et la laissons produire l'objet `Application`, appelons la mÃ©thode `run()` et cela dÃ©marre l'application Nette. C'est exactement ce qui se passe dans le fichier [index.php |bootstrap#index.php].


Application Nette .[#toc-nette-application]
===========================================

La classe Application a une seule tÃ¢che : rÃ©pondre Ã  une requÃªte HTTP.

Les applications Ã©crites dans Nette sont divisÃ©es en plusieurs prÃ©sentateurs (dans d'autres frameworks, vous pouvez rencontrer le terme contrÃ´leur, qui est le mÃªme), qui sont des classes reprÃ©sentant une page spÃ©cifique du site Web : par exemple, la page d'accueil, un produit dans une boutique en ligne, un formulaire d'inscription, un flux sitemap, etc. L'application peut avoir de un Ã  plusieurs milliers de prÃ©sentateurs.

L'application commence par demander Ã  ce qu'on appelle le routeur de dÃ©cider lequel des prÃ©sentateurs doit transmettre la demande actuelle pour traitement. Le routeur dÃ©cide de la responsabilitÃ© qui lui incombe. Il examine l'URL d'entrÃ©e `https://example.com/product/123`, qui veut `show` un produit avec `id: 123` comme action. C'est une bonne habitude d'Ã©crire une paire prÃ©sentateur + action sÃ©parÃ©e par un deux-points comme `Product:show`.

Le routeur transforme donc l'URL en une paire `Presenter:action` + paramÃ¨tres, dans notre cas `Product:show` + `id: 123`. Vous pouvez voir Ã  quoi ressemble un routeur dans le fichier `app/Router/RouterFactory.php` et nous le dÃ©crirons en dÃ©tail dans le chapitre [Routage |Routing].

Continuons. L'application connaÃ®t dÃ©jÃ  le nom du prÃ©sentateur et peut continuer. En crÃ©ant un objet `ProductPresenter`, qui est le code du prÃ©sentateur `Product`. Plus prÃ©cisÃ©ment, elle demande au conteneur DI de crÃ©er le prÃ©sentateur, car la production d'objets est son travail.

Le prÃ©sentateur pourrait ressembler Ã  ceci :

```php
class ProductPresenter extends Nette\Application\UI\Presenter
{
	public function __construct(
		private ProductRepository $repository,
	) {
	}

	public function renderShow(int $id): void
	{
		// nous obtenons des donnÃ©es du modÃ¨le et les transmettons au modÃ¨le
		$this->template->product = $this->repository->getProduct($id);
	}
}
```

La demande est traitÃ©e par le prÃ©sentateur. Et la tÃ¢che est claire : faire l'action `show` avec `id: 123`. Ce qui dans le langage des prÃ©sentateurs signifie que la mÃ©thode `renderShow()` est appelÃ©e et que dans le paramÃ¨tre `$id` on obtient `123`.

Un prÃ©sentateur peut gÃ©rer plusieurs actions, c'est-Ã -dire avoir plusieurs mÃ©thodes. `render<Action>()`. Mais nous recommandons de concevoir des prÃ©sentateurs avec une ou aussi peu d'actions que possible.

Ainsi, la mÃ©thode `renderShow(123)` a Ã©tÃ© appelÃ©e, dont le code est un exemple fictif, mais vous pouvez y voir comment les donnÃ©es sont transmises au modÃ¨le, c'est-Ã -dire en Ã©crivant Ã  `$this->template`.

Ensuite, le prÃ©sentateur renvoie la rÃ©ponse. Cela peut Ãªtre une page HTML, une image, un document XML, l'envoi d'un fichier depuis le disque, JSON ou la redirection vers une autre page. Il est important de noter que si nous ne disons pas explicitement comment rÃ©pondre (ce qui est le cas de `ProductPresenter`), la rÃ©ponse sera de rendre le modÃ¨le avec une page HTML. Pourquoi ? Eh bien, parce que dans 99% des cas, nous voulons dessiner un modÃ¨le, donc le prÃ©sentateur prend ce comportement par dÃ©faut et veut nous faciliter le travail. C'est le point de vue de Nette.

Nous n'avons mÃªme pas besoin d'indiquer quel modÃ¨le dessiner, il dÃ©rive le chemin vers celui-ci selon une logique simple. Dans le cas du prÃ©sentateur `Product` et de l'action `show`, il essaie de voir si l'un de ces fichiers modÃ¨les existe par rapport au rÃ©pertoire oÃ¹ se trouve la classe `ProductPresenter`:

- `templates/Product/show.latte`
- `templates/Product.show.latte`

Il essaiera Ã©galement de trouver la mise en page dans le fichier `@layout.latte`, puis il effectuera le rendu du modÃ¨le. La tÃ¢che du prÃ©sentateur et de l'ensemble de l'application est maintenant terminÃ©e. Si le modÃ¨le n'existe pas, une page d'erreur 404 sera renvoyÃ©e. Vous pouvez en savoir plus sur les prÃ©sentateurs sur la page [PrÃ©sentateurs |Presenters].

[* request-flow.svg *]

Juste pour Ãªtre sÃ»r, essayons de rÃ©capituler l'ensemble du processus avec une URL lÃ©gÃ¨rement diffÃ©rente :

1) l'URL sera `https://example.com`
2) nous dÃ©marrons l'application, nous crÃ©ons un conteneur et nous l'exÃ©cutons `Application::run()`
3) le routeur dÃ©code l'URL comme une paire `Homepage:default`
4) un objet `HomepagePresenter` est crÃ©Ã©
5) la mÃ©thode `renderDefault()` est appelÃ©e (si elle existe)
6) un modÃ¨le `templates/Homepage/default.latte` avec une mise en page `templates/@layout.latte` est rendu


Vous avez peut-Ãªtre rencontrÃ© beaucoup de nouveaux concepts maintenant, mais nous pensons qu'ils ont un sens. CrÃ©er des applications dans Nette est un jeu d'enfant.


ModÃ¨les .[#toc-templates]
=========================

En ce qui concerne les modÃ¨les, Nette utilise le systÃ¨me de modÃ¨les [Latte |latte:]. C'est pourquoi les fichiers contenant des modÃ¨les se terminent par `.latte`. Latte est utilisÃ© parce que c'est le systÃ¨me de modÃ¨les le plus sÃ»r pour PHP, et en mÃªme temps le systÃ¨me le plus intuitif. Vous n'avez pas besoin d'apprendre grand-chose de nouveau, il vous suffit de connaÃ®tre PHP et quelques balises Latte. Vous trouverez tout [dans la documentation |latte:].

Dans le template, nous [crÃ©ons un lien |creating-links] vers d'autres prÃ©sentateurs et actions comme suit :

```latte
<a n:href="Product:show $productId">product detail</a>
```

Il suffit d'Ã©crire la paire familiÃ¨re `Presenter:action` au lieu de l'URL rÃ©elle et d'inclure tous les paramÃ¨tres. L'astuce est `n:href`, qui indique que cet attribut sera traitÃ© par Nette. Et elle le fera :

```latte
<a href="/product/456">product detail</a>
```

Le routeur mentionnÃ© prÃ©cÃ©demment est chargÃ© de gÃ©nÃ©rer l'URL. En fait, les routeurs de Nette sont uniques en ce sens qu'ils peuvent non seulement transformer une URL en une paire prÃ©sentateur:action, mais aussi, Ã  l'inverse, gÃ©nÃ©rer une URL Ã  partir du nom du prÃ©sentateur + action + paramÃ¨tres.
GrÃ¢ce Ã  cela, dans Nette, vous pouvez changer complÃ¨tement la forme de l'URL dans toute l'application finie sans changer un seul caractÃ¨re dans le modÃ¨le ou le prÃ©sentateur, juste en modifiant le routeur.
Et grÃ¢ce Ã  cela, ce que l'on appelle la canonisation fonctionne, ce qui est une autre caractÃ©ristique unique de Nette, qui amÃ©liore le SEO (optimisation de la facilitÃ© de recherche sur Internet) en empÃªchant automatiquement l'existence de contenu dupliquÃ© Ã  diffÃ©rentes URL.
De nombreux programmeurs trouvent cela Ã©tonnant.


Composants interactifs .[#toc-interactive-components]
=====================================================

Nous avons encore une chose Ã  vous dire sur les prÃ©sentateurs : ils ont un systÃ¨me de composants intÃ©grÃ©. Les plus anciens d'entre vous se souviennent peut-Ãªtre de quelque chose de similaire dans Delphi ou ASP.NET Web Forms. React ou Vue.js sont construits sur quelque chose de trÃ¨s similaire. Dans le monde des frameworks PHP, il s'agit d'une fonctionnalitÃ© tout Ã  fait unique.

Les composants sont des unitÃ©s distinctes rÃ©utilisables que nous plaÃ§ons dans des pages (c'est-Ã -dire des prÃ©sentateurs). Il peut s'agir de [formulaires |forms:in-presenter], de [grilles de donnÃ©es |https://componette.org/contributte/datagrid/], de menus, de sondages, en fait de tout ce qui peut Ãªtre utilisÃ© de maniÃ¨re rÃ©pÃ©tÃ©e. Nous pouvons crÃ©er nos propres composants ou utiliser une partie de la [vaste gamme |https://componette.org] de composants open source.

Les composants modifient fondamentalement l'approche du dÃ©veloppement d'applications. Ils ouvrent de nouvelles possibilitÃ©s pour composer des pages Ã  partir d'unitÃ©s prÃ©dÃ©finies. Et ils ont quelque chose en commun avec [Hollywood |components#Hollywood style].


Conteneur et configuration de DI .[#toc-di-container-and-configuration]
=======================================================================

Le conteneur DI (fabrique d'objets) est le cÅ“ur de toute l'application.

Ne vous inquiÃ©tez pas, il ne s'agit pas d'une boÃ®te noire magique, comme cela pourrait sembler dans les mots prÃ©cÃ©dents. En fait, il s'agit d'une classe PHP assez ennuyeuse gÃ©nÃ©rÃ©e par Nette et stockÃ©e dans un rÃ©pertoire de cache. Elle possÃ¨de un grand nombre de mÃ©thodes nommÃ©es `createServiceAbcd()` et chacune d'entre elles crÃ©e et renvoie un objet. Oui, il y a aussi une mÃ©thode `createServiceApplication()` qui produit `Nette\Application\Application`, dont nous avons besoin dans le fichier `index.php` pour exÃ©cuter l'application. Et il y a des mÃ©thodes pour produire des prÃ©sentateurs individuels. Et ainsi de suite.

Les objets que le conteneur DI crÃ©e sont appelÃ©s services pour une raison quelconque.

Ce qui est vraiment spÃ©cial Ã  propos de cette classe est qu'elle n'est pas programmÃ©e par vous, mais par le framework. Il gÃ©nÃ¨re en fait le code PHP et l'enregistre sur le disque. Vous donnez simplement des instructions sur les objets que le conteneur doit Ãªtre capable de produire et comment exactement. Ces instructions sont Ã©crites dans des [fichiers de configuration |bootstrap#DI Container Configuration] au [format NEON |neon:format] et portent donc l'extension `.neon`.

Les fichiers de configuration sont utilisÃ©s uniquement pour donner des instructions au conteneur DI. Ainsi, par exemple, si je spÃ©cifie l'option `expiration: 14 days` dans la section [session |http:configuration#Session], le conteneur DI, lorsqu'il crÃ©era l'objet `Nette\Http\Session` reprÃ©sentant la session, appellera sa mÃ©thode `setExpiration('14 days')`, et la configuration deviendra ainsi une rÃ©alitÃ©.

Un chapitre entier est prÃªt pour vous, dÃ©crivant ce qui peut Ãªtre [configurÃ© |nette:configuring] et comment [dÃ©finir vos propres services |dependency-injection:services].

Lorsque vous entrerez dans la crÃ©ation de services, vous rencontrerez le mot [autowiring |dependency-injection:autowiring]. Il s'agit d'un gadget qui vous rendra la vie incroyablement plus facile. Il permet de passer automatiquement des objets lÃ  oÃ¹ vous en avez besoin (dans les constructeurs de vos classes, par exemple) sans avoir Ã  faire quoi que ce soit. Vous constaterez que le conteneur DI de Nette est un petit miracle.


Et maintenant ? .[#toc-what-next]
=================================

Nous avons passÃ© en revue les principes de base des applications dans Nette. Jusqu'ici, trÃ¨s superficiellement, mais vous allez bientÃ´t plonger dans les profondeurs et finalement crÃ©er de merveilleuses applications web. OÃ¹ continuer ? Avez-vous essayÃ© le tutoriel [CrÃ©er votre premiÃ¨re application |quickstart:]?

En plus de ce qui prÃ©cÃ¨de, Nette dispose de tout un arsenal de [classes utiles |utils:], d'une [couche de base de donnÃ©es |database:], etc. Essayez volontairement de cliquer sur la documentation. Ou visitez le [blog |https://blog.nette.org]. Vous dÃ©couvrirez beaucoup de choses intÃ©ressantes.

Laissez le framework vous apporter beaucoup de joie ğŸ’™
