Latte функции
*************

.[perex]
В шаблоните, освен обикновените PHP функции, можем да използваме и следните допълнителни функции.

.[table-latte-filters]
| `clamp`      | [ограничава стойността в даден диапазон |#clamp]
| `divisibleBy`| [проверява дали променливата се дели на число |#divisibleBy]
| `even`       | [проверява дали даденото число е четно |#even]
| `first`      | [връща първия елемент на масив или знак от низ |#first]
| `group`      | [групира данни по различни критерии |#group]
| `hasBlock`   | [проверява съществуването на блок |#hasBlock]
| `last`       | [връща последния елемент на масив или знак от низ |#last]
| `odd`        | [проверява дали даденото число е нечетно |#odd]
| `slice`      | [извлича част от масив или низ |#slice]


Използване
==========

Функциите се използват по същия начин като обикновените PHP функции и могат да се използват във всички изрази:

```latte
<p>{clamp($num, 1, 100)}</p>

{if odd($num)} ... {/if}
```

[Потребителски функции|custom-functions] могат да се регистрират по следния начин:

```php
$latte = new Latte\Engine;
$latte->addFunction('shortify', fn(string $s, int $len = 10) => mb_substr($s, 0, $len));
```

В шаблона след това се извиква така:

```latte
<p>{shortify($text)}</p>
<p>{shortify($text, 100)}</p>
```


Функции
=======


clamp(int|float $value, int|float $min, int|float $max): int|float .[method]
----------------------------------------------------------------------------
Ограничава стойността в дадения инклузивен диапазон min и max.

```latte
{=clamp($level, 0, 255)}
```

Вижте също [филтър clamp|filters#clamp].


divisibleBy(int $value, int $by): bool .[method]
------------------------------------------------
Проверява дали променливата се дели на число.

```latte
{if divisibleBy($num, 5)} ... {/if}
```


even(int $value): bool .[method]
--------------------------------
Проверява дали даденото число е четно.

```latte
{if even($num)} ... {/if}
```


first(string|iterable $value): mixed .[method]
----------------------------------------------
Връща първия елемент на масив или знак от низ:

```latte
{=first([1, 2, 3, 4])}    {* извежда 1 *}
{=first('abcd')}          {* извежда 'a' *}
```

Вижте също [#last], [филтър first|filters#first].


group(iterable $data, string|int|\Closure $by): array .[method]{data-version:3.0.16}
------------------------------------------------------------------------------------
Функцията групира данни по различни критерии.

В този пример редовете в таблицата се групират по колона `categoryId`. Изходът е масив от масиви, където ключът е стойността в колоната `categoryId`. [Прочетете подробно ръководство|cookbook/grouping].

```latte
{foreach group($items, categoryId) as $categoryId => $categoryItems}
    <ul>
        {foreach $categoryItems as $item}
            <li>{$item->name}</li>
        {/foreach}
    </ul>
{/foreach}
```

Вижте също филтъра [group|filters#group].


hasBlock(string $name): bool .[method]{data-version:3.0.10}
-----------------------------------------------------------
Проверява дали блок с посоченото име съществува:

```latte
{if hasBlock(header)} ... {/if}
```

Вижте също [проверка за съществуване на блокове|template-inheritance#Kontrola existence bloků].


last(string|array $value): mixed .[method]
------------------------------------------
Връща последния елемент на масив или знак от низ:

```latte
{=last([1, 2, 3, 4])}    {* извежда 4 *}
{=last('abcd')}          {* извежда 'd' *}
```

Вижте също [#first], [филтър last|filters#last].


odd(int $value): bool .[method]
-------------------------------
Проверява дали даденото число е нечетно.

```latte
{if odd($num)} ... {/if}
```


slice(string|array $value, int $start, ?int $length=null, bool $preserveKeys=false): string|array .[method]
-----------------------------------------------------------------------------------------------------------
Извлича част от масив или низ.

```latte
{=slice('hello', 1, 2)}           {* извежда 'el' *}
{=slice(['a', 'b', 'c'], 1, 2)}   {* извежда ['b', 'c'] *}
```

Филтърът работи като PHP функцията `array_slice` за масиви или `mb_substr` за низове с резервен вариант към функцията `iconv_substr` в режим UTF‑8.

Ако start е положителен, последователността ще започне изместена с този брой от началото на масива/низа. Ако е отрицателен, последователността ще започне изместена с толкова от края.

Ако е зададен параметър length и е положителен, последователността ще съдържа толкова елементи. Ако в тази функция се предаде отрицателен параметър length, последователността ще съдържа всички елементи на оригиналния масив, започвайки от позиция start и завършвайки на позиция, по-малка с length елементи от края на масива. Ако не зададете този параметър, последователността ще съдържа всички елементи на оригиналния масив, започвайки от позиция start.

По подразбиране филтърът променя реда и нулира целочислените ключове на масива. Това поведение може да се промени, като се зададе preserveKeys на true. Низовите ключове винаги се запазват, независимо от този параметър.
