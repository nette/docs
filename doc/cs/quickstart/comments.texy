Komentáře
*********

Nahráli jsme blog, publikovali několik velmi zajímavých příspěvků pomocí Admineru. Lidé čtou náš blog a jsou z něho velmi nadšení. Dostáváme každý den mnoho emailů s pochvalou, ale k čemu je všechna tato chvála, pokud ji máme pouze v emailu a nikdo si ji nemůže přečíst? Bylo by lepší, kdyby mohl čtenář článek přímo komentovat, takže by si mohl každý přečíst, jak jsme úžasní.

Pojďme tedy vytvořit možnost ke komentování všech článků.


Tvorba nové tabulky
====================

Pomocí Admineru opět vytvořte tabulku, tentokrát se jménem `comments`. Tabulka bude obsahovat následující sloupce:

- `id` int, zaškrněte autoincrement (AI)
- `post_id`, cizí klíč, který odkazuje na tabulku `posts`
- `name` varchar, length 255
- `email` varchar, length 255
- `content` text
- `created_at` timestamp

Tabulka by tedy měla vypadat nějak takto:

[* adminer-comments.png *]

Nezapomeňte opět použít úložiště InnoDB.


Formulář pro komentování
===================

Prvně musíme vytvořit fomrulář, který umožní uživatelům příspěvky komentovat. Nette Framework má úžasnou podporu pro formuláře. Můžou být nastaveny v presenteru a vykresleny v šabloně.

Nette Framework využívá koncept *komponent*. **Komponenta** je znovupoužitelná třída, nebo část kódu, který může být přiložen k jiné komponentě. Presenter je také komponenta. Každá komponenta je vytvořena prostřednictvím továrniček. Definujme tedy továrničku pro formulář na komentáře v presenteru `PostPresenter`.

/--php
        protected function createComponentCommentForm()
        {
                $form = new Nette\Application\UI\Form;

                $form->addText('name', 'Jméno:')
                        ->setRequired();

                $form->addText('email', 'Email:');

                $form->addTextArea('content', 'Komentář:')
                        ->setRequired();

                $form->addSubmit('send', 'Publikovat komenntář');

                return $form;
        }
\--

První řádka vytvoří novou instanci komponenty `Form`. Následující metody připojují HTML inputy do definice tohoto formuláře. `->addText` se vykreslí jako `<input type=text name=name>` s `<label>Jméno:</label>`. Jak již zřejmě správně odhadujete, tak `->addTextArea` se vykreslí jako `<textarea>` a `->addSubmit` jako `<input type=submit>`. Existuje daleko více obdobných metod, ale tyto zatím pro tento formulář stačí. Více se [dočtete v dokumentaci|/forms].

Pokud je již formulář definován v presenteru, můžeme ho vykreslit (zobrazit) v šabloně. To uděláme umístěním makra `{control}` na konec šablony, která vykresluje jeden konkrétní příspěvek (`app/templates/Post/show.latte`). Protože se komponenta jmenuje `commentForm` (název je odvozen od názvu metody `createComponentCommentForm`), makro bude tedy vypadat takto:

/--html
<h2>Vložte nový příspěvek</h2>

{control commentForm}
\--

Když si nyní zobrazíte stránku s detailem příspěvku, na jeho konci uvidíte nový formulář pro komentáře.


Ukládání do databáze
==================

Co se stane když odešlete nějaká data? Formulář neprovede žádnou akci. Pouze je vykreselen, ale nedělá nic. Musí připojit callback metodu, která uloží odeslaná data.

Uvnitř továrničky pro komponentu `commentsForm` umístíme následující kód:

/--php
$form->onSuccess[] = $this->commentFormSucceeded; // bez závorek
\--

Předchozí zápis znamená "po úspěšném odeslání formuláře zavolej metodu `commentFormSucceeded` ze současného presenteru". Zápis `$this->commentFormSucceeded` je jeden ze *syntactic sugars*, které poskytuje objekt [Nette\Object|/php-language-enhancements]. Toto volání se chová jako callback metody. Tato metoda však ještě neexistuje. Pojďme ji tedy vytvořit.

/--php
        public function commentFormSucceeded($form)
        {
                $values = $form->getValues();
                $postId = $this->getParameter('postId');

                $this->database->table('comments')->insert(array(
                        'post_id' => $postId,
                        'name' => $values->name,
                        'email' => $values->email,
                        'content' => $values->content,
                ));

                $this->flashMessage('Děkuji za komentář', 'success');
                $this->redirect('this');
        }
\--

Tuto metodu můžete umístit přímo za továrničku formuláře `commentsForm`.

Tato nová metoda má jeden argument, což je instance formuláře, který byl odeslán - vytvořen továrničkou. Zeptáme se instance formuláře na odeslané hodnoty voláním `$form->getValues()`. Následně uložíme data do databázové tabulky `comments`. 

Ještě jsou zde další dvě metody, které si zaslouží vysvětlit. Redirect metoda doslova přesměrovává zpět na aktuální stránku. Toto je vhodné udělat po každém odeslání formuláře. Pokud přesměrujete stránku po odeslání formuláře, nikdy neuvidíte dobře známou hlášku `Chcete odeslat data z formuláře znovu?`, kterou občas můžete v prohlížeči spatřit. (Obecně platí, že po odeslání formuláře metodou POST by jste měli vždy uživatele přesměrovat na akci GET.)

Metoda `flashMessage` je pro informování uživatele o výsledku nějaké operace. Protože přesměrováváme, zpráva nemůže být jednoduše předána šabloně a vykreslena. Proto je zde metoda, která si tuto zprávu uloží a zpřístupní ji při dalším načtení stránky. Flash zprávy jsou vykreslovány v hlavní šabloně `app/templates/@layout.latte` a vypadají takto:

/--html
<div n:foreach="$flashes as $flash" class="flash {$flash->type}">{$flash->message}</div>
\--

Jak již víme, tak flash zprávy jsou automaticky předávány do šablony. Nemusíte na tím tedy moc přemýšlet, zkrátka to funguje. Pro více informací [navštivte dokumentaci |/presenters#toc-flash-messages].


Vykreslování komentářů
======================

Toto je jedna z věcí, které si zamilujete. Nette\Database má skvělou funkci nazvanou *Selection API*. Pamatujete si, že tabulky v databázi využívají InnoDBúložiště? Adminer tak vytvořil něco, čemu se říká [cizí klíče |http://dev.mysql.com/doc/refman/5.5/en/innodb-foreign-key-constraints.html] a ušetřil nám tak spoustu práce.

Nette\Database použícá cizí klíče pro vyřešení vzájemného vztahu mezi tabulkami databáze. Se znalostí tohoto vztahu umí automaticky vytvořit databázové dotazy.

Jak si jistě pamatujete, do šablony jsme předali proměnnou `$post` pomocí metody `PostPresenter::renderShow()` a nyní chceme iterovat přes všechny komentáře, které mají hodnotu sloupce `post_id` shodnou s `$post->id`. Toho můžete docílit voláním `$post->related('comments')`. Je to velmi jednoduché. Podívejte se na výsledný kód:

/--php
        public function renderShow($postId)
        {
                ...
                $this->template->post = $post;
                $this->template->comments = $post->related('comment')->order('created_at');
        }
\--

A šablonu:

/--html
<h2>Komentáře</h2>

<div class="comments">
        {foreach $comments as $comment}
                <p><b><a href="mailto:{$comment->email}" n:tag-if="$comment->email">{$comment->name}</a></b> said:</p>
                <div>{$comment->content}</div>
        {/foreach}
</div>

\--

Všimněte si speciálního tagu `n:tag-if`. Již víte jak `n:makra` fungují. Pokud k atributu připojíte předponu `tag-`, makro se aplikuje pouze na HTML tagy, ne na jejich obsah. Toto nám umožňuje vytvořit jméno autora komentáře jako odkaz pouze v případě, že poskytl svůj email. Tyto dvě řádky jsou identické:

/--html
<strong n:tag-if="$important"> Dobrý den! </strong>
{if $important}<strong>{/if} Dobrý den! {if $important}</strong>{/if}
\--
