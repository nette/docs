Маршрутизация
*************

<div class=perex>

Маршрутизатор позаботится обо всём, что связано с URL-адресами, так что вам больше не придется о них думать. Давайте покажем:

- как настроить маршрутизатор так, чтобы URL-адреса были такими, какими вы хотите их видеть
- как настроить SEO и перенаправления
- как написать свой собственный маршрутизатор

</div>


Более человеческие URL (или красивые URL) более удобны для использования, лучше запоминаются и вносят положительный вклад в SEO. Фреймворк Nette учитывает это и полностью отвечает требованиям разработчиков.

Давайте начнем немного с технической стороны. Маршрутизатор — это объект, реализующий интерфейс [api:Nette\Routing\Router], который может раскладывать URL на массив параметров (метод `match`) и восстанавливать URL из массива параметров (метод `constructUrl`). Поэтому также говорят, что маршрутизатор является двунаправленным. Nette дает вам возможность определить правила того, как именно должен выглядеть URL вашего приложения, очень элегантным способом.

Маршрутизатор играет важную роль в [приложении Nette|how-it-works#Приложение Nette]. Благодаря маршрутизатору, мы знаем, какого презентера и какое действие необходимо выполнить. Кроме того, маршрутизаторы используются для генерации URL в шаблоне, например:

```latte
<a n:href="Product:detail $productId">страница товара</a>
```

и маршрутизатор строит результирующий URL из этих параметров. Подробнее читайте в главе [Создание ссылок |creating-links].

Однако маршрутизатор не ограничивается этим применением, вы можете использовать его в совершенно других случаях, для REST API, для приложений, где презентеры вообще не используются и т. д. Для получения дополнительной информации см. раздел [#Раздельное использование].

Поэтому маршрутизация — это отдельный и сложный уровень приложения, благодаря которому URL-адреса могут быть разработаны или изменены только тогда, когда всё приложение готово, поскольку это может быть сделано без единого вмешательства в код или шаблоны. Что дает разработчикам огромную свободу.


Коллекция маршрутов
===================

Наиболее приятным способом определения адресов URL в приложении является класс `Nette\Routing\RouteList` соответственно, её потомок [api:Nette\Application\Routers\RouteList], который, в дополнение к родителю, добавляет поддержку презентеров, что нам подходит. Большим преимуществом является то, что весь маршрутизатор определено в одном месте и не так разбросан в виде аннотаций во всех презентерах.

Определение состоит из списка так называемых маршрутов, то есть масок адресов URL и связанных с ними презентеров и действий с использованием простого API. Мы не обязаны давать имена маршрутам.

```php
$router = new Nette\Application\Routers\RouteList;
$router->addRoute('rss.xml', 'Feed:rss');
$router->addRoute('article/<id>', 'Article:view');
// ...
```

В примере говорится, что если мы откроем `https://any-domain.com/rss.xml` в браузере, то будет отображен презентер `Feed` с действием `rss` и т. д. Если подходящий маршрут не найден, приложение Nette отвечает исключением [BadRequestException |api:Nette\Application\BadRequestException], которое отображается для пользователя как страница ошибки 404 Not Found.

.[note]
В Nette 2.x вместо `$router->addRoute(...)` использовалось `$router[] = new Route(...)`.

Порядок маршрутов важен, поскольку они пробуются последовательно от первого до последнего. Основное правило — **заявлять маршруты от самых специфических до самых общих**.

Чтобы подключить наш маршрутизатор к приложению, мы должны сообщить о нем контейнеру DI. Самый простой способ — подготовить фабрику, которая будет создавать объект маршрутизатора, и указать конфигурации контейнера использовать её. Итак, допустим, мы напишем для этого метод `App\Router\RouterFactory::createRouter()`:

```php
namespace App\Router;

use Nette\Application\Routers\RouteList;

class RouterFactory
{
	public static function createRouter(): RouteList
	{
		$router = new RouteList;
		$router->addRoute(/* ... */);
		return $router;
	}
}
```

Тогда мы пишем в [конфигурации |dependency-injection:services]:

```neon
services:
	- App\Router\RouterFactory::createRouter
```

Любые зависимости, такие как подключение к базе данных и т. д., передаются в метод фабрики в качестве его параметров с помощью [autowiring |dependency-injection:autowiring]:

```php
public static function createRouter(Nette\Database\Connection $db): RouteList
{
	// ...
}
```


Маска и параметры
-----------------

Маска описывает относительный путь, основанный на корне сайта. Самая простая маска — это статический URL:

```php
$router->addRoute('products', 'Products:default');
```

Часто маски содержат так называемые **параметры**. Они заключены в угловые скобки (например, `<year>`) и передаются в целевой презентер, например, в метод `renderShow(int $year)` или в постоянный параметр `$year`:

```php
$router->addRoute('chronicle/<year>', 'History:show');
```

В примере говорится, что если мы откроем `https://any-domain.com/chronicle/2020` в браузере, презентер `History` и действие `show` с параметром `year: 2020` будет отображаться.

Мы можем указать значение по умолчанию для параметров непосредственно в маске, и таким образом она становится необязательной:

```php
$router->addRoute('chronicle/<year=2020>', 'History:show');
```

Теперь маршрут будет принимать URL `https://any-domain.com/chronicle/`, который снова отобразит `History:show` с параметром `year`: 2020`.

Конечно, имя презентера и действие также могут быть параметрами. Например:

```php
$router->addRoute('<presenter>/<action>', 'Homepage:default');
```

Этот маршрут принимает, например, URL в форме `/article/edit` и `/catalog/list` соответственно, и переводит их в презентеры и действия `Article:edit` и `Catalog:list` соответственно.

Он также придает параметрам `presenter` и `action` значения по умолчанию `Homepage` и `default` и поэтому они являются необязательными. Поэтому маршрут также принимает URL `/article` и переводит его как `Article:default`. Или наоборот, ссылка на `Product:default` генерирует путь `/product`, ссылка на стандартную `Homepage:default` генерирует путь `/`.

Маска может описывать не только относительный путь, основанный на корне сайта, но и абсолютный путь, если он начинается со слэша, или даже весь абсолютный URL, если он начинается с двух слэшей:

```php
// относительный путь к корню приложения
$router->addRoute('<presenter>/<action>', /* ... */);

// абсолютный путь, относительно имени хоста сервера
$router->addRoute('/<presenter>/<action>', /* ... */);

// абсолютный URL, включая имя хоста (относительно схемы)
$router->addRoute('//<lang>.example.com/<presenter>/<action>', /* ... */);

// абсолютный URL, включая схему
$router->addRoute('https://<lang>.example.com/<presenter>/<action>', /* ... */);
```


Валидационные выражения
-----------------------

Для каждого параметра можно задать условие проверки с помощью [регулярного выражения |https://www.php.net/manual/en/reference.pcre.pattern.syntax.php]. Например, давайте зададим `id` только числовым, используя `\d+` regexp:

```php
$router->addRoute('<presenter>/<action>[/<id \d+>]', /* ... */);
```

По умолчанию регулярным выражением для всех параметров является `[^/]+`, то есть всё, кроме слэша. Если параметр должен соответствовать также косой черте, мы задаем регулярное выражение `.+`.

```php
// принимает https://example.com/a/b/c, path — 'a/b/c'
$router->addRoute('<path .+>', /* ... */);
```


Необязательные последовательности
---------------------------------

Квадратные скобки обозначают необязательные части маски. Любая часть маски может быть задана как необязательная, включая те, которые содержат параметры:

```php
$router->addRoute('[<lang [a-z]{2}>/]<name>', /* ... */);

// Принимаемые URL-адреса:  Параметры:
//   /en/download           lang => en, name => download
//   /download              lang => null, name => download
```

Конечно, когда параметр является частью необязательной последовательности, он также становится необязательным. Если у него нет значения по умолчанию, он будет равен null.

Необязательные части также могут быть в домене:

```php
$router->addRoute('//[<lang=en>.]example.com/<presenter>/<action>', /* ... */);
```

Последовательности могут быть свободно вложены и объединены:

```php
$router->addRoute(
	'[<lang [a-z]{2}>[-<sublang>]/]<name>[doc:page-<page=0>]',
	'Homepage:default',
);

// Accepted URLs:
//   /cs/hello
//   /en-us/hello
//   /hello
//   /hello/page-12
```

Генератор URL старается сделать URL как можно короче, поэтому то, что можно опустить, опускается. Поэтому, например, маршрут `index[.html]` генерирует путь `/index`. Вы можете изменить это поведение, написав восклицательный знак после левой квадратной скобки:

```php
// accepts both /hello and /hello.html, generates /hello
$router->addRoute('<name>[.html]', /* ... */);

// accepts both /hello and /hello.html, generates /hello.html
$router->addRoute('<name>[!.html]', /* ... */);
```

Необязательные параметры (т. е. параметры, имеющие значение по умолчанию) без квадратных скобок ведут себя так, как если бы они были обернуты таким образом:

```php
$router->addRoute('<presenter=Homepage>/<action=default>/<id=>', /* ... */);

// equals to:
$router->addRoute('[<presenter=Homepage>/[<action=default>/[<id>]]]', /* ... */);
```

Чтобы изменить способ генерации самой правой косой черты, т. е. вместо `/homepage/` получить `/homepage`, настройте маршрут таким образом:

```php
$router->addRoute('[<presenter=Homepage>[/<action=default>[/<id>]]]', /* ... */);
```


Символы подстановки
-------------------

В маске абсолютного пути мы можем использовать следующие подстановочные знаки, чтобы избежать, например, необходимости записывать в маску домен, который может отличаться в среде разработки и производственной среде:

- `%tld%` = домен верхнего уровня, например, `com` или `org`
- `%sld%` = домен второго уровня, например, `example`
- `%domain%` = домен без поддоменов, например, `example.com`
- `%host%` = весь хост, например, `www.example.com`
- `%basePath%` = путь к корневому каталогу

```php
$router->addRoute('//www.%domain%/%basePath%/<presenter>/<action>', /* ... */);
$router->addRoute('//www.%sld%.%tld%/%basePath%/<presenter>/<action', /* ... */);
```


Расширенная нотация
-------------------

Второй параметр маршрута, который мы часто пишем в формате `Presenter:action`, является аббревиатурой, которую мы также можем написать в виде поля, где мы непосредственно указываем значения (по умолчанию) отдельных параметров:

```php
$router->addRoute('<presenter>/<action>[/<id \d+>]', [
	'presenter' => 'Homepage',
	'action' => 'default',
]);
```

Или мы можем использовать эту форму, обратите внимание на переписывание регулярного выражения проверки:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>[/<id>]', [
	'presenter' => [
		Route::Value => 'Homepage',
	],
	'action' => [
		Route::Value => 'default',
	],
	'id' => [
		Route::Pattern => '\d+',
	],
]);
```

Эти более подробные форматы полезны для добавления дополнительных метаданных.


Фильтры и переводы
------------------

Хорошей практикой является написание исходного кода на английском языке, но что если вам нужно, чтобы URL вашего сайта был переведен на другой язык?

```php
$router->addRoute('<presenter>/<action>', 'Homepage:default');
```

будет генерировать английские URL, такие как `/product/123` или `/cart`. Если мы хотим, чтобы презентеры и действия в URL были переведены на немецкий язык (например, `/produkt/123` или `/einkaufswagen`), мы можем использовать словарь переводов. Чтобы добавить его, нам уже нужен «более понятный» вариант второго параметра:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>', [
	'presenter' => [
		Route::Value => 'Homepage',
		Route::FilterTable => [
			// string in URL => presenter
			'produkt' => 'Product',
			'einkaufswagen' => 'Cart',
			'katalog' => 'Catalog',
		],
	],
	'action' => [
		Route::Value => 'default',
		Route::FilterTable => [
			'liste' => 'list',
		],
	],
]);
```

Для одного и того же презентера можно использовать несколько ключей словаря. Они будут создавать для него различные псевдонимы. Последний ключ считается каноническим вариантом (т. е. тот, который будет в сгенерированном URL).

Таблица перевода может быть применена к любому параметру таким образом. Однако если перевода не существует, берется исходное значение. Мы можем изменить это поведение, добавив `Route::FilterStrict => true`, и тогда маршрут будет отклонять URL, если значение отсутствует в словаре.

В дополнение к словарю перевода в виде массива можно задать собственные функции перевода:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => [
		Route::Value => 'Homepage',
		Route::FilterIn => function (string $s): string { /* ... */ },
		Route::FilterOut => function (string $s): string { /* ... */ },
	],
	'action' => 'default',
	'id' => null,
]);
```

Функция `Route::FilterIn` осуществляет преобразование между параметром в URL и строкой, которая затем передается презентеру, функция `FilterOut` обеспечивает преобразование в обратном направлении.

Параметры `presenter`, `action` и `module` уже имеют предопределенные фильтры, которые конвертируют между PascalCase, camelCase и kebab-case соответственно, используемые в URL. Значение параметров по умолчанию уже записано в преобразованной форме, поэтому, например, в случае с презентером мы пишем `<presenter=ProductEdit>` вместо `<presenter=product-edit>`.


Общие фильтры
-------------

Помимо фильтров для конкретных параметров, вы также можете определить общие фильтры, получающие ассоциативный массив всех параметров, которые они могут изменять любым способом, а затем возвращать. Общие фильтры определяются по ключу `null`.

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>', [
	'presenter' => 'Homepage',
	'action' => 'default',
	null => [
		Route::FilterIn => function (array $params): array { /* ... */ },
		Route::FilterOut => function (array $params): array { /* ... */ },
	],
]);
```

Общие фильтры дают вам возможность настроить поведение маршрута абсолютно любым способом. Мы можем использовать их, например, для изменения параметров на основе других параметров. Например, перевод `<presenter>` и `<action>` на основе текущего значения параметра `<lang>`.

Если для параметра определен пользовательский фильтр и одновременно существует общий фильтр, пользовательский `FilterIn` выполняется перед общим, и наоборот, общий `FilterOut` выполняется перед пользовательским. Таким образом, внутри общего фильтра находятся значения параметров `presenter` и `action` соответственно, написанное на языке PascalCase и camelCase соответственно.


Флаг OneWay
-----------

Односторонние маршруты используются для сохранения функциональности старых URL, которые приложение больше не генерирует, но всё ещё принимает. Мы отмечаем их флагом `OneWay`:

```php
// старый URL /product-info?id=123
$router->addRoute('product-info', 'Product:detail', $router::ONE_WAY);
// новый URL /product/123
$router->addRoute('product/<id>', 'Product:detail');
```

При обращении к старому URL-адресу презентер автоматически перенаправляет на новый URL-адрес, чтобы поисковые системы не индексировали эти страницы дважды (см. [#SEO и канонизация]).


Модули
------

Если у нас есть несколько маршрутов, принадлежащих одному модулю, мы можем использовать `withModule()` для их группировки:

```php
$router = new RouteList;
$router->withModule('Forum') // следующие маршрутизаторы входят в состав модуля Forum
	->addRoute('rss', 'Feed:rss') // презентер Forum:Feed
	->addRoute('<presenter>/<action>')

	->withModule('Admin') // следующие маршрутизаторы являются частью модуля Forum:Admin
		->addRoute('sign:in', 'Sign:in');
```

Альтернативой является использование параметра `module`:

```php
// URL manage/dashboard/default maps to presenter Admin:Dashboard
$router->addRoute('manage/<presenter>/<action>', [
	'module' => 'Admin',
]);
```


Субдомены
---------

Коллекции маршрутов могут быть сгруппированы по поддоменам:

```php
$router = new RouteList;
$router->withDomain('example.com')
	->addRoute('rss', 'Feed:rss')
	->addRoute('<presenter>/<action>');
```

Вы также можете использовать [Символы подстановки |#Символы подстановки] в своем доменном имени:

```php
$router = new RouteList;
$router->withDomain('example.%tld%')
	// ...
```


Префикс пути
------------

Коллекции маршрутов могут быть сгруппированы по пути в URL:

```php
$router = new RouteList;
$router->withPath('/eshop')
	->addRoute('rss', 'Feed:rss') // соответствует URL /eshop/rss
	->addRoute('<presenter>/<action>'); //  соответствует URL /eshop/<presenter>/<action>
```


Комбинации
----------

Вышеуказанные варианты использования можно комбинировать:

```php
$router = (new RouteList)
	->withDomain('admin.example.com')
		->withModule('Admin')
			->addRoute(/* ... */)
			->addRoute(/* ... */)
		->end()
		->withModule('Images')
			->addRoute(/* ... */)
		->end()
	->end()
	->withDomain('example.com')
		->withPath('export')
			->addRoute(/* ... */)
			// ...
```


Параметры запроса
-----------------

Маски также могут содержать параметры запроса (параметры после знака вопроса в URL). Они не могут определить выражение проверки, но они могут изменить имя, под которым они передаются презентеру:

```php
// используем параметр запроса 'cat' в качестве 'categoryId' в приложении
$router->addRoute('product ? id=<productId> & cat=<categoryId>', /* ... */);
```


Параметры Foo
-------------

Теперь мы идем глубже. Параметры Foo — это, по сути, неименованные параметры, которые позволяют сопоставить регулярное выражение. Следующий маршрут соответствует `/index`, `/index.html`, `/index.htm` и `/index.php`:

```php
$router->addRoute('index<? \.html?|\.php|>', /* ... */);
```

Также можно явно задать строку, которая будет использоваться для генерации URL. Строка должна располагаться непосредственно после знака вопроса. Следующий маршрут похож на предыдущий, но генерирует `/index.html` вместо `/index`, потому что строка `.html` установлена как «генерируемое значение».

```php
$router->addRoute('index<?.html \.html?|\.php|>', /* ... */);
```


SimpleRouter
============

Гораздо более простым маршрутизатором, чем коллекция маршрутов, является [SimpleRouter |api:Nette\Application\Routers\SimpleRouter]. Его можно использовать, когда нет необходимости в определенном формате URL, когда `mod_rewrite` (или альтернативы) недоступен или когда мы просто не хотим пока возиться с удобными для пользователя URL.

Генерирует адреса примерно такой формы:

```
http://example.com/?presenter=Product&action=detail&id=123
```

Параметром конструктора `SimpleRouter` является презентер и действие по умолчанию, т. е. действие, которое будет выполнено, если мы откроем, например, `http://example.com/` без дополнительных параметров.

```php
// используем презентер 'Homepage' и действие 'default'
$router = new Nette\Application\Routers\SimpleRouter('Homepage:default');
```

Мы рекомендуем определять SimpleRouter непосредственно в [конфигурации |dependency-injection:services]:

```neon
services:
	- Nette\Application\Routers\SimpleRouter('Homepage:default')
```


SEO и канонизация
=================

Фреймворк улучшает SEO, предотвращая дублирование контента на разных URL. Если несколько адресов ссылаются на одно и то же место назначения, например `/index` и `/index.html`, фреймворк определяет первый из них как основной (канонический) и перенаправляет на него остальные с помощью HTTP-кода 301. Благодаря этому поисковые системы не будут индексировать страницы дважды и не нарушат их страничный рейтинг.

Этот процесс называется канонизацией. Канонический URL — это URL, сгенерированный маршрутизатором, т. е. первым подходящим маршрутом в [коллекции |#Коллекция маршрутов] без флага OneWay. Поэтому в коллекции мы перечисляем **первичные маршруты первыми**.

Канонизация осуществляется презентером, подробнее в главе [Канонизация |presenters#Канонизация].


HTTPS
=====

Для того чтобы использовать протокол HTTPS, необходимо активировать его на хостинге и настроить сервер.

Перенаправление всего сайта на HTTPS должно быть выполнено на уровне сервера, например, с помощью файла .htaccess в корневом каталоге нашего приложения, с HTTP-кодом 301. Настройки могут отличаться в зависимости от хостинга и выглядят примерно так:

```
<IfModule mod_rewrite.c>
	RewriteEngine On
	...
	RewriteCond %{HTTPS} off
	RewriteRule .* https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
	...
</IfModule>
```

Маршрутизатор генерирует URL с тем же протоколом, по которому была загружена страница, поэтому нет необходимости задавать что-либо ещё.

Однако, если нам исключительно нужно, чтобы разные маршруты работали под разными протоколами, мы поместим это в маску маршрута:

```php
// Сгенерирует HTTP адрес
$router->addRoute('http://%host%/<presenter>/<action>', /* ... */);

// Сгенерирует HTTPS адрес
$router->addRoute('https://%host%/<presenter>/<action>', /* ... */);
```


Отладчик маршрутизации
======================

Мы не будем скрывать от вас, что поначалу маршрутизация может показаться немного магической, и прежде чем вы в нее погрузитесь, отладчик маршрутизации станет хорошим помощником. Это панель, отображаемая в [Tracy Bar |tracy:], которая предоставляет четкий список маршрутов, а также параметры, которые маршрутизатор получил из URL.

Зеленая полоса с символом ✓ представляет маршрут, соответствующий текущему URL, синие полосы с символами ≈ обозначают маршруты, которые также соответствовали бы URL, если бы зеленый цвет не обогнал их. Мы видим текущий презентер и действуем дальше.

[* routing-debugger.webp *]


Производительность
==================

Количество маршрутов влияет на скорость маршрутизатора. Их количество, конечно, не должно превышать нескольких десятков. Если ваш сайт имеет слишком сложную структуру URL, вы можете написать [#Пользовательский маршрутизатор].

Если маршрутизатор не имеет зависимостей, например, от базы данных, и его фабрика не имеет аргументов, мы можем сериализовать его скомпилированную форму непосредственно в DI-контейнер и тем самым сделать приложение немного быстрее.

```neon
routing:
	cache: true
```


Пользовательский маршрутизатор
==============================

Следующие строки предназначены для очень опытных пользователей. Вы можете создать свой собственный маршрутизатор и, естественно, добавить его в коллекцию маршрутов. Маршрутизатор представляет собой реализацию интерфейса [Router |api:Nette\Routing\Router] с двумя методами:

```php
use Nette\Http\IRequest as HttpRequest;
use Nette\Http\UrlScript;

class MyRouter implements Nette\Routing\Router
{
	public function match(HttpRequest $httpRequest): ?array
	{
		// ...
	}

	public function constructUrl(array $params, UrlScript $refUrl): ?string
	{
		// ...
	}
}
```

Метод `match` обрабатывает текущий запрос в параметре [$httpRequest |http:request] (который предлагает больше, чем просто URL) в массив, содержащий имя презентера и его параметры. Если он не может обработать запрос, то возвращает null.

Метод `constructUrl`, с другой стороны, генерирует абсолютный URL из массива параметров. Он может использовать информацию из параметра `$refUrl`, который является текущим URL.

Чтобы добавить пользовательский маршрутизатор в коллекцию маршрутов, используйте `add()`:

```php
$router = new Nette\Application\Routers\RouteList;
$router->add(new MyRouter);
$router->addRoute(/* ... */);
// ...
```


Раздельное использование
========================

Под раздельным использованием подразумевается использование возможностей маршрутизатора в приложении, которое не использует приложение Nette и презентеры. К нему применимо почти всё, что мы показали в этой главе, со следующими отличиями:

- для коллекций маршрутов мы используем класс [api:Nette\Routing\RouteList].
- как класс простого маршрутизатора [api:Nette\Routing\SimpleRouter].
- поскольку нет пары `Presenter:action`, мы используем [#Расширенная нотация].

Итак, мы снова добавим метод, который будет создавать, например, маршрутизатор:

```php
namespace App\Router;

use Nette\Routing\RouteList;

class RouterFactory
{
	public static function createRouter(): RouteList
	{
		$router = new RouteList;
		$router->addRoute('rss.xml', [
			'controller' => 'RssFeedController',
		]);
		$router->addRoute('article/<id \d+>', [
			'controller' => 'ArticleController',
		]);
		// ...
		return $router;
	}
}
```

Если вы используете DI-контейнер, как мы рекомендуем, добавьте метод в конфигурацию ещё раз, а затем получите маршрутизатор вместе с HTTP-запросом из контейнера:

```php
$router = $container->getByType(Nette\Routing\Router::class);
$httpRequest = $container->getByType(Nette\Http\IRequest::class);
```

Или мы будем создавать объекты напрямую:

```php
$router = App\Router\RouterFactory::createRouter();
$httpRequest = (new Nette\Http\RequestFactory)->fromGlobals();
```

Теперь нужно дать маршрутизатору поработать:

```php
$params = $router->match($httpRequest);
if ($params === null) {
	// не найден совпадающий маршрут, отправим ошибку 404
	exit;
}

// обрабатываем полученные параметры
$controller = $params['controller'];
// ...
```

И наоборот, мы будем использовать маршрутизатор для создания ссылки:

```php
$params = ['controller' => 'ArticleController', 'id' => 123];
$url = $router->constructUrl($params, $httpRequest->getUrl());
```


{{composer: nette/application}}
