Forms: standalone usage
***********************

.[perex]
Nette Forms greatly facilitates the creation and processing of web forms in your applications. In this chapter, you will learn how to use forms alone without using Nette Application.

However, if you use presenters and Nette Application, there is a guide for you: [forms in presenters|form-presenter].

Installation:

```shell
composer require nette/forms
```

First Form
==========

We will try to write a simple registration form. Its code will look like this:

```php
use Nette\Forms\Form;

$form = new Form;
$form->addText('name', 'Name:');
$form->addPassword('password', 'Password:');
$form->addSubmit('send', 'Sign up');
```

And let's render it:

```php
$form->render();
```

and the result should look like this:

[* form-en.png *]

Now we will revive the form. By asking `$form->isSuccess()`, we will find out whether the form was submitted and whether it was filled in correctly. If the form is filled in correctly, we will write the data into the browser window. After the definition of the form we will add:

```php
if ($form->isSuccess()) {
	echo 'The form has been filled in and submitted correctly';
	$data = $form->getValues();
	// $data->name contains name
	// $data->password contains password
	var_dump($data);
}
```

Method `getValues()` returns the sent data in the form of an object [ArrayHash |arrays#ArrayHash]. We will show how to change this [later |#Mapping to Classes]. The variable `$data` contains keys `name` and `password` with data entered by the user. Usually we send the data directly for further processing, such as insertion into the database.

After processing the form, we will redirect to the next page. This prevents the form from being unintentionally resubmitted by clicking the Refresh, Back button, or moving the browser history.

By default, the form is send as POST to the same page. This can be easily changed:

```php
$form->setAction('/submit.php');
$form->setMethod('GET');
```

And that is all :-) We have a functional and perfectly [secured |#Vulnerability Protection] form.


Access to Fields
================

The form and its individual fields are called components. They create a component tree, where the root is the form. You can access the individual fields as follows:

```php
$input = $form->getComponent('name');
// alternative syntax: $input = $form['name'];

$button = $form->getComponent('send');
// alternative syntax: $button = $form['send'];
```

Validation Rules
================

The word *valid* was used several times, but the form has no validation rules yet. Let's fix it.

The name will be mandatory, so we will mark it with the method `setRequired()`, whose optional argument is the text of the error message that will be displayed if the user does not fill it. If no argument is given, the default error message is used.

```php
$form->addText('name', 'Name:')
	->setRequired('Please fill your name.');
```

Try to submit the form without the name filled in and you will see that an error message is displayed and the browser or server will reject it until you fill it.

At the same time, you will not be able cheat the system by typing only spaces in the input, for example. No way. Nette automatically trims left and right whitespace. Try it. It's something you should always do with every single-line input, but it's often forgotten. Nette does it automatically.

The form is always validated on the server side, but it also generates JavaScript validation on the browser side, which is quick and the user knows of the error immediately, without having to send the form to the server. This is handled by the script `netteForms.js`.
Add it to the page:

```html
<script src="https://nette.github.io/resources/js/3/netteForms.min.js"></script>
```

If you look in the source code of the page, you may notice that Nette inserts the required fields into an element with a CSS class `required`. Try adding the following style to the template, and the "Name" label will be red. Elegantly, we mark the required fields for the user:

```html
<style>
.required label { color: maroon }
</style>
```

Additional validation rules will be added by method `addRule()`. The first parameter is [rule |form-validation#rules], the second is again the text of the error message, and the optional validation rule argument can follow.

The form will get another optional input *age* with the condition, that it has to be a number (`addInteger()`) and in certain boundaries (`$form::RANGE`). This time we will utilize a third argument of `addRule()`, the range itself:

```php
$form->addInteger('age', 'Age:')
	->addRule($form::RANGE, 'You must be older 18 years and be under 120.', [18, 120]);
```

.[tip]
If the user does not fill in the field, the validation rules will not be verified, because the field is optional.

Obviously room for a small refactoring is available. In the error message and in the third parameter, the numbers are listed in duplicate, which is not ideal. If we were creating a [multilingual form|translations] and the message containing numbers would have to be translated into multiple languages, it would make it more difficult to change values. For this reason, substitute characters `%d` can be used:

```php
	->addRule($form::RANGE, 'You must be older %d years and be under %d.', [18, 120]);
```

Let's return to the *password* field, make it *required*, and verify the minimum password length (`$form::MIN_LENGTH`), again using the substitute characters in the message:

```php
$form->addPassword('password', 'Password:')
	->setRequired('Pick a password')
	->addRule($form::MIN_LENGTH, 'Your password has to be at least %d long', 8);
```

We will add a field `passwordVerify` to the form, where the user enters the password again, for checking. Using validation rules, we check whether both passwords are the same (`$form::EQUAL`). Notice the dynamic references to the first password using [square brackets |#Access to Fields]:

```php
$form->addPassword('passwordVerify', 'Password again:')
	->setRequired('Fill your password again to check for typo')
	->addRule($form::EQUAL, 'Password mismatch', $form['password'])
	->setOmitted(); // after validation the data is discarded and not passed to $data
```

We have a fully functional form that has the same validation on the browser and server side. It automatically treats whether an attacker does not send invalid UTF-8 strings, etc., does not spoof a form from another domain, etc. You just don't have to think about these things, Nette does them for you.

Try adding more [form fields|form-fields]. You can also find inspiration in the distribution in the [examples |https://github.com/nette/forms/tree/master/examples] directory.


Default Values
==============

We set the default values to form fields, for example, when the form is used to edit database records. We read it from the database and pass it to the form as an array of default values:

```php
$items = [
	'name' => 'John',
	'age' => '33'
];
$form->setDefaults($items);
```

Call `setDefaults()` after defining the fields.

The `setDefaultValue()` method can be used to set the default value for individual fields:

```php
$form->addEmail('email', 'Email')
	->setDefaultValue('user@example.com');
```


Rendering the Form
==================

By default, the form is rendered as a table. The individual fields follows basic web accessibility guidelines. All labels are generated as `<label>` elements and are associated with their inputs, clicking on the label moves the cursor on the input.

We can set any HTML attributes for each element. For example, add a placeholder:

```php
$form->addInteger('age', 'Age:')
	->setHtmlAttribute('placeholder', 'Please fill in the age');
```

There are really a lot of ways to render a form, so it's dedicated [chapter about rendering|form-rendering].


Mapping to Classes
==================

Let's go back to form data processing. Method `getValues()` returns object `ArrayHash` with sent data. Of course, since it's a generic object, something like `stdClass`, code hinting or [static code analysis |editors-and-tools#PHPStan] won't work for us.
Therefore, it would be more handy to create a class for each form, where properties represent individual elements. E.g.:

```php
class RegistrationFormData
{
	/** @var string */
	public $name;
	/** @var int */
	public $age;
	/** @var string */
	public $password;
}
```

Now we just need to specify this class as a parameter `getValue()` and lo and behold, Nette will create and return just this object:

```php
$data = $form->getValues(RegistrationFormData::class);
$name = $data->name;
```

Conversely, if it would be more convenient to get the data as an array, specify as a parameter `'array'`.


Multiple Submit Buttons
=======================

If the form has more than one button, we usually need to distinguish which one was pressed. The method `isSubmittedBy()` of the button returns this information to us:

```php
$form->addSubmit('save', 'Save');
$form->addSubmit('delete', 'Delete');

if ($form->isSuccess()) {
	if ($form['save']->isSubmittedBy()) {
		....
	}

	if ($form['delete']->isSubmittedBy()) {
		....
	}
}
```

Do not omit the query on `$form->isSuccess()`, you will verify that the form data is valid.

When the form is submitted with the *enter* key, the first button is considered as submitting.



Vulnerability Protection
========================

Nette Framework puts a great effort to be safe and since forms are the most common user input, Nette forms are as good as impenetrable. All is maintained dynamically and transparently, nothing has to be set manually. Well-known vulnerabilities such as [Cross-Site Scripting (XSS) |vulnerability-protection#cross-site-scripting-xss] and [Cross-Site Request Forgery (CSRF)|vulnerability-protection#cross-site-request-forgery-csrf] are filtered, as well as special control characters. All inputs are checked for UTF-8 validity. Every multiple-choice, select box and similar are checked for forged values upon validating.

A CSRF attack is that an attacker lures the victim to visit a page that silently executes a request in the victim's browser to the server where the victim is currently logged in, and the server believes that the request was made by the victim at will. It's strongly recommended to apply this protection to the forms in an administrative part of your application which changes sensitive data.

The protection is pretty simple:

```php
$form->addProtection('Your session has expired. Please return to the home page and try again.');
```

The framework protects against a CSRF attack by generating and validating authentication token that is stored in a session (the argument is the error message shown if the token has expired). That's why it is necessary to have an session started before displaying the form. In the administration part of the website, the session is usually already started, due to the user's login.
Otherwise, start the session with the method `Nette\Http\Session::start()`.


{{composer: nette/forms}}
