Model
**************

Na začátku jsme modelovou vrstvu přeskočili, abychom se rychle dostali k potřebným datům. To se ale v praxi téměř nedělá. Na ukázku to stačilo, ale u větších projektů bychom brzy zaplakali ;-). Zrefaktorujeme si tedy aplikaci a vytvoříme si modelovou vrstvu. Tedy tu vrstvu, která nás v prezenteru oddělí od přímé komunikace s tabulkami a zaštítí to pod pěkné API.


[* quick-manager.png *]


V adresáři app/model/ vytvoříme naši modelovou třídu co se nám bude starat o články ArticlesManager.php.


/---php
<?php

namespace App\Model;

use Nette;

/**
 * Article management.
 */
class ArticleManager extends Nette\Object
{


}

\--

Zároveň ho zaregistrujeme v app/config/config.neon v sekci services. Nepotřebujeme ho pojmenovat, tak na začátek přidáme pouze odrážku. Nezapomeňme na namespace, ve kterém je definován.


/--neon
services:
	- App\Forms\SignFormFactory
	router: App\RouterFactory::createRouter
	- App\Model\ArticleManager
\--

Tím Nette a jeho "DI containeru":http://doc.nette.org/cs/2.3/dependency-injection říkáme, kdyby se někdo ptal na tuhle třídu tak víš kde ji hledat, dej ji vše co potřebuje k životu a připrav nám ji pro použití v dalších třídách.



Přepneme se do HomepagePresenter.php, který upravíme tak, že se zbavíme závislosti na Nette\Database\Context a nahradíme za novou závislost na naší nové třídě.


/--php
<?php

namespace App\Presenters;

use Nette,
	App\Model;

/**
 * Homepage presenter.
 */
class HomepagePresenter extends BasePresenter
{
	/** @var Model\ArticleManager */
	private $articleManager;

	public function __construct(Model\ArticleManager $articleManager)
	{
		$this->articleManager = $articleManager;
	}


	public function renderDefault()
	{
		$this->template->posts = $this->articleManager->findAll()->limit(5);
	}

}


\--
.[tip]
V sekci use máme App/Model, tak si můžeme zápis v php kódu zkrátit na Model\ArticleManager (nebojte, i v komentářích to funguje a vaše chytré IDE by si s tím mělo poradit).



V konstruktoru si požádáme o ArticleManager. Ten nám dá už nám známý "DI container":http://doc.nette.org/cs/2.3/dependency-injection a tenhle ArticleManager si přiřadíme do private property. V metodě renderDefault zavoláme metodu findAll (která v tuto chvíli neexistuje) a nad výsledkem co se nám vrátí zavoláme ještě metodu limit(5);


Doplníme si tedy do našeho managera metodu findAll


app/model/ArticleManager.php

/—-
//...
public function findAll()
{
	return $this->database->table('posts')
		->order('created_at DESC');
}
//...
\--

kam jsme přesunuli kus kódu co se dotazoval databáze na články. Zde tedy používáme property database, kterou ale nemáme nikde definovanou. Tak si ji zadefinujeme a její obsah naplníme tím o co si řekneme v konstruktoru.

/—-
//...
/**
 * @var Nette\Database\Context
 */
private $database;


public function __construct(Nette\Database\Context $database)
{
	$this->database = $database;
}
//...
\--

celé to pak vypadá následovně:

/--
<?php

namespace App\Model;

use Nette;

/**
 * Article management.
 */
class ArticleManager extends Nette\Object
{

	/**
	 * @var Nette\Database\Context
	 */
	private $database;


	public function __construct(Nette\Database\Context $database)
	{
		$this->database = $database;
	}


	public function findAll()
	{
		return $this->database->table('posts')
			->order('created_at DESC');

	}

}

\--



Třída ArticleManager si v konstruktoru řekne o předání Nette\Database\Context a jelikož tato třída je v DI containeru zaregistrovaná, vytvoří její instancí a předá. DI za nás takto vytvoří instanci ArticleManagera a předá ho v konstrukotru HomepagePresenter, který si o něj požádal. Taková matroška :) Všichni si jen říkají co chtějí a nezajímají se o to kde se to vytváří. O to se postará Nette DI container:"http://doc.nette.org/cs/dependency-injection"
