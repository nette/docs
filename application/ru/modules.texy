Модули
******

Для немного больших приложений мы можем разделить папки с презентерами и шаблонами на подкаталоги (на диске) и на пространства имен (в коде), которые мы называем модулями. Если бы наше приложение содержало, например, модули `Front` и `Admin`, его структура могла бы выглядеть следующим образом:

/--pre
<b>app/</b>
├── <b>Modules/</b>              ← директория с модулями
│   ├── <b>Admin/</b>            ← модуль Admin
│   │   └── <b>Presenters</b>    ← его презентеры
│   │       └── <b>templates</b> ← и шаблоны
│   └── <b>Front/</b>            ← модуль Front
│       └── <b>Presenters</b>    ← его презентеры
│           └── <b>templates</b> ← и шаблоны
\--

Модули не обязательно должны быть только плоской структурой, можно также создавать подмодули.

Если бы модуль `Front` включал презентер `Product`, то действие `show` в этом презентере было бы записано как `Front:Product:show`, а класс `ProductPresenter` был бы помещен в пространство имен, например, `App\Modules\Front`:

```php
namespace App\Modules\Front;

class ProductPresenter extends Nette\Application\UI\Presenter
{
	// ...
}
```


Маппинг
-------

Определяет правила, согласно которым имя класса (например, `App\Presenters\HomepagePresenter`) происходит от имени презентера (например, `Homepage`). Этого отображения можно достичь с помощью следующей конфигурации:

```neon
application:
	mapping:
		*: App\Presenters\*Presenter
```

Имя презентера заменяется звездочкой, и в результате получается название класса. Легко!

Если мы разделим докладчиков на модули, то для каждого модуля у нас может быть свой маппинг:

```neon
application:
	mapping:
		Front: App\Modules\Front\Presenters\*Presenter
		Admin: App\Modules\Admin\Presenters\*Presenter
		Api: App\Api\*Presenter
```

Теперь презентер `Front:Homepage` определяется классом `App\Modules\Front\HomepagePresenter`, а презентер `Admin:Dashboard` — `App\AdminModule\DashboardPresenter`.

Удобнее будет создать общее правило (звездочка), которое заменит первые два правила и добавит дополнительную звездочку только для модуля:

```neon
application:
	mapping:
		*: App\Modules\*\Presenters\*Presenter
		Api: App\Api\*Presenter
```

Опять же, презентер `Front:Homepage` определяется классом ``App\Modules\Front\HomepagePresenter``.

Но что если мы используем вложенные модули и имеем презентер `Admin:User:Edit`? В этом случае сегмент со звездочкой, представляющий модуль для каждого уровня, просто повторяется, и в результате получается класс `App\Modules\Admin\User\EditPresenter`.

Альтернативной нотацией является использование массива, состоящего из трех сегментов, вместо строки:

```neon
application:
	mapping:
		*: [App\Modules, *, *Presenter]
```

Эта запись эквивалентна оригиналу `App\Modules\*\*Presenter`.

Значение по умолчанию `*: *Module\*Presenter`.


