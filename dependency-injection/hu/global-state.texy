Glob√°lis √°llapot √©s singletonok
*******************************

.[perex]
Figyelmeztet√©s: A k√∂vetkez≈ë konstrukci√≥k rosszul megtervezett k√≥d jelei:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` vagy `static::$var`

El≈ëfordulnak ezek a konstrukci√≥k a k√≥dj√°ban? Akkor itt a lehet≈ës√©g a jav√≠t√°sra. Tal√°n azt gondolja, hogy ezek √°ltal√°nos konstrukci√≥k, amelyeket ak√°r k√ºl√∂nb√∂z≈ë k√∂nyvt√°rak √©s keretrendszerek p√©ldamegold√°saiban is l√°t. Ha ez √≠gy van, akkor a k√≥djuk tervez√©se nem j√≥.

Most biztosan nem valamilyen akad√©miai tisztas√°gr√≥l besz√©l√ºnk. Minden ilyen konstrukci√≥nak egy k√∂z√∂s von√°sa van: glob√°lis √°llapotot haszn√°lnak. √âs ennek rombol√≥ hat√°sa van a k√≥d min≈ës√©g√©re. Az oszt√°lyok hazudnak a f√ºgg≈ës√©geikr≈ël. A k√≥d kisz√°m√≠thatatlann√° v√°lik. Megzavarja a programoz√≥kat √©s cs√∂kkenti hat√©konys√°gukat.

Ebben a fejezetben elmagyar√°zzuk, mi√©rt van ez √≠gy, √©s hogyan ker√ºlj√ºk el a glob√°lis √°llapotot.


Glob√°lis √∂sszekapcsol√°s
-----------------------

Egy ide√°lis vil√°gban egy objektumnak csak azokkal az objektumokkal kellene tudnia kommunik√°lni, amelyeket [k√∂zvetlen√ºl √°tadva |passing-dependencies] kapott. Ha l√©trehozok k√©t `A` √©s `B` objektumot, √©s soha nem adok √°t referenci√°t k√∂z√∂tt√ºk, akkor sem `A`, sem `B` nem f√©rhet hozz√° a m√°sik objektumhoz, vagy nem v√°ltoztathatja meg annak √°llapot√°t. Ez a k√≥d egy nagyon k√≠v√°natos tulajdons√°ga. Hasonl√≥ ahhoz, mint amikor van egy elem √©s egy izz√≥; az izz√≥ nem fog vil√°g√≠tani, am√≠g nem k√∂ti √∂ssze az elemmel egy dr√≥ttal.

Ez azonban nem igaz a glob√°lis (statikus) v√°ltoz√≥kra vagy singletonokra. Az `A` objektum *vezet√©k n√©lk√ºl* hozz√°f√©rhetne a `C` objektumhoz, √©s m√≥dos√≠thatn√° azt an√©lk√ºl, hogy b√°rmilyen referenci√°t √°tadna, az√°ltal, hogy megh√≠vja a `C::changeSomething()`-t. Ha a `B` objektum is megragadja a glob√°lis `C`-t, akkor `A` √©s `B` k√∂lcs√∂n√∂sen befoly√°solhatj√°k egym√°st a `C`-n kereszt√ºl.

A glob√°lis v√°ltoz√≥k haszn√°lata a *vezet√©k n√©lk√ºli* √∂sszekapcsol√°s √∫j form√°j√°t vezeti be a rendszerbe, amely k√≠v√ºlr≈ël nem l√°that√≥. F√ºstf√ºgg√∂nyt hoz l√©tre, amely bonyol√≠tja a k√≥d meg√©rt√©s√©t √©s haszn√°lat√°t. Ahhoz, hogy a fejleszt≈ëk val√≥ban meg√©rts√©k a f√ºgg≈ës√©geket, el kell olvasniuk a forr√°sk√≥d minden sor√°t. Ahelyett, hogy egyszer≈±en megismerkedn√©nek az oszt√°lyok interf√©sz√©vel. R√°ad√°sul ez egy teljesen felesleges √∂sszekapcsol√°s. A glob√°lis √°llapotot az√©rt haszn√°lj√°k, mert k√∂nnyen hozz√°f√©rhet≈ë b√°rhonnan, √©s lehet≈ëv√© teszi p√©ld√°ul az adatb√°zisba √≠r√°st a glob√°lis (statikus) `DB::insert()` met√≥duson kereszt√ºl. De ahogy megmutatjuk, az ebb≈ël sz√°rmaz√≥ el≈ëny eleny√©sz≈ë, m√≠g a okozott komplik√°ci√≥k v√©gzetesek.

.[note]
Viselked√©s szempontj√°b√≥l nincs k√ºl√∂nbs√©g a glob√°lis √©s a statikus v√°ltoz√≥ k√∂z√∂tt. Ugyanolyan k√°rosak.


K√≠s√©rteties t√°volhat√°s
----------------------

"K√≠s√©rteties t√°volhat√°s" - √≠gy nevezte el h√≠resen 1935-ben Albert Einstein a kvantumfizika egy jelens√©g√©t, amelyt≈ël libab≈ër√∂s lett.
Ez egy kvantum-√∂sszefon√≥d√°s, amelynek k√ºl√∂nlegess√©ge, hogy ha megm√©rj√ºk az inform√°ci√≥t az egyik r√©szecsk√©r≈ël, azonnal befoly√°soljuk a m√°sik r√©szecsk√©t is, m√©g akkor is, ha milli√≥ f√©ny√©v t√°vols√°gra vannak egym√°st√≥l.
Ami l√°tsz√≥lag megs√©rti az univerzum alapvet≈ë t√∂rv√©ny√©t, hogy semmi sem terjedhet gyorsabban a f√©nyn√©l.

A szoftver vil√°g√°ban "k√≠s√©rteties t√°volhat√°snak" nevezhetj√ºk azt a helyzetet, amikor elind√≠tunk egy folyamatot, amelyr≈ël azt gondoljuk, hogy izol√°lt (mert nem adtunk √°t neki semmilyen referenci√°t), de a rendszer t√°voli pontjain v√°ratlan interakci√≥k √©s √°llapotv√°ltoz√°sok k√∂vetkeznek be, amelyekr≈ël nem volt tudom√°sunk. Ez csak glob√°lis √°llapoton kereszt√ºl t√∂rt√©nhet meg.

K√©pzelje el, hogy csatlakozik egy projekt fejleszt≈ëi csapat√°hoz, amelynek kiterjedt, kiforrott k√≥db√°zisa van. Az √∫j vezet≈ëje megk√©ri √ñnt egy √∫j funkci√≥ implement√°l√°s√°ra, √©s √ñn, mint j√≥ fejleszt≈ë, a teszt √≠r√°s√°val kezdi. Mivel azonban √∫j a projektben, sok felt√°r√≥ tesztet v√©gez, mint p√©ld√°ul "mi t√∂rt√©nik, ha megh√≠vom ezt a met√≥dust". √âs megpr√≥b√°lja meg√≠rni a k√∂vetkez≈ë tesztet:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // az √ñn k√°rtyasz√°ma
	$cc->charge(100);
}
```

Futtatja a k√≥dot, tal√°n t√∂bbsz√∂r is, √©s egy id≈ë ut√°n √©szreveszi a mobilj√°n a banki √©rtes√≠t√©seket, hogy minden futtat√°skor 100 doll√°rt vontak le a bankk√°rty√°j√°r√≥l ü§¶‚Äç‚ôÇÔ∏è

Hogy a fen√©be okozhatta a teszt a val√≥di p√©nzlevon√°st? A bankk√°rty√°val val√≥ m≈±velet nem egyszer≈±. Kommunik√°lnia kell egy harmadik f√©l webszolg√°ltat√°s√°val, ismernie kell ennek a webszolg√°ltat√°snak az URL-j√©t, be kell jelentkeznie √©s √≠gy tov√°bb.
Ezek k√∂z√ºl az inform√°ci√≥k k√∂z√ºl egyik sem szerepel a tesztben. S≈ët, m√©g azt sem tudja, hol vannak ezek az inform√°ci√≥k, √©s √≠gy azt sem, hogyan mockolja az extern√°lis f√ºgg≈ës√©geket, hogy minden futtat√°s ne vezessen √∫jabb 100 doll√°r levon√°s√°hoz. √âs honnan kellett volna tudnia √∫j fejleszt≈ëk√©nt, hogy amit tenni k√©sz√ºl, az 100 doll√°rral szeg√©nyebb√© teszi?

Ez a k√≠s√©rteties t√°volhat√°s!

Nem marad m√°s h√°tra, mint hosszan turk√°lni a rengeteg forr√°sk√≥dban, k√©rdezgetni az id≈ësebb √©s tapasztaltabb koll√©g√°kat, am√≠g meg nem √©rti, hogyan m≈±k√∂dnek a kapcsolatok a projektben.
Ez az√©rt van, mert a `CreditCard` oszt√°ly interf√©sz√©nek megtekint√©sekor nem lehet meg√°llap√≠tani a glob√°lis √°llapotot, amelyet inicializ√°lni kell. M√©g az oszt√°ly forr√°sk√≥dj√°nak megtekint√©se sem √°rulja el, melyik inicializ√°ci√≥s met√≥dust kell megh√≠vnia. Legjobb esetben tal√°lhat egy glob√°lis v√°ltoz√≥t, amelyhez hozz√°f√©rnek, √©s abb√≥l megpr√≥b√°lhatja kital√°lni, hogyan inicializ√°lja.

Az ilyen projekt oszt√°lyai patologikus hazudoz√≥k. A bankk√°rtya √∫gy tesz, mintha el√©g lenne p√©ld√°nyos√≠tani √©s megh√≠vni a `charge()` met√≥dust. Titokban azonban egy√ºttm≈±k√∂dik egy m√°sik `PaymentGateway` oszt√°llyal, amely a fizet√©si kaput k√©pviseli. Annak interf√©sze is azt mondja, hogy √∂n√°ll√≥an inicializ√°lhat√≥, de val√≥j√°ban kih√∫zza a hiteles√≠t≈ë adatokat valamilyen konfigur√°ci√≥s f√°jlb√≥l √©s √≠gy tov√°bb.
A fejleszt≈ëknek, akik ezt a k√≥dot √≠rt√°k, vil√°gos, hogy a `CreditCard`-nak sz√ºks√©ge van a `PaymentGateway`-re. √çgy √≠rt√°k a k√≥dot. De b√°rki sz√°m√°ra, aki √∫j a projektben, ez teljes rejt√©ly, √©s akad√°lyozza a tanul√°st.

Hogyan jav√≠tsuk a helyzetet? K√∂nnyen. **Hagyja, hogy az API deklar√°lja a f√ºgg≈ës√©geket.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Figyelje meg, hogyan v√°lnak hirtelen nyilv√°nval√≥v√° a k√≥don bel√ºli kapcsolatok. Azzal, hogy a `charge()` met√≥dus deklar√°lja, hogy sz√ºks√©ge van a `PaymentGateway`-re, nem kell senkit≈ël megk√©rdeznie, hogyan van √∂sszekapcsolva a k√≥d. Tudja, hogy l√©tre kell hoznia annak p√©ld√°ny√°t, √©s amikor megpr√≥b√°lja, r√°j√∂n, hogy meg kell adnia a hozz√°f√©r√©si param√©tereket. N√©lk√ºl√ºk a k√≥d el sem indulna.

√âs ami a legfontosabb, most m√°r mockolhatja a fizet√©si kaput, √≠gy nem vonnak le 100 doll√°rt minden tesztfuttat√°skor.

A glob√°lis √°llapot miatt az objektumai titokban hozz√°f√©rhetnek olyan dolgokhoz, amelyek nincsenek deklar√°lva az API-jukban, √©s ennek k√∂vetkezt√©ben az API-jai patologikus hazudoz√≥kk√° v√°lnak.

Tal√°n kor√°bban nem gondolt r√° √≠gy, de minden alkalommal, amikor glob√°lis √°llapotot haszn√°l, titkos vezet√©k n√©lk√ºli kommunik√°ci√≥s csatorn√°kat hoz l√©tre. A k√≠s√©rteties t√°volhat√°s arra k√©nyszer√≠ti a fejleszt≈ëket, hogy minden k√≥dsort elolvassanak a potenci√°lis interakci√≥k meg√©rt√©s√©hez, cs√∂kkenti a fejleszt≈ëk termel√©kenys√©g√©t √©s megzavarja az √∫j csapattagokat.
Ha √ñn hozta l√©tre a k√≥dot, ismeri a val√≥di f√ºgg≈ës√©geket, de b√°rki, aki √ñn ut√°n j√∂n, tan√°cstalan.

Ne √≠rjon olyan k√≥dot, amely glob√°lis √°llapotot haszn√°l, r√©szes√≠tse el≈ënyben a f√ºgg≈ës√©gek √°tad√°s√°t. Teh√°t a dependency injection-t.


Glob√°lis √°llapot t√∂r√©kenys√©ge
-----------------------------

A glob√°lis √°llapotot √©s singletonokat haszn√°l√≥ k√≥dban soha nem biztos, hogy mikor √©s ki v√°ltoztatta meg ezt az √°llapotot. Ez a kock√°zat m√°r az inicializ√°l√°skor megjelenik. A k√∂vetkez≈ë k√≥dnak adatb√°zis-kapcsolatot kellene l√©trehoznia √©s inicializ√°lnia a fizet√©si kaput, azonban folyamatosan kiv√©telt dob, √©s az ok keres√©se rendk√≠v√ºl hosszadalmas:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

R√©szletesen √°t kell n√©znie a k√≥dot, hogy r√°j√∂jj√∂n, a `PaymentGateway` objektum vezet√©k n√©lk√ºl hozz√°f√©r m√°s objektumokhoz, amelyek k√∂z√ºl n√©h√°ny adatb√°zis-kapcsolatot ig√©nyel. Teh√°t az adatb√°zist kor√°bban kell inicializ√°lni, mint a `PaymentGateway`-t. Azonban a glob√°lis √°llapot f√ºstf√ºgg√∂nye ezt elrejti √ñn el≈ël. Mennyi id≈ët takar√≠thatna meg, ha az egyes oszt√°lyok API-ja nem hazudna, √©s deklar√°ln√° a f√ºgg≈ës√©geit?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Hasonl√≥ probl√©ma mer√ºl fel az adatb√°zis-kapcsolat glob√°lis el√©r√©s√©nek haszn√°latakor is:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

A `save()` met√≥dus h√≠v√°sakor nem biztos, hogy m√°r l√©trej√∂tt-e az adatb√°zis-kapcsolat, √©s ki felel≈ës annak l√©trehoz√°s√°√©rt. Ha p√©ld√°ul fut√°s k√∂zben szeretn√©nk megv√°ltoztatni az adatb√°zis-kapcsolatot, p√©ld√°ul tesztek miatt, val√≥sz√≠n≈±leg tov√°bbi met√≥dusokat kellene l√©trehoznunk, mint p√©ld√°ul `DB::reconnect(...)` vagy `DB::reconnectForTest()`.

Vegy√ºnk egy p√©ld√°t:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Hol van a biztos√≠t√©k arra, hogy a `$article->save()` h√≠v√°sakor val√≥ban a tesztadatb√°zist haszn√°ljuk? Mi van, ha a `Foo::doSomething()` met√≥dus megv√°ltoztatta a glob√°lis adatb√°zis-kapcsolatot? Ennek kider√≠t√©s√©hez meg kellene vizsg√°lnunk a `Foo` oszt√°ly forr√°sk√≥dj√°t, √©s val√≥sz√≠n≈±leg sok m√°s oszt√°ly√©t is. Ez a megk√∂zel√≠t√©s azonban csak r√∂vid t√°v√∫ v√°laszt adna, mivel a helyzet a j√∂v≈ëben megv√°ltozhat.

√âs mi van, ha az adatb√°zis-kapcsolatot egy statikus v√°ltoz√≥ba helyezz√ºk az `Article` oszt√°lyon bel√ºl?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Ezzel egy√°ltal√°n semmi sem v√°ltozott. A probl√©ma a glob√°lis √°llapot, √©s teljesen mindegy, melyik oszt√°lyban rejt≈ëzik. Ebben az esetben, ak√°rcsak az el≈ëz≈ëben, a `$article->save()` met√≥dus h√≠v√°sakor nincs semmilyen t√°mpontunk arra vonatkoz√≥an, hogy melyik adatb√°zisba √≠r√≥dik. B√°rki az alkalmaz√°s m√°sik v√©g√©n b√°rmikor megv√°ltoztathatta az adatb√°zist az `Article::setDb()` seg√≠ts√©g√©vel. A kez√ºnk alatt.

A glob√°lis √°llapot **rendk√≠v√ºl t√∂r√©kenny√©** teszi az alkalmaz√°sunkat.

Van azonban egy egyszer≈± m√≥dja ennek a probl√©m√°nak a kezel√©s√©re. Csak hagyni kell, hogy az API deklar√°lja a f√ºgg≈ës√©geket, ami biztos√≠tja a helyes m≈±k√∂d√©st.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Ennek a megk√∂zel√≠t√©snek k√∂sz√∂nhet≈ëen megsz≈±nik az aggodalom a rejtett √©s v√°ratlan adatb√°zis-kapcsolat v√°ltoz√°sok miatt. Most m√°r biztosak lehet√ºnk benne, hova ment≈ëdik a cikk, √©s semmilyen k√≥dm√≥dos√≠t√°s egy m√°sik, nem kapcsol√≥d√≥ oszt√°lyon bel√ºl m√°r nem v√°ltoztathat a helyzeten. A k√≥d m√°r nem t√∂r√©keny, hanem stabil.

Ne √≠rjon olyan k√≥dot, amely glob√°lis √°llapotot haszn√°l, r√©szes√≠tse el≈ënyben a f√ºgg≈ës√©gek √°tad√°s√°t. Teh√°t a dependency injection-t.


Singleton
---------

A Singleton egy tervez√©si minta, amely a h√≠res Gang of Four kiadv√°ny ["defin√≠ci√≥ja":https://en.wikipedia.org/wiki/Singleton_pattern] szerint egy oszt√°lyt egyetlen p√©ld√°nyra korl√°toz, √©s glob√°lis hozz√°f√©r√©st k√≠n√°l hozz√°. Ennek a mint√°nak az implement√°ci√≥ja √°ltal√°ban a k√∂vetkez≈ë k√≥dhoz hasonl√≠t:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// √©s tov√°bbi met√≥dusok, amelyek az adott oszt√°ly funkci√≥it t√∂ltik be
}
```

Sajnos a singleton glob√°lis √°llapotot vezet be az alkalmaz√°sba. √âs ahogy fentebb megmutattuk, a glob√°lis √°llapot nemk√≠v√°natos. Ez√©rt a singletont antipattern-nek tekintik.

Ne haszn√°ljon singletonokat a k√≥dj√°ban, √©s helyettes√≠tse ≈ëket m√°s mechanizmusokkal. Val√≥ban nincs sz√ºks√©ge singletonokra. Ha azonban garant√°lnia kell egy oszt√°ly egyetlen p√©ld√°ny√°nak l√©tez√©s√©t az eg√©sz alkalmaz√°s sz√°m√°ra, b√≠zza azt a [DI kont√©nerre |container].
Hozzon l√©tre √≠gy egy alkalmaz√°s szint≈± singletont, azaz egy szolg√°ltat√°st. Ezzel az oszt√°ly megsz≈±nik foglalkozni saj√°t egyedis√©g√©nek biztos√≠t√°s√°val (azaz nem lesz `getInstance()` met√≥dusa √©s statikus v√°ltoz√≥ja), √©s csak a funkci√≥it fogja ell√°tni. √çgy megsz≈±nik megs√©rteni az egyetlen felel≈ëss√©g elv√©t.


Glob√°lis √°llapot versus tesztek
-------------------------------

Tesztek √≠r√°sakor felt√©telezz√ºk, hogy minden teszt egy izol√°lt egys√©g, √©s hogy semmilyen k√ºls≈ë √°llapot nem l√©p be. √âs semmilyen √°llapot nem hagyja el a teszteket. A teszt befejez√©se ut√°n minden, a teszthez kapcsol√≥d√≥ √°llapotot automatikusan el kell t√°vol√≠tania a garbage collectornak. Ennek k√∂sz√∂nhet≈ëen a tesztek izol√°ltak. Ez√©rt futtathatjuk a teszteket tetsz≈ëleges sorrendben.

Ha azonban glob√°lis √°llapotok/singletonok vannak jelen, mindezek a kellemes felt√©telez√©sek √∂sszeomlanak. Az √°llapot bel√©phet a tesztbe √©s kil√©phet bel≈ële. Hirtelen sz√°m√≠that a tesztek sorrendje.

Ahhoz, hogy egy√°ltal√°n tesztelni tudjuk a singletonokat, a fejleszt≈ëk gyakran k√©nytelenek laz√≠tani a tulajdons√°gaikat, p√©ld√°ul az√°ltal, hogy megengedik a p√©ld√°ny cser√©j√©t egy m√°sikkal. Az ilyen megold√°sok legjobb esetben is hackek, amelyek nehezen karbantarthat√≥ √©s √©rthet≈ë k√≥dot hoznak l√©tre. Minden tesztnek vagy `tearDown()` met√≥dusnak, amely b√°rmilyen glob√°lis √°llapotot befoly√°sol, vissza kell √°ll√≠tania ezeket a v√°ltoztat√°sokat.

A glob√°lis √°llapot a legnagyobb fejf√°j√°s az unit tesztel√©s sor√°n!

Hogyan jav√≠tsuk a helyzetet? K√∂nnyen. Ne √≠rjon olyan k√≥dot, amely singletonokat haszn√°l, r√©szes√≠tse el≈ënyben a f√ºgg≈ës√©gek √°tad√°s√°t. Teh√°t a dependency injection-t.


Glob√°lis konstansok
-------------------

A glob√°lis √°llapot nem korl√°toz√≥dik csak a singletonok √©s statikus v√°ltoz√≥k haszn√°lat√°ra, hanem glob√°lis konstansokra is vonatkozhat.

Azok a konstansok, amelyek √©rt√©ke nem hoz sz√°munkra semmilyen √∫j (`M_PI`) vagy hasznos (`PREG_BACKTRACK_LIMIT_ERROR`) inform√°ci√≥t, egy√©rtelm≈±en rendben vannak.
Ellenben azok a konstansok, amelyek arra szolg√°lnak, hogy *vezet√©k n√©lk√ºl* inform√°ci√≥t adjanak √°t a k√≥dba, nem m√°sok, mint rejtett f√ºgg≈ës√©gek. Mint p√©ld√°ul a `LOG_FILE` a k√∂vetkez≈ë p√©ld√°ban.
A `FILE_APPEND` konstans haszn√°lata teljesen korrekt.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ebben az esetben deklar√°lnunk kellene egy param√©tert a `Foo` oszt√°ly konstruktor√°ban, hogy az API r√©sz√©v√© v√°ljon:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Most m√°r √°tadhatjuk az inform√°ci√≥t a napl√≥f√°jl el√©r√©si √∫tj√°r√≥l, √©s sz√ºks√©g szerint k√∂nnyen megv√°ltoztathatjuk, ami megk√∂nny√≠ti a k√≥d tesztel√©s√©t √©s karbantart√°s√°t.


Glob√°lis f√ºggv√©nyek √©s statikus met√≥dusok
-----------------------------------------

Szeretn√©nk hangs√∫lyozni, hogy maguk a statikus met√≥dusok √©s glob√°lis f√ºggv√©nyek haszn√°lata nem problematikus. Elmagyar√°ztuk, mi√©rt nem megfelel≈ë a `DB::insert()` √©s hasonl√≥ met√≥dusok haszn√°lata, de ez mindig csak a glob√°lis √°llapot k√©rd√©se volt, amely valamilyen statikus v√°ltoz√≥ban van t√°rolva. A `DB::insert()` met√≥dus megk√∂veteli egy statikus v√°ltoz√≥ l√©tez√©s√©t, mert abban van t√°rolva az adatb√°zis-kapcsolat. E v√°ltoz√≥ n√©lk√ºl lehetetlen lenne a met√≥dust implement√°lni.

Determinisztikus statikus met√≥dusok √©s f√ºggv√©nyek haszn√°lata, mint p√©ld√°ul a `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` √©s sok m√°s, teljes m√©rt√©kben √∂sszhangban van a dependency injection-nel. Ezek a f√ºggv√©nyek mindig ugyanazokat az eredm√©nyeket adj√°k vissza ugyanazokb√≥l a bemeneti param√©terekb≈ël, √©s ez√©rt el≈ërejelezhet≈ëk. Nem haszn√°lnak semmilyen glob√°lis √°llapotot.

L√©teznek azonban olyan f√ºggv√©nyek is PHP-ban, amelyek nem determinisztikusak. Ezek k√∂z√© tartozik p√©ld√°ul a `htmlspecialchars()` f√ºggv√©ny. Annak harmadik param√©tere, a `$encoding`, ha nincs megadva, alap√©rtelmezett √©rt√©kk√©nt a `ini_get('default_charset')` konfigur√°ci√≥s opci√≥ √©rt√©k√©t veszi fel. Ez√©rt aj√°nlott ezt a param√©tert mindig megadni, hogy elker√ºlj√ºk a f√ºggv√©ny esetleges kisz√°m√≠thatatlan viselked√©s√©t. A Nette ezt k√∂vetkezetesen megteszi.

N√©h√°ny f√ºggv√©ny, mint p√©ld√°ul a `strtolower()`, `strtoupper()` √©s hasonl√≥k, a k√∂zelm√∫ltban nem determinisztikusan viselkedtek, √©s a `setlocale()` be√°ll√≠t√°st√≥l f√ºggtek. Ez sok komplik√°ci√≥t okozott, leggyakrabban a t√∂r√∂k nyelvvel val√≥ munka sor√°n.
Az ugyanis megk√ºl√∂nb√∂zteti a kis- √©s nagybet≈±s `I`-t ponttal √©s pont n√©lk√ºl is. √çgy a `strtolower('I')` az `ƒ±` karaktert adta vissza, a `strtoupper('i')` pedig az `ƒ∞` karaktert, ami ahhoz vezetett, hogy az alkalmaz√°sok sz√°mos rejt√©lyes hib√°t kezdtek okozni.
Ezt a probl√©m√°t azonban a PHP 8.2-es verzi√≥j√°ban orvosolt√°k, √©s a f√ºggv√©nyek m√°r nem f√ºggnek a locale-t√≥l.

Ez egy sz√©p p√©lda arra, hogyan okozott fejf√°j√°st a glob√°lis √°llapot t√∂bb ezer fejleszt≈ënek vil√°gszerte. A megold√°s az volt, hogy dependency injection-nel helyettes√≠tett√©k.


Mikor lehet glob√°lis √°llapotot haszn√°lni?
-----------------------------------------

L√©teznek bizonyos specifikus helyzetek, amikor lehet glob√°lis √°llapotot haszn√°lni. P√©ld√°ul a k√≥d debuggol√°sakor, amikor ki kell √≠ratni egy v√°ltoz√≥ √©rt√©k√©t, vagy meg kell m√©rni egy programr√©sz fut√°si idej√©t. Ilyen esetekben, amelyek ideiglenes m≈±veletekre vonatkoznak, amelyeket k√©s≈ëbb elt√°vol√≠tanak a k√≥db√≥l, legitim egy glob√°lisan el√©rhet≈ë dumper vagy stopper√≥ra haszn√°lata. Ezek az eszk√∂z√∂k ugyanis nem r√©szei a k√≥d tervez√©s√©nek.

Egy m√°sik p√©lda a regul√°ris kifejez√©sekkel dolgoz√≥ `preg_*` f√ºggv√©nyek, amelyek bels≈ëleg statikus cache-ben t√°rolj√°k a leford√≠tott regul√°ris kifejez√©seket a mem√≥ri√°ban. Teh√°t ha ugyanazt a regul√°ris kifejez√©st t√∂bbsz√∂r h√≠vja meg a k√≥d k√ºl√∂nb√∂z≈ë pontjain, csak egyszer ford√≠t√≥dik le. A cache teljes√≠tm√©nyt takar√≠t meg, √©s ugyanakkor a felhaszn√°l√≥ sz√°m√°ra teljesen l√°thatatlan, ez√©rt az ilyen haszn√°lat legitimnek tekinthet≈ë.


√ñsszegz√©s
---------

Megbesz√©lt√ºk, mi√©rt van √©rtelme:

1) Elt√°vol√≠tani minden statikus v√°ltoz√≥t a k√≥db√≥l
2) Deklar√°lni a f√ºgg≈ës√©geket
3) √âs haszn√°lni a dependency injection-t

Amikor a k√≥d tervez√©s√©n gondolkodik, gondoljon arra, hogy minden `static $foo` probl√©m√°t jelent. Ahhoz, hogy a k√≥dja DI-t tiszteletben tart√≥ k√∂rnyezet legyen, elengedhetetlen a glob√°lis √°llapot teljes kiirt√°sa √©s dependency injection-nel val√≥ helyettes√≠t√©se.

E folyamat sor√°n tal√°n r√°j√∂n, hogy egy oszt√°lyt fel kell osztani, mert t√∂bb felel≈ëss√©ge van. Ne f√©ljen ett≈ël; t√∂rekedjen az egyetlen felel≈ëss√©g elv√©re.

*Szeretn√©k k√∂sz√∂netet mondani Mi≈°ko Hevery-nek, akinek cikkei, mint p√©ld√°ul a [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], k√©pezik ennek a fejezetnek az alapj√°t.*
