Starea globalÄƒ È™i singletoni
****************************

.[perex]
Avertisment: UrmÄƒtoarele construcÈ›ii sunt simptome ale unui cod prost conceput:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` sau `static::$var`

ÃntÃ¢lneÈ™ti vreunul dintre aceste construcÈ›ii Ã®n codul tÄƒu? Ãn caz afirmativ, aveÈ›i posibilitatea de a-l Ã®mbunÄƒtÄƒÈ›i. S-ar putea sÄƒ vÄƒ gÃ¢ndiÈ›i cÄƒ acestea sunt construcÈ›ii obiÈ™nuite, vÄƒzute adesea Ã®n soluÈ›ii de exemplu ale diferitelor biblioteci È™i cadre de lucru. DacÄƒ este aÈ™a, designul codului lor este defectuos.

Nu vorbim aici despre o puritate academicÄƒ. Toate aceste construcÈ›ii au un lucru Ã®n comun: utilizeazÄƒ starea globalÄƒ. Iar acest lucru are un impact distructiv asupra calitÄƒÈ›ii codului. Clasele sunt Ã®nÈ™elÄƒtoare Ã®n ceea ce priveÈ™te dependenÈ›ele lor. Codul devine imprevizibil. Ãi Ã®ncurcÄƒ pe dezvoltatori È™i le reduce eficienÈ›a.

Ãn acest capitol, vom explica de ce se Ã®ntÃ¢mplÄƒ acest lucru È™i cum sÄƒ evitÄƒm starea globalÄƒ.


Interconectarea globalÄƒ .[#toc-global-interlinking]
---------------------------------------------------

Ãntr-o lume idealÄƒ, un obiect ar trebui sÄƒ comunice numai cu obiectele care [i-au fost transmise direct |passing-dependencies]. DacÄƒ creez douÄƒ obiecte `A` È™i `B` È™i nu transmit niciodatÄƒ o referinÈ›Äƒ Ã®ntre ele, atunci nici `A` È™i nici `B` nu pot accesa sau modifica starea celuilalt. Aceasta este o proprietate foarte doritÄƒ a codului. Este ca È™i cum ai avea o baterie È™i un bec; becul nu se va aprinde pÃ¢nÄƒ cÃ¢nd nu Ã®l conectezi la baterie cu un fir.

Cu toate acestea, acest lucru nu este valabil pentru variabilele globale (statice) sau singletone. Obiectul `A` poate accesa *fÄƒrÄƒ fir* obiectul `C` È™i Ã®l poate modifica fÄƒrÄƒ a trece referinÈ›e, prin apelarea `C::changeSomething()`. Ãn cazul Ã®n care obiectul `B` acceseazÄƒ È™i obiectul global `C`, atunci `A` È™i `B` se pot influenÈ›a reciproc prin intermediul `C`.

Utilizarea variabilelor globale introduce o nouÄƒ formÄƒ de cuplare *fÄƒrÄƒ fir* care nu este vizibilÄƒ din exterior. Aceasta creeazÄƒ o perdea de fum care complicÄƒ Ã®nÈ›elegerea È™i utilizarea codului. Pentru a Ã®nÈ›elege cu adevÄƒrat dependenÈ›ele, dezvoltatorii trebuie sÄƒ citeascÄƒ fiecare linie a codului sursÄƒ, Ã®n loc sÄƒ se familiarizeze doar cu interfeÈ›ele claselor. Ãn plus, aceastÄƒ Ã®ncurcÄƒturÄƒ este complet inutilÄƒ. Starea globalÄƒ este utilizatÄƒ deoarece este uÈ™or de accesat de oriunde È™i permite, de exemplu, scrierea Ã®ntr-o bazÄƒ de date prin intermediul unei metode globale (statice) `DB::insert()`. Cu toate acestea, dupÄƒ cum vom vedea, beneficiul pe care Ã®l oferÄƒ este minim, Ã®n timp ce complicaÈ›iile pe care le introduce sunt grave.

.[note]
Ãn ceea ce priveÈ™te comportamentul, nu existÄƒ nicio diferenÈ›Äƒ Ã®ntre o variabilÄƒ globalÄƒ È™i una staticÄƒ. Ele sunt la fel de dÄƒunÄƒtoare.


AcÈ›iunea Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ .[#toc-the-spooky-action-at-a-distance]
---------------------------------------------------------------------------

"AcÈ›iunea ciudatÄƒ la distanÈ›Äƒ" - aÈ™a a numit Albert Einstein un fenomen din fizica cuanticÄƒ care i-a dat fiori Ã®n 1935.
Este vorba despre entanglarea cuanticÄƒ, a cÄƒrei particularitate este cÄƒ atunci cÃ¢nd mÄƒsori informaÈ›ii despre o particulÄƒ, afectezi imediat o altÄƒ particulÄƒ, chiar dacÄƒ acestea se aflÄƒ la milioane de ani luminÄƒ distanÈ›Äƒ.
Ceea ce aparent Ã®ncalcÄƒ legea fundamentalÄƒ a universului conform cÄƒreia nimic nu poate cÄƒlÄƒtori mai repede decÃ¢t lumina.

Ãn lumea software-ului, putem numi "acÈ›iune fantomaticÄƒ la distanÈ›Äƒ" o situaÈ›ie Ã®n care rulÄƒm un proces pe care Ã®l considerÄƒm izolat (deoarece nu i-am transmis nicio referinÈ›Äƒ), dar interacÈ›iuni neaÈ™teptate È™i schimbÄƒri de stare au loc Ã®n locaÈ›ii Ã®ndepÄƒrtate ale sistemului, despre care nu am informat obiectul. Acest lucru se poate Ã®ntÃ¢mpla numai prin intermediul stÄƒrii globale.

ImaginaÈ›i-vÄƒ cÄƒ vÄƒ alÄƒturaÈ›i unei echipe de dezvoltare a unui proiect care are o bazÄƒ de cod mare È™i maturÄƒ. Noul dvs. È™ef vÄƒ cere sÄƒ implementaÈ›i o nouÄƒ caracteristicÄƒ È™i, ca un bun dezvoltator, Ã®ncepeÈ›i prin a scrie un test. Dar, pentru cÄƒ sunteÈ›i nou Ã®n proiect, faceÈ›i o mulÈ›ime de teste exploratorii de tipul "ce se Ã®ntÃ¢mplÄƒ dacÄƒ apelez aceastÄƒ metodÄƒ". È˜i Ã®ncercaÈ›i sÄƒ scrieÈ›i urmÄƒtorul test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // numÄƒrul cardului dvs.
	$cc->charge(100);
}
```

RulaÈ›i codul, poate de mai multe ori, È™i dupÄƒ un timp observaÈ›i notificÄƒri pe telefon de la bancÄƒ care vÄƒ anunÈ›Äƒ cÄƒ, de fiecare datÄƒ cÃ¢nd Ã®l executaÈ›i, 100 de dolari au fost debitaÈ›i de pe cardul dvs. de credit ğŸ¤¦â€â™‚ï¸.

Cum naiba a putut testul sÄƒ provoace o Ã®ncÄƒrcare realÄƒ? Nu este uÈ™or de operat cu cardul de credit. Trebuie sÄƒ interacÈ›ionezi cu un serviciu web terÈ›, trebuie sÄƒ cunoÈ™ti URL-ul acelui serviciu web, trebuie sÄƒ te loghezi È™i aÈ™a mai departe.
Niciuna dintre aceste informaÈ›ii nu este inclusÄƒ Ã®n test. Chiar mai rÄƒu, nici mÄƒcar nu È™tiÈ›i unde sunt prezente aceste informaÈ›ii È™i, prin urmare, nu È™tiÈ›i cum sÄƒ vÄƒ bateÈ›i joc de dependenÈ›ele externe, astfel Ã®ncÃ¢t fiecare execuÈ›ie sÄƒ nu ducÄƒ la o nouÄƒ taxare de 100 de dolari. È˜i, Ã®n calitate de dezvoltator nou, de unde sÄƒ È™tii cÄƒ ceea ce urma sÄƒ faci te va duce la o sÄƒrÄƒcie de 100 de dolari?

Aceasta este o acÈ›iune Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ!

Nu ai altÄƒ soluÈ›ie decÃ¢t sÄƒ scotoceÈ™ti prin mult cod sursÄƒ, Ã®ntrebÃ¢nd colegi mai vechi È™i mai experimentaÈ›i, pÃ¢nÄƒ cÃ¢nd Ã®nÈ›elegi cum funcÈ›ioneazÄƒ conexiunile din proiect.
Acest lucru se datoreazÄƒ faptului cÄƒ, atunci cÃ¢nd vÄƒ uitaÈ›i la interfaÈ›a clasei `CreditCard`, nu puteÈ›i determina starea globalÄƒ care trebuie iniÈ›ializatÄƒ. Nici mÄƒcar dacÄƒ vÄƒ uitaÈ›i la codul sursÄƒ al clasei nu vÄƒ va spune ce metodÄƒ de iniÈ›ializare trebuie sÄƒ apelaÈ›i. Ãn cel mai bun caz, puteÈ›i gÄƒsi variabila globalÄƒ care este accesatÄƒ È™i Ã®ncercaÈ›i sÄƒ ghiciÈ›i cum sÄƒ o iniÈ›ializaÈ›i pornind de la aceasta.

Clasele dintr-un astfel de proiect sunt niÈ™te mincinoÈ™i patologici. Cardul de platÄƒ pretinde cÄƒ puteÈ›i pur È™i simplu sÄƒ Ã®l instanÈ›i È™i sÄƒ apelaÈ›i metoda `charge()`. Cu toate acestea, ea interacÈ›ioneazÄƒ Ã®n secret cu o altÄƒ clasÄƒ, `PaymentGateway`. Chiar È™i interfaÈ›a sa spune cÄƒ poate fi iniÈ›ializatÄƒ Ã®n mod independent, dar Ã®n realitate trage acreditÄƒrile dintr-un fiÈ™ier de configurare È™i aÈ™a mai departe.
Este clar pentru dezvoltatorii care au scris acest cod cÄƒ `CreditCard` are nevoie de `PaymentGateway`. AceÈ™tia au scris codul Ã®n acest fel. Dar pentru oricine este nou Ã®n proiect, acest lucru este un mister complet È™i Ã®mpiedicÄƒ Ã®nvÄƒÈ›area.

Cum se poate remedia situaÈ›ia? UÈ™or. **LasÄƒ API-ul sÄƒ declare dependenÈ›ele.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

ObservaÈ›i cum relaÈ›iile din cadrul codului sunt brusc evidente. DeclarÃ¢nd cÄƒ metoda `charge()` are nevoie de `PaymentGateway`, nu mai trebuie sÄƒ Ã®ntrebaÈ›i pe nimeni cum este interdependent codul. È˜tiÈ›i cÄƒ trebuie sÄƒ creaÈ›i o instanÈ›Äƒ a acesteia, iar cÃ¢nd Ã®ncercaÈ›i sÄƒ faceÈ›i acest lucru, vÄƒ loviÈ›i de faptul cÄƒ trebuie sÄƒ furnizaÈ›i parametri de acces. FÄƒrÄƒ aceÈ™tia, codul nici mÄƒcar nu ar funcÈ›iona.

È˜i, cel mai important, acum puteÈ›i sÄƒ vÄƒ bateÈ›i joc de gateway-ul de platÄƒ, astfel Ã®ncÃ¢t sÄƒ nu fiÈ›i taxat cu 100 de dolari de fiecare datÄƒ cÃ¢nd executaÈ›i un test.

Starea globalÄƒ face ca obiectele dvs. sÄƒ poatÄƒ accesa Ã®n secret lucruri care nu sunt declarate Ã®n API-urile lor È™i, ca urmare, face ca API-urile dvs. sÄƒ fie mincinoase patologice.

Poate cÄƒ nu v-aÈ›i gÃ¢ndit la asta pÃ¢nÄƒ acum, dar ori de cÃ¢te ori folosiÈ›i starea globalÄƒ, creaÈ›i canale secrete de comunicare fÄƒrÄƒ fir. AcÈ›iunile Ã®nfiorÄƒtoare de la distanÈ›Äƒ Ã®i obligÄƒ pe dezvoltatori sÄƒ citeascÄƒ fiecare linie de cod pentru a Ã®nÈ›elege interacÈ›iunile potenÈ›iale, reduc productivitatea dezvoltatorilor È™i Ã®i deruteazÄƒ pe noii membri ai echipei.
DacÄƒ tu eÈ™ti cel care a creat codul, cunoÈ™ti dependenÈ›ele reale, dar oricine vine dupÄƒ tine nu È™tie nimic.

Nu scrieÈ›i cod care utilizeazÄƒ starea globalÄƒ, preferaÈ›i sÄƒ treceÈ›i dependenÈ›ele. AdicÄƒ injectarea dependenÈ›elor.


BÄƒtÄƒlia statului global .[#toc-brittleness-of-the-global-state]
---------------------------------------------------------------

Ãn codul care utilizeazÄƒ starea globalÄƒ È™i singletonii, nu este niciodatÄƒ sigur cÃ¢nd È™i de cÄƒtre cine a fost schimbatÄƒ acea stare. Acest risc este deja prezent la iniÈ›ializare. UrmÄƒtorul cod ar trebui sÄƒ creeze o conexiune la baza de date È™i sÄƒ iniÈ›ializeze gateway-ul de platÄƒ, dar continuÄƒ sÄƒ arunce o excepÈ›ie, iar gÄƒsirea cauzei este extrem de anevoioasÄƒ:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Trebuie sÄƒ parcurgeÈ›i codul Ã®n detaliu pentru a descoperi cÄƒ obiectul `PaymentGateway` acceseazÄƒ alte obiecte fÄƒrÄƒ fir, dintre care unele necesitÄƒ o conexiune la baza de date. Astfel, trebuie sÄƒ iniÈ›ializaÈ›i baza de date Ã®nainte de `PaymentGateway`. Cu toate acestea, perdeaua de fum a statului global vÄƒ ascunde acest lucru. CÃ¢t timp aÈ›i economisi dacÄƒ API-ul fiecÄƒrei clase nu ar minÈ›i È™i nu È™i-ar declara dependenÈ›ele?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

O problemÄƒ similarÄƒ apare atunci cÃ¢nd se utilizeazÄƒ accesul global la o conexiune la o bazÄƒ de date:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Atunci cÃ¢nd se apeleazÄƒ metoda `save()`, nu se È™tie cu siguranÈ›Äƒ dacÄƒ a fost deja creatÄƒ o conexiune la baza de date È™i cine este responsabil pentru crearea acesteia. De exemplu, dacÄƒ am dori sÄƒ modificÄƒm din mers conexiunea la baza de date, poate Ã®n scopuri de testare, probabil cÄƒ ar trebui sÄƒ creÄƒm metode suplimentare, cum ar fi `DB::reconnect(...)` sau `DB::reconnectForTest()`.

LuaÈ›i Ã®n considerare un exemplu:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

De unde putem fi siguri cÄƒ baza de date de testare este Ã®ntr-adevÄƒr utilizatÄƒ atunci cÃ¢nd apelÄƒm `$article->save()`? Ce se Ã®ntÃ¢mplÄƒ dacÄƒ metoda `Foo::doSomething()` a schimbat conexiunea globalÄƒ la baza de date? Pentru a afla, ar trebui sÄƒ examinÄƒm codul sursÄƒ al clasei `Foo` È™i, probabil, al multor alte clase. Cu toate acestea, aceastÄƒ abordare ar oferi doar un rÄƒspuns pe termen scurt, deoarece situaÈ›ia se poate schimba Ã®n viitor.

Ce se Ã®ntÃ¢mplÄƒ dacÄƒ mutÄƒm conexiunea la baza de date Ã®ntr-o variabilÄƒ staticÄƒ Ã®n interiorul clasei `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Acest lucru nu schimbÄƒ absolut nimic. Problema este o stare globalÄƒ È™i nu conteazÄƒ Ã®n ce clasÄƒ se ascunde. Ãn acest caz, ca È™i Ã®n cel precedent, nu avem niciun indiciu cu privire la baza de date Ã®n care se scrie atunci cÃ¢nd este apelatÄƒ metoda `$article->save()`. Oricine aflat la capÄƒtul Ã®ndepÄƒrtat al aplicaÈ›iei ar putea schimba baza de date Ã®n orice moment folosind `Article::setDb()`. Ãn mÃ¢inile noastre.

Starea globalÄƒ face ca aplicaÈ›ia noastrÄƒ sÄƒ fie **extrem de fragilÄƒ**.

Cu toate acestea, existÄƒ o modalitate simplÄƒ de a rezolva aceastÄƒ problemÄƒ. Este suficient ca API-ul sÄƒ declare dependenÈ›ele pentru a asigura o funcÈ›ionalitate corespunzÄƒtoare.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

AceastÄƒ abordare eliminÄƒ grija modificÄƒrilor ascunse È™i neaÈ™teptate ale conexiunilor la baza de date. Acum suntem siguri unde este stocat articolul È™i nicio modificare de cod Ã®n interiorul unei alte clase fÄƒrÄƒ legÄƒturÄƒ nu mai poate schimba situaÈ›ia. Codul nu mai este fragil, ci stabil.

Nu scrieÈ›i cod care utilizeazÄƒ starea globalÄƒ, preferaÈ›i sÄƒ treceÈ›i dependenÈ›ele. Astfel, injecÈ›ia de dependenÈ›e.


Singleton .[#toc-singleton]
---------------------------

Singleton este un model de proiectare care, prin [definiÈ›ia |https://en.wikipedia.org/wiki/Singleton_pattern] din celebra publicaÈ›ie Gang of Four, limiteazÄƒ o clasÄƒ la o singurÄƒ instanÈ›Äƒ È™i oferÄƒ acces global la aceasta. Implementarea acestui model seamÄƒnÄƒ, de obicei, cu urmÄƒtorul cod:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// È™i alte metode care Ã®ndeplinesc funcÈ›iile clasei
}
```

Din pÄƒcate, singletonul introduce o stare globalÄƒ Ã®n aplicaÈ›ie. È˜i, dupÄƒ cum am arÄƒtat mai sus, starea globalÄƒ nu este de dorit. De aceea, singletonul este considerat un antipattern.

Nu folosiÈ›i singletonii Ã®n codul dvs. È™i Ã®nlocuiÈ›i-i cu alte mecanisme. Chiar nu aveÈ›i nevoie de singletons. Cu toate acestea, dacÄƒ trebuie sÄƒ garantaÈ›i existenÈ›a unei singure instanÈ›e a unei clase pentru Ã®ntreaga aplicaÈ›ie, lÄƒsaÈ›i acest lucru Ã®n seama [containerului DI |container].
Astfel, creaÈ›i un singleton de aplicaÈ›ie, sau serviciu. Acest lucru va Ã®mpiedica clasa sÄƒ Ã®È™i asigure propria unicitate (adicÄƒ nu va avea o metodÄƒ `getInstance()` È™i o variabilÄƒ staticÄƒ) È™i Ã®È™i va Ã®ndeplini doar funcÈ›iile. Astfel, nu va mai Ã®ncÄƒlca principiul responsabilitÄƒÈ›ii unice.


Starea globalÄƒ faÈ›Äƒ de teste .[#toc-global-state-versus-tests]
--------------------------------------------------------------

Atunci cÃ¢nd scriem teste, presupunem cÄƒ fiecare test este o unitate izolatÄƒ È™i cÄƒ nicio stare externÄƒ nu intrÄƒ Ã®n el. È˜i nicio stare nu pÄƒrÄƒseÈ™te testele. Atunci cÃ¢nd un test se finalizeazÄƒ, orice stare asociatÄƒ cu testul ar trebui sÄƒ fie eliminatÄƒ automat de cÄƒtre garbage collector. Acest lucru face ca testele sÄƒ fie izolate. Prin urmare, putem rula testele Ã®n orice ordine.

Cu toate acestea, dacÄƒ sunt prezente stÄƒri globale/singletele globale, toate aceste presupuneri frumoase se prÄƒbuÈ™esc. O stare poate intra È™i ieÈ™i dintr-un test. Dintr-o datÄƒ, ordinea testelor poate conta.

Pentru a testa singletonii, dezvoltatorii trebuie adesea sÄƒ relaxeze proprietÄƒÈ›ile acestora, poate permiÈ›Ã¢nd ca o instanÈ›Äƒ sÄƒ fie Ã®nlocuitÄƒ cu alta. Astfel de soluÈ›ii sunt, Ã®n cel mai bun caz, hack-uri care produc un cod dificil de Ã®ntreÈ›inut È™i de Ã®nÈ›eles. Orice test sau metodÄƒ `tearDown()` care afecteazÄƒ orice stare globalÄƒ trebuie sÄƒ anuleze aceste modificÄƒri.

Starea globalÄƒ este cea mai mare bÄƒtaie de cap Ã®n testarea unitarÄƒ!

Cum se poate remedia situaÈ›ia? UÈ™or. Nu scrieÈ›i cod care foloseÈ™te singletoni, preferaÈ›i sÄƒ treceÈ›i dependenÈ›ele. AdicÄƒ injecÈ›ia de dependenÈ›Äƒ.


Constante globale .[#toc-global-constants]
------------------------------------------

Starea globalÄƒ nu se limiteazÄƒ la utilizarea singletonilor È™i a variabilelor statice, ci se poate aplica È™i constantelor globale.

Constantele a cÄƒror valoare nu ne furnizeazÄƒ informaÈ›ii noi (`M_PI`) sau utile (`PREG_BACKTRACK_LIMIT_ERROR`) sunt Ã®n mod clar Ã®n regulÄƒ.
DimpotrivÄƒ, constantele care servesc drept modalitate de a transmite *fÄƒrÄƒ fir* informaÈ›ii Ã®n interiorul codului nu sunt altceva decÃ¢t o dependenÈ›Äƒ ascunsÄƒ. Cum ar fi `LOG_FILE` din exemplul urmÄƒtor.
Utilizarea constantei `FILE_APPEND` este perfect corectÄƒ.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ãn acest caz, ar trebui sÄƒ declarÄƒm parametrul Ã®n constructorul clasei `Foo` pentru a-l face parte din API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Acum putem transmite informaÈ›ii despre calea cÄƒtre fiÈ™ierul de logare È™i o putem modifica cu uÈ™urinÈ›Äƒ, dupÄƒ cum este necesar, facilitÃ¢nd testarea È™i Ã®ntreÈ›inerea codului.


FuncÈ›ii globale È™i metode statice .[#toc-global-functions-and-static-methods]
-----------------------------------------------------------------------------

Dorim sÄƒ subliniem faptul cÄƒ utilizarea metodelor statice È™i a funcÈ›iilor globale nu este Ã®n sine problematicÄƒ. Am explicat caracterul nepotrivit al utilizÄƒrii `DB::insert()` È™i a metodelor similare, dar Ã®ntotdeauna a fost vorba de starea globalÄƒ stocatÄƒ Ã®ntr-o variabilÄƒ staticÄƒ. Metoda `DB::insert()` necesitÄƒ existenÈ›a unei variabile statice, deoarece stocheazÄƒ conexiunea la baza de date. FÄƒrÄƒ aceastÄƒ variabilÄƒ, ar fi imposibil de implementat metoda.

Utilizarea metodelor È™i funcÈ›iilor statice deterministe, cum ar fi `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` È™i multe altele, este perfect coerentÄƒ cu injecÈ›ia de dependenÈ›Äƒ. Aceste funcÈ›ii returneazÄƒ Ã®ntotdeauna aceleaÈ™i rezultate la aceiaÈ™i parametri de intrare È™i, prin urmare, sunt previzibile. Ele nu utilizeazÄƒ nicio stare globalÄƒ.

Cu toate acestea, existÄƒ funcÈ›ii Ã®n PHP care nu sunt deterministe. Printre acestea se numÄƒrÄƒ, de exemplu, funcÈ›ia `htmlspecialchars()`. Cel de-al treilea parametru al acesteia, `$encoding`, dacÄƒ nu este specificat, este valoarea implicitÄƒ a opÈ›iunii de configurare `ini_get('default_charset')`. Prin urmare, se recomandÄƒ sÄƒ specificaÈ›i Ã®ntotdeauna acest parametru pentru a evita un eventual comportament imprevizibil al funcÈ›iei. Nette face acest lucru Ã®n mod constant.

Unele funcÈ›ii, cum ar fi `strtolower()`, `strtoupper()`, È™i altele similare, au avut un comportament nedeterminist Ã®n trecutul recent È™i au depins de setarea `setlocale()`. Acest lucru a cauzat multe complicaÈ›ii, cel mai adesea atunci cÃ¢nd se lucra cu limba turcÄƒ.
Acest lucru se datoreazÄƒ faptului cÄƒ limba turcÄƒ face distincÈ›ie Ã®ntre majuscule È™i minuscule `I` cu È™i fÄƒrÄƒ punct. Astfel, `strtolower('I')` returna caracterul `Ä±`, iar `strtoupper('i')` returna caracterul `Ä°`, ceea ce a dus la aplicaÈ›ii care provocau o serie de erori misterioase.
Cu toate acestea, aceastÄƒ problemÄƒ a fost rezolvatÄƒ Ã®n versiunea 8.2 a PHP, iar funcÈ›iile nu mai depind de locale.

Acesta este un exemplu frumos al modului Ã®n care statul global a afectat mii de dezvoltatori din Ã®ntreaga lume. SoluÈ›ia a fost Ã®nlocuirea acesteia cu injecÈ›ia de dependenÈ›Äƒ.


CÃ¢nd este posibil sÄƒ se utilizeze statul global? .[#toc-when-is-it-possible-to-use-global-state]
------------------------------------------------------------------------------------------------

ExistÄƒ anumite situaÈ›ii specifice Ã®n care este posibil sÄƒ se utilizeze starea globalÄƒ. De exemplu, atunci cÃ¢nd depanaÈ›i codul È™i trebuie sÄƒ descÄƒrcaÈ›i valoarea unei variabile sau sÄƒ mÄƒsuraÈ›i durata unei anumite pÄƒrÈ›i a programului. Ãn astfel de cazuri, care se referÄƒ la acÈ›iuni temporare care vor fi ulterior eliminate din cod, este legitim sÄƒ se utilizeze un dumper sau un cronometru disponibil la nivel global. Aceste instrumente nu fac parte din proiectarea codului.

Un alt exemplu este reprezentat de funcÈ›iile de lucru cu expresii regulate `preg_*`, care stocheazÄƒ intern expresiile regulate compilate Ã®ntr-o memorie cache staticÄƒ Ã®n memorie. Atunci cÃ¢nd apelaÈ›i aceeaÈ™i expresie regulatÄƒ de mai multe ori Ã®n diferite pÄƒrÈ›i ale codului, aceasta este compilatÄƒ o singurÄƒ datÄƒ. Memoria cache economiseÈ™te performanÈ›Äƒ È™i este, de asemenea, complet invizibilÄƒ pentru utilizator, astfel Ã®ncÃ¢t o astfel de utilizare poate fi consideratÄƒ legitimÄƒ.


Rezumat .[#toc-summary]
-----------------------

Am arÄƒtat de ce are sens

1) SÄƒ eliminÄƒm toate variabilele statice din cod
2) DeclaraÈ›i dependenÈ›ele
3) È˜i folosiÈ›i injectarea dependenÈ›elor

Atunci cÃ¢nd vÄƒ gÃ¢ndiÈ›i la proiectarea codului, nu uitaÈ›i cÄƒ fiecare `static $foo` reprezintÄƒ o problemÄƒ. Pentru ca codul dumneavoastrÄƒ sÄƒ fie un mediu care respectÄƒ DI, este esenÈ›ial sÄƒ eradicaÈ›i complet starea globalÄƒ È™i sÄƒ o Ã®nlocuiÈ›i cu injecÈ›ia de dependenÈ›Äƒ.

Ãn timpul acestui proces, s-ar putea sÄƒ descoperiÈ›i cÄƒ trebuie sÄƒ divizaÈ›i o clasÄƒ deoarece aceasta are mai multe responsabilitÄƒÈ›i. Nu vÄƒ faceÈ›i griji Ã®n aceastÄƒ privinÈ›Äƒ; strÄƒduiÈ›i-vÄƒ sÄƒ respectaÈ›i principiul unei singure responsabilitÄƒÈ›i.

*Doresc sÄƒ Ã®i mulÈ›umesc lui MiÅ¡ko Hevery, ale cÄƒrui articole, precum [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], constituie baza acestui capitol.*
