Какво е "прилагане на зависимостта"?
************************************

.[perex]
Тази глава ви запознава с основните техники за програмиране, които са в основата на цялата рамка на Nette и които трябва да следвате, когато пишете свои собствени приложения. Това са основите, от които се нуждаете, за да пишете чист, ясен и поддържан код.

Ако усвоите тези правила и ги следвате, рамката ще ви помага на всяка крачка от пътя. Той ще извърши рутинните задачи вместо вас и ще ви осигури възможно най-голям комфорт, за да можете да се съсредоточите върху самата логика.

Принципите, които показваме тук, са съвсем прости. Няма за какво да се притеснявате.


Помните ли първата си програма? .[#toc-remember-your-first-program]
-------------------------------------------------------------------

Нямаме представа на какъв език сте го написали, но ако е PHP, вероятно ще изглежда по следния начин

```php
function addition(float $a, float $b): float
{
	return $a + $b;
}

echo addition(23, 1); // извежда 24
```

Няколко тривиални реда код, но той крие толкова много ключови концепции. Виждаме, че има променливи. Кодът е разделен на по-малки единици, които са например функции. Предаваме им входни аргументи и те връщат резултати. Липсват само условия и цикли.

Това, че подаваме входни данни на функция и тя връща резултати, е напълно разбираема концепция, която се използва и в други области, например в математиката.

Една функция има сигнатура, която се състои от нейното име, списък с параметри и техните типове и накрая типа на връщаната стойност. Като потребители ние се интересуваме от сигнатурата; обикновено не е необходимо да знаем нищо за вътрешната реализация.

Сега си представете, че сигнатурата на функцията изглежда по следния начин:

```php
function addition(float $x): float
```

Допълнение с един параметър? Странно... Какво ще кажете за това?

```php
function addition(): float
```

Много е странно, нали? Как смятате, че се използва тази функция?

```php
echo addition(); // какво се показва тук?
```

При разглеждането на този вид код се объркваме. Не само че начинаещите няма да го разберат, но дори и опитните програмисти няма да разберат такъв код.

Чудя се как би изглеждала такава функция вътрешно? Откъде ще вземе своите променливи? Вероятно би могъл да ги получи *по някакъв начин* сам, например по този начин:

```php
function addition(): float
{
	$a = Input::get('a');
	$b = Input::get('b');
	return $a + $b;
}
```

Оказва се, че в тялото на функцията има скрити връзки към други функции (или статични методи) и за да разберем откъде всъщност идват допълненията, трябва да се разровим допълнително.


Не и по този начин! .[#toc-not-this-way]
----------------------------------------

Дизайнът, който току-що показахме, е есенция на много отрицателни качества:

- сигнатурата на функцията се преструва, че не се нуждае от суми, което ни обърква
- нямаме представа как да накараме функцията да изчислява с две други числа
- Трябваше да се вгледаме в кода, за да разберем откъде се вземат сумарните стойности.
- открихме скрити връзки.
- За да го разберем напълно, трябва да разгледаме и тези връзки.

Но дали изобщо задачата на функцията за добавяне е да получава необработени данни? Разбира се, че не е така.  Той отговаря само за добавянето.


Не искаме да се сблъскваме с такъв код и със сигурност не искаме да го пишем. Решението е просто: върнете се към основите и просто използвайте параметри:


```php
function addition(float $a, float $b): float
{
	return $a + $b;
}
```


Правило номер 1: Използвайте параметрите .[#toc-rule-1-use-parameters]
----------------------------------------------------------------------

Най-важното правило гласи: **всички данни, необходими на функциите или класовете, трябва да им бъдат предадени**.

Ако нарушим това правило, ще бъде невъзможно да направим кода ясен, чист и стабилен.

Ако го следваме, сме на път да създадем код без скрити ограничения. Стремеж към код, който е разбираем не само за автора, но и за всеки, който го прочете след това. Когато всичко е ясно от сигнатурите на функциите и класовете и не е необходимо да се търсят скрити тайни в имплементацията.

Тази техника за предаване на аргументи технически се нарича **инжектиране на зависимости**.

(Не бъркайте "инжектиране на зависимости" с "контейнер за инжектиране на зависимости"; това е нещо коренно различно и за контейнерите ще говорим в [следващата глава |container].)


От функции към класове .[#toc-from-functions-to-classes]
--------------------------------------------------------

Какво общо имат класовете с това? Класът е по-сложна единица от обикновена функция, но правило № 1 важи и тук. Просто има [повече начини за предаване на аргументи |passing-dependencies]. Например, много подобно на случая с функция:

```php
class Math
{
	public function addition(float $a, float $b): float
	{
		return $a + $b;
	}
}

$math = new Math;
echo $math->addition(23, 1); // 24
```

Или с други методи, или с конструктор:

```php
class Addition
{
	public function __construct(
		private float $a,
		private float $b,
	) {
	}

	public function calculate(): float
	{
		return $this->a + $this->b;
	}

}

$addition = new Addition(23, 1);
echo $addition->calculate(); // 24
```

И двата примера са в пълно съответствие с принципа за въвеждане на зависимости.


Примери от реалния живот .[#toc-real-life-examples]
---------------------------------------------------

В реалния свят не бихте написали класове за събиране на числа. Нека преминем към примери от реалния живот.

Да предположим, че имаме клас `Article`, който представлява статия в блог:

```php
class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		// запазване на статията в базата данни
	}
}
```

и използването му ще бъде следното:

```php
$article = new Article;
$article->title = '10 вещей, которые нужно знать о потере веса';
$article->content = 'Каждый год миллионы людей в ...';
$article->save();
```

Методът `save()` ще запази статията в таблицата на базата данни. Прилагането на този метод с помощта на [базата данни Nette |database:] би било лесно, ако не беше една трудност: откъде `Article` получава връзката с базата данни, т.е. обекта от клас `Nette\Database\Connection`?

Изглежда имаме много възможности. Той може да го вземе от някоя статична променлива. Или може да наследи от клас, който ще осигури връзката с базата данни. Или се възползвайте от т.нар. singleton. Или използвайте така наречените фасади, които се използват в Laravel:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		DB::insert(
			'INSERT INTO articles (title, content) VALUES (?, ?)',
			[$this->title, $this->content],
		);
	}
}
```

Чудесно, решихме проблема.

Или сме го направили?

Запомнете [правило № 1: използвайте параметри |#правило №1: использовать параметры]: трябва да предадем на класа всички данни, от които се нуждае. Защото ако не го направим и нарушим правилото, ще тръгнем по пътя на разхвърлян код, пълен със скрити връзки, неясноти, и накрая ще получим приложение, което е много трудно да се поддържа и разработва.

Потребителят на класа `Article` няма представа къде методът `save()` съхранява статията. В таблица от базата данни? Кой от тях - хрупкав или тестови? И как може да се промени това?

Потребителят трябва да разгледа начина, по който е реализиран методът `save()`, за да открие употребата на метода `DB::insert()`. Така че той трябва да потърси допълнително, за да разбере как този метод осигурява връзката с базата данни. А скритите връзки могат да образуват доста дълга верига.

Скритите връзки, фасадите на Laravel или статичните променливи никога не присъстват в чист, добре проектиран код. В чистия и добре проектиран код се предават аргументи:

```php
class Article
{
	public function save(Nette\Database\Connection $db): void
	{
		$db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Още по-практично, както ще видим по-нататък, е използването на конструктор:

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function save(): void
	{
		$this->db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Ако ще пишете клас, който се нуждае от база данни, например, не измисляйте откъде да я вземете, а я оставете да ви бъде предадена. Може би като параметър на конструктор или друг метод. Деклариране на зависимости. Декларирайте ги в API на класа си. Ще получите ясен и предвидим код.

Какво ще кажете за клас, който регистрира съобщения за грешки:

```php
class Logger
{
	public function log(string $message)
	{
		$file = LOG_DIR . '/log.txt';
		file_put_contents($file, $message . "\n", FILE_APPEND);
	}
}
```

Смятате ли, че сме спазили [правило № 1: използвайте параметри |#правилу №1: использовать параметры]?

Не.

Класът *получава* ключовата информация, директорията, съдържаща файла с дневника, от константа.

Вижте пример за използване:

```php
$logger = new Logger;
$logger->log('Температура 23 °C');
$logger->log('Температура 10 °C');
```

Можете ли да отговорите на въпроса къде се записват съобщенията, без да познавате изпълнението? Не мислите ли, че съществуването на константата LOG_DIR е необходимо, за да работи? А можете ли да създадете втори екземпляр, който да записва на друго място? Разбира се, че не.

Да поправим класа:

```php
class Logger
{
	public function __construct(
		private string $file,
	) {
	}

	public function log(string $message)
	{
		file_put_contents($this->file, $message . "\n", FILE_APPEND);
	}
}
```

Класът вече е много по-ясен, може да се персонализира и следователно е по-полезен:

```php
$logger = new Logger('/path/to/log.txt');
$logger->log('Температура 15 °C');
```


Но на мен не ми пука! .[#toc-but-i-don-t-care]
----------------------------------------------

*"Когато създавам обект Article и извиквам save(), не искам да се занимавам с базата данни, а само да го запазя в тази, която съм задал в конфигурацията. "*

*"Когато използвам Logger, искам само съобщението да бъде записано и не искам да се занимавам с това къде. Нека се използват глобалните настройки. "*

Това са валидни коментари.

Като пример, нека вземем клас, който изпраща информационни известия и регистрира резултатите от изпращането:

```php
class NewsletterDistributor
{
	public function distribute(): void
	{
		$logger = new Logger(/* ... */);
		try {
			$this->sendEmails();
			$logger->log('Были разосланы электронные письма');

		} catch (Exception $e) {
			$logger->log('Во время отправки произошла ошибка');
			throw $e;
		}
	}
}
```

Новият `Logger`, който вече не използва константата `LOG_DIR`, обаче изисква пътят до файла да бъде посочен в конструктора. Как може да бъде решен този проблем? Класът `NewsletterDistributor` не се интересува от това къде се записват съобщенията, той просто иска да ги запише.

Решението отново е [правило № 1: използвайте параметри |#правило №1: используйте параметры]: предайте на класа всички данни, които той иска.

Така че предаваме пътя до дневника на конструктора, който след това използваме при създаването на обекта `Logger`? Не. защото пътят не е информацията, от която се нуждае класът `NewsletterDistributor`. Класът се нуждае от самия регистратор. И ние ще го приемем:


```php
class NewsletterDistributor
{
	public function __construct(
		private Logger $logger,
	) {
	}

	public function distribute(): void
	{
		try {
			$this->sendEmails();
			$this->logger->log('Были разосланы электронные письма');

		} catch (Exception $e) {
			$this->logger->log('Во время отправки произошла ошибка');
			throw $e;
		}
	}
}
```

От сигнатурите на класа `NewsletterDistributor` вече е ясно, че регистрирането е част от неговата функционалност. Имате възможност да замените регистратора с друг.

Докато в цялото приложение можем да се задоволим с една единствена инстанция на логера и да я предаваме навсякъде, където се записва нещо, това не е така с класа `Article`. Ще искаме да създадем няколко нейни екземпляра. Как да се справим със зависимостта от базата данни в конструктора? Като пример нека вземем контролер, който трябва да запише статия в базата данни след изпращане на формуляр:

```php
class UserController extends Controller
{
	public function formSubmitted($data)
	{
		$article = new Article(/* ... */);
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Предложено възможно решение: подайте обект от база данни на конструктора на класа `UserController` и използвайте `$article = new Article($this->db)`.

Както и в предишния случай, това е неправилна практика. Базата данни не е зависима от `UserController`, а от `Article`. Освен това, след като конструкторът на класа `Article` бъде променен по някакъв начин (добавен е нов параметър), ще трябва да променим кода на всички места, където се създават екземпляри.

Правилното решение са фабриките.


Правило #2: Използвайте фабрики .[#toc-rule-2-use-factories]
------------------------------------------------------------

Чрез премахване на скритите връзки и предаване на всички данни като аргументи получаваме по-персонализирани и гъвкави класове. Така че все още се нуждаем от нещо за създаване и персонализиране на тези по-гъвкави класове. Ще го наречем фабрика.

Правилото е следното: ако даден клас има зависимости, оставете създаването на техните инстанции на фабриката.

Фабриките са по-разумен заместител на оператора `new` в света на прилагането на зависимости.


Фабрика .[#toc-factory]
-----------------------

Фабриката е клас, който създава и конфигурира обекти. Фабриката, която произвежда `Article`, ще се нарича `ArticleFactory`, а използването ѝ в контролера ще бъде следното:

```php
class UserController extends Controller
{
	public function __construct(
		private ArticleFactory $articleFactory,
	) {
	}

	public function formSubmitted($data)
	{
		// нека фабриката създаде обект
		$article = $this->articleFactory->create();
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Една реализация на фабрика може да изглежда по следния начин:


```php
class ArticleFactory
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

В този момент, когато сигнатурата на конструктора на класа `Article` се промени, единствената част от кода, която трябва да реагира на това, е фабриката `ArticleFactory`. Всеки друг код, работещ с обекти `Article`, като например `UserController`, остава незасегнат.

Вероятно сега се чудите как това ще ви помогне. В крайна сметка обемът на кода е нараснал и се е преместил от контролер в отделен клас. Въпреки това Nette DI има скрит коз в ръкава си. Той разбира концепцията на фабриките и дори може да [напише такава услуга за нас |factory]. Така че вместо класа `ArticleFactory` можем просто да създадем интерфейс:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

Но малко изпреварваме събитията и ще се върнем към това след малко.


Нека обобщим. .[#toc-summary]
-----------------------------

В началото на тази глава обещахме да демонстрираме един прост принцип за разработване на приложения. Въпреки че самият принцип е прост (предоставяйте на класовете данните, от които се нуждаят), това, което следва, изисква по-задълбочено обмисляне. Не се притеснявайте да препрочитате тази глава няколко пъти.

Програмистите, които са се отървали от старите си навици и са започнали да използват последователно прилагането на зависимости, смятат това за повратна точка в професионалния си живот. Тя открива свят на ясни и устойчиви приложения.

Сега ще разгледаме какво представлява [контейнерът за изпълнение на зависимости |container].
