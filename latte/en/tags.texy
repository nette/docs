Latte Tags
**********

.[perex]
Summary and description of all Latte built-in tags (also called macros).

.[table-latte-summary language-latte]
|## Variable and expression printing
| `{$variable}`                  | [prints an escaped variable |#Variable printing]
| `{$variable\|noescape}`        | [prints a variable without escaping |#Variable printing]
| `{expression}`                 | [prints an escaped expression |#Variable printing]
| `{=expression}`                | [prints an escaped expression |#Variable printing]

.[table-latte-summary language-latte]
|## Conditions
| `{if $cond} … {elseif $cond} …`<wbr> `{else} … {/if}`         | [if condition |#Conditions]
| `{$cond ? $value1 : $value2}`                          | [ternary operator |#Conditions]
| `{$cond ? $value}`                                     | [abbreviated "ternary" operator |#Conditions]
| `{$a ?: $default}`                                     | prints `$a`, if is empty prints `$default`
| `{ifset $var} … {elseifset $var} …`<wbr> `{/ifset}`           | [if (isset()) condition |#Conditions]
| `{ifchanged [$vars]} … {/ifchanged}`                          | [test whether the variable has changed |#Conditions]
| `{switch $var} … {case value} …`<wbr> `{default} … {/switch}` | [choice by value |#Conditions]
| `{$obj?->prop}` `{$arr?['item']}`                             | forms of [optional chaining |#Optional Chaining]

.[table-latte-summary language-latte]
|## Loops
| `{foreach $arr as $item} … {/foreach}` | [foreach loop |#Loops]
| `{for expr; expr; expr} … {/for}`      | [for loop |#Loops]
| `{while expr} … {/while}`      | [while loop |#Loops]
| `{continueIf $cond}`           | [conditional jump to the next iteration |#Loops]
| `{skipIf $cond}`               | [conditional jump to the next iteration |#Loops]
| `{breakIf $cond}`              | [conditional loop break |#Loops]
| `{first} … {/first}`           | [prints if first iteration |#Loops]
| `{last} … {/last}`             | [prints if last iteration |#Loops]
| `{sep} … {/sep}`               | [separator |#Loops]

.[table-latte-summary language-latte]
|## Variables
| `{var $foo = value}`           | [variable creation |#Variable declaration]
| `{default $foo = value}`       | [default value when variable isn't declared |#Variable declaration]
| `{capture $var} … {/capture}`  | [captures a section to a variable |#Capturing to variables]

.[table-latte-summary language-latte]
|## Blocks, layouts, template inheritance
| `{block block}`                | [block definition and immediate print out |#blocks]
| `{define block}`               | [block defintion for future use |#blocks]
| `{include block}`              | [inserts a block |#block including]
| `{include block from 'file.latte'}` | [inserts a block from file |#block including]
| `{include 'file.latte'}`       | [includes a template from other file |#File including]
| `{import 'file.latte'}`        | [loads blocks from external template |#template expansion inheritance]
| `{layout 'file.latte'}`        | [specifies a layout file |#template expansion inheritance]
| `{extends 'file.latte'}`       | [alias for `{layout}` |#template expansion inheritance]
| `{embed 'file.latte'}`         | [loads the template and allows you to overwrite the blocks |#embed]
| `{ifset block} … {/ifset}`     | [condition if block is defined |#blocks]

.[table-latte-summary language-latte]
|## Exceptions
| `{try} … {else} … {/try}`      | [catching exceptions |#exceptions]
| `{rollback}`                   | [discards try block |#exceptions]

.[table-latte-summary language-latte]
|## Types
| `{varType type $var}`          | [declares type of variable |#Types]
| `{varPrint [all]}`             | [suggests types of variables	 |#Types]
| `{templateType ClassName}`     | [declares types of variables using class |#Types]
| `{templatePrint}`              | [generates class with properties |#Types]

.[table-latte-summary language-latte]
|## Other
| `{sandbox 'file.latte'}`       | [includes a template in sandbox mode |#File including]
| `{do expression}`              | [evaluates an expression without printing it |#Code evaluation]
| `{* comment text *}`           | a comment (removed from evaluation)
| `{l}` or `{r}`                 | prints { and } characters, respectively
| `{syntax mode}`                | [switches the syntax at runtime |#Syntax switching]
| `{spaceless} … {/spaceless}`   | removes unnecessary whitespace, similar to [strip |filters#strip] filter
| `{contentType $type}`          | [switches the escaping mode and sends HTTP header |#header-contenttype]
| `{debugbreak $cond}`           | [sets breakpoint to the code |#debugbreak]

.[table-latte-summary language-latte]
|## HTML tag attributes
| `n:class`                      |  [smart class attribute |#n:class]
| `n:attr`                       |  [smart HTML attributes |#n:attr]
| `n:ifcontent`                  |  [Omit empty HTML tag |#n:ifcontent]
| `n:tag-if`                     |  Omit HTML tag if condition is false

.[table-latte-summary language-latte]
|## Operators
| `(expand)`                     | [expansion of arrays |#(expand)]


.[table-latte-summary language-latte]
|## Available only in Nette Framework
| Links ||
|---------------------------
| `n:href`                            | [link in `<a>` HTML elements |doc:creating-links#In the Presenter Template]
| `{link Presenter:action}`           | [generates a link |doc:creating-links#In the Presenter Template]
| `{plink Presenter:action}`          | [generates a link to a presenter |doc:creating-links#In the Presenter Template]
|---------------------------
| Controls and forms ||
|---------------------------
| `{control loginForm}`          | [prints a component |doc:components#Rendering]
| `{form formName} … {/form}`    | [prints a form element |doc:form-rendering#latte]
| `{label fieldName} … {/label}` | [prints a form input label |doc:form-rendering#latte]
| `{input fieldName}`            | [prints a form input element |doc:form-rendering#latte]
| `{inputError fieldName}`       | [prints error message for form input element|doc:form-rendering#latte]
| `n:name`                       | [activates an HTML input element |doc:form-rendering#latte]
| `{formPrint}`                  | [generates Latte form blueprint |doc:form-rendering#latte]
| `{formContext formName} … {/formContext}` | [partial form rendering |doc:form-rendering#latte]
|---------------------------
| AJAX ||
|---------------------------
| `{snippet name} … {/snippet}`  | [a template snippet that can be sent by AJAX |doc:ajax#tag-snippet]
| `{snippetArea name}`           | snippets envelope
|---------------------------
| Translations ||
|---------------------------
| `{_}Text{/_}`                  | [translates a text |#localization]
| `{_expression}`                | [translates an expression and prints it with escaping |#localization]
|---------------------------
| Other ||
|---------------------------
| `{dump $variable}`             | [dumps variables to the Tracy Bar |#variable-dumping]
| `{cache $key} … {/cache}`      | [caches a template section |doc:caching#caching-in-templates]


Variable and expression printing `{expression}` .{toc: Variable printing}
-------------------------------------------------------------------------

**With escaping:** (eliminates the [Cross Site Scripting |doc:vulnerability-protection#cross-site-scripting-xss] vulnerability):

```html
Full Name: {$name} {$surname}<br>
Age: {date('Y') - $birth}<br>
```

**Without escaping** by using the `|noescape` modifier (an exclamation mark was used in older Nette versions):

```html
<div class="article">
	{$content|noescape}
	{nl2br($notes)|noescape}
</div>
```

Alternatively you can use notations with equals sign `{=expression}`. This is useful in cases where it may not be obvious that the expression is actually an expression and not a tag or JSON:

```html
Version: {=PHP_VERSION}
Name: {="string"}
```

With technology of [Context-Aware Escaping |safety-first#Context-aware escaping] it is also possible to use PHP variables inside the JavaScript safely:

```html
<script>
var arr = {$arr};
var name = {$name}; // quotes are automatically added!
</script>
```


Conditions `{if $cond} … {/if}`, `{$cond ? … : …}` .{toc: Conditions}
---------------------------------------------------------------------

Conditions behave exactly the same way as their PHP counterparts:

```html
{if $stock}
	In stock
{elseif $onWay}
	On the way
{else}
	Not available
{/if}
```

You can also use `{ifset}` tag which checks variable existence and corresponds to the `if (isset($var))` PHP code. `{ifset}` tag can check for [block |#blocks] existence as well.


Expression in the `{if}` condition can be placed in the closing tag which is useful in situations when we don't know the expression at the time of opening the condition block:

```html
{if}
	<h1>Printing rows from the database</h1>

	{foreach $database->table as $row} ... {/foreach}
{/if $row}
```

Block `{if}` with condition in a closing tag does not support `{elseif}`, tag `{else}` can be used.

```html
availability: {$stock ? 'In stock' : 'Not in stock'}

shortly: {$stock ? 'In stock'}
```

 .{data-version:2.9}
`{ifchanged}` checks if a value has changed from the last iteration within a loop (for, foreach, while).

If given one or more variables, check whether any variable has changed. For example, the following example prints a heading with the first letter each time it changes while listing names:

```html
{foreach ($names|sort) as $name}
    {ifchanged $name[0]} <h2>{$name[0]}</h2> {/ifchanged}

	<p>{$name}</p>
{/foreach}
```

If no argument is specified, it checks its own rendered contents against its previous state and only displays the content if it has changed. So in the previous example, we can omit the argument. We can also use n:attribute:

```html
{foreach ($names|sort) as $name}
    <h2 n:ifchanged>{$name[0]}</h2>

	<p>{$name}</p>
{/foreach}
```

The `{ifchanged}` tag can also take an optional `{else}` clause that will be displayed if the value has not changed.



Repetitive expression in condition could be shortened by `{switch}` and `{case}` tags. Latte **uses strict comparisons** in cases and does not need `break`. It is the exact equivalent for PHP 8 `match` statement.
```html
{switch $transport}
	{case train}
		By train
	{case plane}
		By plane
	{default}
		Differently
{/switch}
```

.{data-version:2.9}
Clause `{case}` can contain multiple values:

```html
{switch $status}
{case $status::NEW}<b>new item</b>
{case $status::SOLD, $status::UNKNOWN}<i>not available</i>
{/switch}
```


.{data-version:2.6}
Optional Chaining (Nullsafe operators)
--------------------------------------

Optional chaining lets us write code where Latte immediately stops evaluating expressions if it encounters null. With the new `?->` operator allowing optional access to variables or array elements. PHP 8 brings the same thing, but you can also use it in PHP 7 in Latte.

When we write code like

```html
{$order?->id}
```

this is a way of saying that when `$order` is not null, `$order->id` will be computed, but when `$order` is null, stop what we’re doing and just return null.

You might find yourself using `?->` to replace a lot of code that performs repetitive nullish checks:

/--comment
Zatím nejde
{$order?->product?[2]->name}
// means ($order !== null) && ($order->product !== null) ? $order->product[2]->name : null
\--

```html
{$user?->address?->street}
// roughly means ($user !== null) && ($user->address !== null) ? $user->address->street : null

{$items[2]?->count}
// roughly means ($items[2] !== null) ? $items[2]->count : null

{$user->getIdentity()?->name}
// roughly means $user->getIdentity() !== null ? $user->getIdentity()->name : null
```

The meaning are "roughly" because in fact the expression is evaluated more sophistically and no step is repeated. For example, `$user->getIdentity()` is called only once, so there cannot be a problem due to an object being returned in the condition and then null.

Optional chaining expressions can be used anywhere, for example, in terms of:

```html
{if $blogPost?->count('*')}
	// means if (isset($blogPost) && $blogPost->count('*'))
	...
{/if}
```


.{data-version:2.9}
Undefined safe operator
-----------------------

The undefined safe operator `??->` is similar to the nullsafe operator `?->`, but does not raise an error if a variable, property, or index does not exist at all.

```html
{$order??->id}
```

this is a way of saying that when `$order` is defined and not null, `$order->id` will be computed, but when `$order` is null or doesn't exist, stop what we’re doing and just return null.

You might find yourself using `?->` to replace a lot of code that performs repetitive nullish checks:
```html
{$user??->address??->street}
// roughly means isset($user) && isset($user->address) ? $user->address->street : null
```


Loops `{foreach}`, `{for}`, `{while}`  .{toc: Loops}
----------------------------------------------------

`foreach`, `for` and `while` loops behave exactly the same as their PHP counterparts.

```html
{foreach $result as $row}
	<span>{$row->title}</span>
{/foreach}
```

```html
{while $row = $result->fetch()}
	<span>{$row->title}</span>
{/while}
```

```html
{for $i = 0; $i < 10; $i++}
	<span>Item #{$i}</span>
{/for}
```

 .{data-version:2.9}
The `foreach` loop can take an optional `{else}` clause whose text is displayed if the given array is empty:

```html
<ul>
    {foreach $people as $person}
        <li>{$person->name}</li>
    {else}
        <li><em>Sorry, no users in this list</em></li>
    {/foreach}
</ul>
```

Inside the `foreach` loop the `$iterator` variable is initialized. It holds important information about the current loop. [Its API |api:Latte\Runtime\CachingIterator] features iteration counter and methods identifying odd, even, first and last iteration:

- `isFirst()` - is this the first iteration?
- `isLast()` - is this the last iteration?
- `getCounter()` - iteration counter, starts from 1
- `getCounter0()` - iteration counter, starts from 0 .{data-version:2.9}
- `isOdd()` - is this iteration odd?
- `isEven()` - is this iteration even?
- `getParent()` - the iterator surrounding the current one .{data-version:2.9}

Object behind the `$iterator` variable has [Nette\SmartObject trait characteristics |doc:smartobject#properties-getters-and-setters], that's why you can write `$iterator->first` instead of `$iterator->isFirst()` and alike. For example:

```html
{foreach $rows as $row}
	{if $iterator->first}<table>{/if}

	<tr id="row-{$iterator->counter}">
		<td>{$row->name}</td>
		<td>{$row->email}</td>
	</tr>

	{if $iterator->last}</table>{/if}
{/foreach}
```

`{if $iterator->first}<table>{/if}` can be replaced with `{first}<table>{/first}`. Similarly, the condition with `last` can be also written as `{last}</table>{/last}`.

```html
{foreach $rows as $row}
	{first}<table>{/first}
		{first 5}<tr>{/first} {* new row each 5 items *}
			<td>{$row->value}</td>
		{last 5}</tr>{/last}
	{last}</table>{/last}
{/foreach}
```

Finally, the equivalent of `{if !$iterator->last} … {/if}` notation (ie. not the last item) is `{sep} … {/sep}` tag. Usually it marks the separator between items – comma, for example. This way the redundant right comma won't print:

```html
{foreach $items as $item} {$item} {sep}, {/sep} {/foreach}
```

There are special tags you can use inside any loop - `{continueIf ?}` and `{breakIf ?}` which jump to the next iteration and end the loop, respectively, if the conditions are met:

```html
{foreach $rows as $row}
	{continueIf $row->parent === null}
	...
{/foreach}
```

 .{data-version:2.9}
Third tag `{skipIf ?}` is very similar to `{continueIf ?}`, but does not increment the counter. So there are no holes in the numbering when you print `$iterator->counter` and skip some items. And most importantly, the {else} clause will be rendered when you skip all items.

```html
<ul>
    {foreach $people as $person}
		{skipIf $person->age < 18}
        <li>{$iterator->counter}. {$person->name}</li>
    {else}
        <li><em>Sorry, no adult users in this list</em></li>
    {/foreach}
</ul>
```

The cycle definition can be merged with the HTML definition as follows: (lists the `div` element for each row)
```html
<div n:foreach="$rows as $row">
	...
</div>
```
Or, use the inner loop to repeat only the inside of the element: (`ul` is displayed once, `li` for each line)
```html
<ul n:inner-foreach="$rows as $row">
	<li>
	...
	</li>
</ul>
```


Variable declaration `{var}` and `{default}` .{toc: Variable declaration}
-------------------------------------------------------------------------

We can declare variables directly in the template by using `{var}` tag:

```html
{var $name = 'John Smith'}
{var $age = 27}

{* Multiple declaration *}
{var $name = 'John Smith', $age = 27}
```

Tag `{default}` does the same thing, except it only sets the value to nonexistent variables:

```html
{default $lang = 'cs'}
```

As of Latte 2.7, you can declare the type of variables:

```html
{var string $name = $article->getTitle()}
```


Capturing to variables `{capture}` .{toc: Capturing to variables}
-----------------------------------------------------------------

By using `{capture}` tag you can capture the output to a variable:

```html
{capture $var}
<ul>
	<li>Hello World</li>
</ul>
{/capture}

<p>Captured: {$var}</p>
```

If you want to capture the output only for a [filter |guide#filters] to be applied it is easier to use the filter on the `{block}` instead:

```html
{block|strip}
<ul>
	<li>Hello World</li>
</ul>
{/block}
```


File including `{include}` and `{sandbox}` .{toc: File including}
-----------------------------------------------------------------

You can include other templates into the current template. The included file has access to the global variables of the current template. Additionally, we can also pass other variables listed in the tag:

```html
{include 'basket.latte'}

// passing arguments
{include 'menu.latte', level: 3, data: $menu}
// passing arguments before Latte 2.9
{include 'menu.latte', level => 3, data => $menu}
```

.[note]
In addition to including files the `{include}` tag is also used to [include blocks |#block including].

The file can also be inserted in safe [sandbox mode |sandbox]. In this case, the included file does have access to only those variables that you explicitly pass:

```html
{sandbox 'untrusted.latte', level: 3, data: $menu}
```


Code evaluation `{do expression}` .{toc: Code evaluation}
---------------------------------------------------------

Evaluates the code written inside but it doesn't print it. (As of Latte 2.8, `{php}` works in older versions).


Header `{contentType}`
----------------------

Switches [Context-Aware Escaping |guide#context-aware-escaping] to the context determined by the parameter so that when printing, the variables are escaped using the rules of the context. For example `{contentType xml}` would switch to the XML escaping mode, meanwhile `{contentType text}` disables escaping completely.


If the parameter is a complete MIME type the correct HTTP header is sent to the browser:

```html
{contentType application/xml}
<?xml version="1.0"?>
<rss version="2.0">
	<channel>
		<title>RSS feed</title>
		<item>
			...
		</item>
	</channel>
</rss>
```


Breakpoint `{debugbreak}` .{toc: debugbreak}
--------------------------------------------

Specifies the place where code execution will break. It is used for debugging purposes for the programmer to inspect the runtime environment and to ensure the code runs as expected. It supports [Xdebug |https://xdebug.org] and [PhpEd |http://www.nusphere.com/products/php_debugger.htm]. Additionally, you can specify a condition when the code should break.

```html
{debugbreak} {* breaks the program *}

{debugbreak $counter == 1}  {* breaks the program if the condition is met *}
```


Syntax switching `{syntax}` .{toc: Syntax switching}
----------------------------------------------------

Tags don't have to be enclosed by simple braces only, we can also use other delimiters, even at runtime. That's the function of `{syntax …}` tag where we can use the following parameters:

- latte: `{...}`
- double: `{{...}}`
- off: completely disables tag evaluation

Note: asp and python syntaxes were removed in 2.4.0.

By using the n:attribute notation we can disable Latte for a JavaScript block only:

```html
<script n:syntax="off">
	var obj = {var: 123}; // this isn't a tag any more
</script>
```

Latte mode can easily be used in JavaScript, you just have to avoid the notation above by writing a space after the opening brace `{ var: 123}` or by using quotes around the identifier `{'var': 123}`.

If you turn off Latte with `{syntax off}` (using tag, not n:attribute), remember that you can not turn it back on using `{syntax}`. No parentheses are processed, so neither the syntax exception termination tag.


n:class
-------

In a typical situation, we could be trying to print an unknown amount of entries from the database as `<li>` elements and mark the last entry and every odd item with corresponding CSS classes for further styling. In case the last line is odd as well, we will require both classes, but we want to avoid empty classes like `<li class=" ">`.

By using `n:class` attribute the problem is rather trivial:

```html
<ul>
	{foreach $data as $item}
	<li n:class="$iterator->odd ? alt, $iterator->last ? last">{$item}</li>
	{/foreach}
</ul>
```

Or do you need to mark the current menu link with 'current' class?

```html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:*') ? current">
```

Amazing, huh?

If you need more accurate URL detection, the `isLinkCurrent()` method can also pass the expected parameter

```html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:action', 'slug') ? current">
```


n:attr
------

`n:attr` attribute is able to generate any HTML attribute similarly to the [n:class |#n:class]. It's mostly suitable in cases when we don't know which attributes we want to print and which not to.

```html
<input type="checkbox" n:attr="value => $value, checked => $checked">
```

Depending on the values of the variables `$value` and `$checked` this will print:

```html
<input type="checkbox">

{* $value = 'Hello' *}
<input type="checkbox" value="Hello">

{* $checked = true *}
<input type="checkbox" value="Hello" checked>
```


n:ifcontent
-----------

`n:ifcontent` removes empty tag

```html
<div>
	<div class="error" n:ifcontent>{$error}</div>
</div>
```

Depending on the values of the variable `$error` this will print:

```html
{* $error = '' *}
<div>
</div>

{* $error = 'Required' *}
<div>
	<div class="error">Required</div>
</div>
```


Blocks `{block}` and `{define}`  .{toc: Blocks}
-----------------------------------------------

Block selects a region of the template, for example to apply a filter (see [example |#Capturing to variables]) or to name it and reinsert it elsewhere in the template.

```html
{block sidebar}
	<h3>Menu</h3>
	...
{/block}
```

We can nest the blocks and of course we can write them in `n:attribute` notation:

```html
{block sidebar}
	<h3>Menu</h3>
	...

	<ul n:block="menulist">
		...
	</ul>
{/block}
```

A block is immediately printed. In case we want to define the block only without printing it we can use `{define}` instead of `{block}`.
In addition, it can receive parameters:

```html
{define card, $name, $collapsed}
	<h3>{$name}</h3>
	...
{/define}

{include card, $person->name, true}
```

As of Latte 2.7, parameter types can also be declared: `{define sidebar, string $name, bool $mode}`.

As for the name of the block it is allowed to specify it by a variable too: `{block $var} … {/block}`.

Every block can see the variables of its surroundings. But alternation of the value inside the block will be visible only in the block (and in nested blocks of course).

The existence of a block can by tested with `{ifset sidebar}` or `{ifset block $name}`.


Block and template inclusion `{include block}` or `{include 'mytemplate.latte'}`  .{toc: Block including}
---------------------------------------------------------------------------------------------------------

Block and template inclusion is performed using `{include}`.

```html
{include sidebar}
```

Analogically for templates:

```html
{include 'sidebar.latte'}
```

It is also possible to pass additional parameters:

```html
{include sidebar, id: 123, name: $value}

// before Latte 2.9:
{include sidebar, id => 123, name => $value}
```

We can include a block by specifying the block name stored in a variable as well (to differentiate from including a file we use the hash sign before the block name):

```html
{include block $blockname}
```

(Or `{include #$blockname}` before Latte 2.9)


Blocks can also include themselves which is suitable when rendering a tree structured menu.

```html
{block menu}
<ul>
	{foreach $menu as $item}
	<li>{if is_array($item)}
		{include menu, menu: $item}
	{else}
		{$item}
	{/if}</li>
	{/foreach}
</ul>
{/block}
```

Instead of `{include menu, ...}` we can write `{include this, ...}` where #this points to the current block.


If you need to add some code to the previously defined block (e.g. add a link to a new stylesheet), you don't need to redeclare and copy the whole block. Use `{include parent}` instead.

```html
{block styles}
	{include parent}
	<link href="http://url.to.styles.css" rel="stylesheet">
{/block}
```

You can also insert only one block from a file. It also works for local blocks.

```html
{include sidebar from 'template.latte'}
```


Template expansion/inheritance `{layout}` .{toc: Template expansion/inheritance}
--------------------------------------------------------------------------------

Template expansion (also called inheritance) is a powerful tool which enables us to create even very complicated layouts effectively and with no code repetition.

Let's say we have two simple pages. The first one:

```html
<html>
	<head>
		<title>First page | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Lorem Gypsum...</p>
		</div>
	</body>
</html>
```

and the second:

```html
<html>
	<head>
		<title>Second page | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Proin eu sem purus. Donec bibendum
			vestibulum...</p>
		</div>
	</body>
</html>
```

The pages vary only by `<title>` and `<div#content>` elements, so we'll create a layout file which contains all common parts and specifies placeholders, which are nothing more but blocks:

File `@layout.latte`:
```html
<html>
	<head>
		<title>{block title}{/block} | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">{block content}{/block}</div>
	</body>
</html>
```

In the actual templates we'll point to the layout by using the `{layout}`, so we can minimize the template content by only defining the two blocks:

```html
{layout '@layout.latte'}

{block title}First page{/block}

{block content}<p>Lorem Gypsum...</p>{/block}
```

The other page will look similar.

Also, there are no limits to the number of levels, there can be as many layers as you want.

 .{data-version:2.9}
Sometimes we need to create a block (via `{block}` or `{define}`) that should not be available in other templates, nor should it rewrite other blocks if their names match. So we mark these blocks as local using keyword `local` before name:

```html
{block local tree}
	This is local block
{/block}
```


Loading a template with overwriting blocks `{embed}`` .{toc: embed}{data-version:v2.9}
--------------------------------------------------------------------------------------

Combination of include + extends. It allows you to insert the contents of another template while overwriting any blocks defined inside it, like when extending a template.

```html
{embed 'object.latte'}
    {* these blocks defined in object.latte we override right here: *}
    {block title}Hello{/block}

	{block description}
        Some content for the description
    {/block}
{/embed}
```

object.latte:

```html
<div class="media">
	<h1 class="media-title">{block title}default content{/block}</h1>

	<div class="media-inner">
		{include description}
	</div>
</div>
```

You can also pass variables, ie `{embed template.latte, id: 10, name: $name}`, like `{include}` does.


Exceptions `{try}`, `{rollback}` .{toc: Exceptions}{data-version:v2.9}
----------------------------------------------------------------------

This tags makes it extremely easy to build robust templates. If an exception occurs while rendering the `{try}` block, the entire block is skipped and rendering will continue after it:

```html
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
{/try}
```

The optional `{else}` clause is rendered on exception:

```html
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
	{else}
	<p>Sorry, unable to load tweets.</p>
{/try}
```

The `{try}` block can also be stopped and skipped manually using `{rollback}`. So you do not have to check all the input data in advance, and during rendering you can decide whether it makes sense to render the object.

```html
{try}
<ul>
    {foreach $people as $person}
 		{skipIf $person->age < 18}
       <li>{$person->name}</li>
    {else}
		{rollback}
    {/foreach}
</ul>
{/try}
```

It is also possible to define own exception handler for i.e logging:

```php
$latte = new Latte\Engine;
$latte->setExceptionHandler(function (\Throwable $e) {
	...
});
```


Typed templates `{varType}`, `{varPrint}`, `{templateType}`, `{templatePrint}` .{toc: Types}{data-version:v2.7}
---------------------------------------------------------------------------------------------------------------

Type system is main thing for the development of robust applications. To knowing what data or object type each variable is allows IDE to correctly autocomplete (see [Typed Templates |type-system]).

How to declare types? Use tags `{varType}` or [`{var}` |#Variable declaration] to define the types of individual variables directly in the template:

```html
{varType Nette\Security\User $user}
{varType string $lang}
```

The `{varPrint}` tag saves you time. If you place it in a template, the list of `{varType}` tags is displayed instead of the normal rendering. Then simply select and copy the code into your template.
The `{varPrint}` lists local variables that are not template parameters. If you want to list all variables, use `{varPrint all}`.

The types of parameters passed to the template can be [declared using class |type-system], which we state at the beginning of the template:

```html
{templateType MyApp\CatalogTemplate}
```

You can also generate this class using the `{templatePrint}` tag. If you place it at the beginning of the template, the code of class is displayed instead of the normal template. Then simply select and copy the code into your project.


Forms `{form}`, `{input}`, `{inputError}`, `{label}` .{toc: Forms}
------------------------------------------------------------------

Tags for rendering [forms |doc:forms] and their elements:

```html
{form myForm}
<table>
<tr n:foreach="$form->controls as $name => $field">
	<th>{label $name /}<th>
	<td>{input $name}</td>
	<td n:ifcontent>{inputError $name}</td>
</tr>
</table>
{/form}
```

The `{form}` or `<form n:name>` tag starts rendering of given form. It also creates a local variable `$form` with a form object. The closing `{/form}` or `</form>` tag renders all undrawn hidden fields before completes the form.

`{input}` tag renders any element including select boxes and textareas. `{label}` is optionally paired tag, ie. `{label}Age{/label}`, in that case the text is translated too. Tag `{inputError}` prints error message for form input.

It's also possible to "breathe life" into a raw HTML input with `n:name` attribute tag, which links it with the form input using its identification:

```html
<form n:name=myForm>
	<p>Name: <input size="50" n:name="name"></p>
	<p>Password: <input size="30" n:name="password"></p>
</form>
```

You can also generate Latte code for a form using the `{formPrint}` tag. If you place it in a template, the code of form is displayed instead of the normal template. Then simply select and copy the code into your project. .{data-version:nette/forms 3.0.5}

If you only need to render the inner content of a form without `<form>` & `</form>` HTML tags, for example, in an AJAX request, you can open and close the form with `{formContext formName} … {/formContext}`. It works similarly to `{form}` in a logical sense, here it allows you to use other tags to draw form elements, but at the same time it doesn't draw anything. .{data-version:nette/forms 3.0.6}


Localization `{_expression}` .{toc: Localization}
-------------------------------------------------

Tag which helps with automated translating in templates. For proper functionality a translator has to be set, see [localization |doc:translations#template-translation]:

```php
$latte->addFilter('translate', new MyTranslator);
```

At this point every expression written in this tag will be automatically translated:

```html
{_$variable}
```

You can also use an alternative pair notation for chunks of text within a template:

```html
{_}Text to be translated{/_}
```


Variable dumping `{dump}` .{toc: Variable dumping}
--------------------------------------------------

Requires [Tracy|tracy:].

```html
{dump $name} {* inspects the $name variable *}

{dump}       {* inspects all the defined variables *}
```


Array expansion operator `(expand)` .{toc: (expand)}
----------------------------------------------------

The `(expand)` operator allows you to use an array where multiple arguments are expected. This is the equivalent of the [`...` operator from PHP |https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list.new], but retaining the keys.

It can be used, for example, to pass arguments into blocks or included templates if we have them in the array.


```html
{include 'foobar.latte' (expand) $args}          {* arguments for include *}
```

{{composer: latte/latte}}
