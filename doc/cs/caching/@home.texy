Cache
*****

<div class=perex>

Cache `[keÅ¡]` zrychlÃ­ vaÅ¡i aplikaci tÃ­m, Å¾e jednou nÃ¡roÄnÄ› zÃ­skanÃ¡ data uloÅ¾Ã­ pro pÅ™Ã­Å¡tÃ­ pouÅ¾itÃ­. UkÃ¡Å¾eme si:

- jak pouÅ¾Ã­vat cache
- jak zmÄ›nit ÃºloÅ¾iÅ¡tÄ›
- jak sprÃ¡vnÄ› cache invalidovat

</div>

PouÅ¾Ã­vÃ¡nÃ­ cache je v Nette velmi snadnÃ©, pÅ™itom pokrÃ½vÃ¡ i velmi pokroÄilÃ© potÅ™eby. Je navrÅ¾eno pro vÃ½kon a 100% odolnost. V zÃ¡kladu najdete adaptÃ©ry pro nejbÄ›Å¾nÄ›jÅ¡Ã­ backendovÃ© ÃºloÅ¾iÅ¡tÄ›. UmoÅ¾Åˆuje invalidaci zaloÅ¾enou na znaÄkÃ¡ch, Äasovou expiraci, mÃ¡ ochranu proti cache stampede atd.


Instalace
=========

Knihovnu stáhnete a nainstalujete pomocÃ­ nÃ¡stroje [Composer|/best-practices/composer]:

```shell
composer require nette/caching
```


ZÃ¡kladnÃ­ pouÅ¾itÃ­
================

StÅ™edobodem prÃ¡ce s cache neboli mezipamÄ›tÃ­ pÅ™edstavuje objekt [api:Nette\Caching\Cache]. VytvoÅ™Ã­me si jeho instanci a jako parametr pÅ™edÃ¡me konstruktoru tzv. ÃºloÅ¾iÅ¡tÄ›. CoÅ¾ je objekt reprezentujÃ­cÃ­ mÃ­sto, kam se budou data fyzicky uklÃ¡dat (databÃ¡ze, Memcached, soubory na disku, ...). K ÃºloÅ¾iÅ¡ti se dostaneme tak, Å¾e si jej nechÃ¡te pÅ™edat pomocÃ­ [dependency injection |/dependency-injection/passing-dependencies] s typem `Nette\Caching\Storage`. VÅ¡e podstatnÃ© se dozvÃ­te v [ÄÃ¡sti ÃšloÅ¾iÅ¡tÄ›|#ÃšloÅ¾iÅ¡tÄ›].

Pro nÃ¡sledujÃ­cÃ­ ukÃ¡zky pÅ™edpoklÃ¡dejme, Å¾e mÃ¡me vytvoÅ™enÃ½ alias `Cache` a v promÄ›nnÃ© `$storage` ÃºloÅ¾iÅ¡tÄ›.

```php
use Nette\Caching\Cache;

$storage = /* ... */; // instance of Nette\Caching\Storage
```

Cache je vlastnÄ› *keyâ€“value store*, tedy data Äteme a zapisujeme pod klÃ­Äi stejnÄ› jako u asociativnÃ­ch polÃ­. Aplikace se sklÃ¡dajÃ­ z Å™ady nezÃ¡vislÃ½ch ÄÃ¡stÃ­ a pokud vÅ¡echny budou pouÅ¾Ã­vat jedno ÃºloÅ¾iÅ¡tÄ› (pÅ™edstavte si jeden adresÃ¡Å™ na disku), dÅ™Ã­ve nebo pozdÄ›ji by doÅ¡lo ke kolizi klÃ­ÄÅ¯. Nette Framework problÃ©m Å™eÅ¡Ã­ tak, Å¾e celÃ½ prostor rozdÄ›luje na jmennÃ© prostory (podadresÃ¡Å™e). KaÅ¾dÃ¡ ÄÃ¡st programu pak pouÅ¾Ã­vÃ¡ svÅ¯j prostor s unikÃ¡tnÃ­m nÃ¡zvem a k Å¾Ã¡dnÃ© kolizi jiÅ¾ dojÃ­t nemÅ¯Å¾e.

NÃ¡zev prostoru uvedeme jako druhÃ½ parametr konstruktoru tÅ™Ã­dy Cache:

```php
$cache = new Cache($storage, 'Full Html Pages');
```

NynÃ­ mÅ¯Å¾eme pomocÃ­ objektu `$cache` z mezipamÄ›ti ÄÃ­st a zapisovat do nÃ­. K obojÃ­mu slouÅ¾Ã­ metoda `load()`. PrvnÃ­m argumentem je klÃ­Ä a druhÃ½m PHP callback, kterÃ½ se zavolÃ¡, kdyÅ¾ klÃ­Ä nenÃ­ nalezen v cache. Callback hodnotu vygeneruje, vrÃ¡tÃ­ a ta se uloÅ¾Ã­ do cache:

```php
$value = $cache->load($key, function () use ($key) {
	$computedValue = /* ... */; // nÃ¡roÄnÃ½ vÃ½poÄet
	return $computedValue;
});
```

Pokud druhÃ½ parametr neuvedeme `$value = $cache->load($key)`, vrÃ¡tÃ­ se `null`, pokud poloÅ¾ka v cache nenÃ­.

.[tip]
Prima je, Å¾e do cache lze uklÃ¡dat jakÃ©koliv serializovatelnÃ© struktury, nemusÃ­ to bÃ½t jen Å™etÄ›zce. A totÃ©Å¾ platÃ­ dokonce i pro klÃ­Äe.

PoloÅ¾ku z mezipamÄ›ti vymaÅ¾eme metodou `remove()`:

```php
$cache->remove($key);
```

UloÅ¾it poloÅ¾ku do mezipamÄ›ti lze takÃ© metodou `$cache->save($key, $value, array $dependencies = [])`. PreferovanÃ¡ je nicmÃ©nÄ› vÃ½Å¡e uvedenÃ½ zpÅ¯sob pomocÃ­ `load()`.


Memoizace
=========

Memoizace znamenÃ¡ cachovÃ¡nÃ­ vÃ½sledku volÃ¡nÃ­ funkce nebo metody, abyste jej mohli pouÅ¾Ã­t pÅ™Ã­Å¡tÄ› bez vypoÄÃ­tÃ¡vÃ¡nÃ­ stejnÃ© vÄ›ci znovu a znovu.

MemoizovanÄ› lze volat metody a funkce pomocÃ­ `call(callable $callback, ...$args)`:

```php
$result = $cache->call('gethostbyaddr', $ip);
```

Funkce `gethostbyaddr()` se tak zavolÃ¡ pro kaÅ¾dÃ½ parametr `$ip` jen jednou a pÅ™Ã­Å¡tÄ› uÅ¾ se vrÃ¡tÃ­ hodnota z cache.

TakÃ© je moÅ¾nÃ© vytvoÅ™it si memoizovanÃ½ obal nad metodou nebo funkcÃ­, kterÃ½ lze volat aÅ¾ pozdÄ›ji:

```php
function factorial($num)
{
	return /* ... */;
}

$memoizedFactorial = $cache->wrap('factorial');

$result = $memoizedFactorial(5); // poprvÃ© vypoÄÃ­tÃ¡
$result = $memoizedFactorial(5); // podruhÃ© z cache
```


Expirace & invalidace
=====================

S uklÃ¡dÃ¡nÃ­m do cache je potÅ™eba Å™eÅ¡it otÃ¡zku, kdy se dÅ™Ã­ve uloÅ¾enÃ¡ data stanou neplatnÃ¡. Nette Framework nabÃ­zÃ­ mechanismus, jak omezit platnost dat nebo je Å™Ã­zenÄ› mazat (v terminologii frameworku â€invalidovatâ€œ).

Platnost dat se nastavuje v okamÅ¾iku uklÃ¡dÃ¡nÃ­ a to pomocÃ­ tÅ™etÃ­ho parametru metody `save()`, napÅ™.:

```php
$cache->save($key, $value, [
	$cache::EXPIRE => '20 minutes',
]);
```

Nebo pomocÃ­ parametru `$dependencies` pÅ™edÃ¡vanÃ©ho referencÃ­ do callbacku metody `load()`, napÅ™.:

```php
$value = $cache->load($key, function (&$dependencies) {
	$dependencies[Cache::EXPIRE] = '20 minutes';
	return /* ... */;
});
```

V dalÅ¡Ã­ch ukÃ¡zkÃ¡ch budeme pÅ™edpoklÃ¡dat druhou variantu a tedy existenci promÄ›nnÃ© `$dependencies`.


Expirace
--------

NejjednoduÅ¡Å¡Ã­ exirace pÅ™edstavuje ÄasovÃ½ limit. Takto uloÅ¾Ã­me do cache data s platnostÃ­ 20 minut:

```php
// akceptuje i poÄet sekund nebo UNIX timestamp
$dependencies[Cache::EXPIRE] = '20 minutes';
```

Pokud bychom chtÄ›li prodlouÅ¾it dobu platnosti s kaÅ¾dÃ½m ÄtenÃ­m, lze toho docÃ­lit nÃ¡sledovnÄ›, ale pozor, reÅ¾ie cache tÃ­m vzroste:

```php
$dependencies[Cache::SLIDING] = true;
```

Å ikovnÃ¡ je moÅ¾nost nechat data vyexpirovat v okamÅ¾iku, kdy se zmÄ›nÃ­ soubor Äi nÄ›kterÃ½ z vÃ­ce souborÅ¯. Toho lze vyuÅ¾Ã­t tÅ™eba pÅ™i uklÃ¡dÃ¡nÃ­ dat vzniklÃ½ch zpracovÃ¡nÃ­m tÄ›chto souborÅ¯ do cache. PouÅ¾Ã­vejte absolutnÃ­ cesty.

```php
$dependencies[Cache::FILES] = '/path/to/data.yaml';
// nebo
$dependencies[Cache::FILES] = ['/path/to/data1.yaml', '/path/to/data2.yaml'];
```

MÅ¯Å¾eme nechat poloÅ¾ku v cache vyexpirovat ve chvÃ­li, kdy vyexpiruje jinÃ¡ poloÅ¾ka (Äi nÄ›kterÃ¡ z vÃ­ce jinÃ½ch). CoÅ¾ lze vyuÅ¾Ã­t tehdy, kdyÅ¾ uklÃ¡dÃ¡me do cache tÅ™eba celou HTML strÃ¡nku a pod jinÃ½mi klÃ­Äi jejÃ­ fragmenty. Jakmile se fragment zmÄ›nÃ­, invaliduje se celÃ¡ strÃ¡nka. Pokud fragmenty mÃ¡me uloÅ¾enÃ© pod klÃ­Äi napÅ™. `frag1` a `frag2`, pouÅ¾ijeme:

```php
$dependencies[Cache::ITEMS] = ['frag1', 'frag2'];
```

Expiraci lze Å™Ã­dit i pomocÃ­ vlastnÃ­ch funkcÃ­ nebo statickÃ½ch metod, kterÃ© vÅ¾dy pÅ™i ÄtenÃ­ rozhodnou, zda je poloÅ¾ka jeÅ¡tÄ› platnÃ¡. Takto tÅ™eba mÅ¯Å¾eme nechat poloÅ¾ku vyexpirovat vÅ¾dy, kdyÅ¾ se zmÄ›nÃ­ verze PHP. VytvoÅ™Ã­me funkci, kterÃ¡ porovnÃ¡ aktuÃ¡lnÃ­ verzi s parameterem, a pÅ™i uklÃ¡dÃ¡nÃ­ pÅ™idÃ¡me mezi zÃ¡vislosti pole ve tvaru `[nazev funkce, ...argumenty]`:

```php
function checkPhpVersion($ver): bool
{
	return $ver === PHP_VERSION_ID;
}

$dependencies[Cache::CALLBACKS] = [
	['checkPhpVersion', PHP_VERSION_ID] // expiruj kdyÅ¾ checkPhpVersion(...) === false
];
```

VÅ¡echny kritÃ©ria je samozÅ™ejmÄ› moÅ¾nÃ© kombinovat. Cache pak vyexpiruje, kdyÅ¾ alespoÅˆ jedno kritÃ©rium nenÃ­ splnÄ›no.

```php
$dependencies[Cache::EXPIRE] = '20 minutes';
$dependencies[Cache::FILES] = '/path/to/data.yaml';
```


Invalidace pomocÃ­ tagÅ¯
----------------------

Velmi uÅ¾iteÄnÃ½m invalidaÄnÃ­m nÃ¡strojem jsou tzv. tagy. KaÅ¾dÃ© poloÅ¾ce v cache mÅ¯Å¾eme pÅ™iÅ™adit seznam tagÅ¯, coÅ¾ jsou libovolnÃ© Å™etÄ›zce. MÄ›jme tÅ™eba HTML strÃ¡nku s ÄlÃ¡nkem a komentÃ¡Å™i, kterou budeme cachovat. PÅ™i uklÃ¡dÃ¡nÃ­ specifikujeme tagy:

```php
$dependencies[Cache::TAGS] = ["article/$articleId", "comments/$articleId"];
```

PÅ™esuÅˆme se do administrace. Tady najdeme formulÃ¡Å™ pro editaci ÄlÃ¡nku. SpoleÄnÄ› s uloÅ¾enÃ­m ÄlÃ¡nku do databÃ¡ze zavolÃ¡me pÅ™Ã­kaz `clean()`, kterÃ½ smaÅ¾e z cache poloÅ¾ky dle tagu:

```php
$cache->clean([
	$cache::TAGS => ["article/$articleId"],
]);
```

StejnÄ› tak v mÃ­stÄ› pÅ™idÃ¡nÃ­ novÃ©ho komentÃ¡Å™e (nebo editace komentÃ¡Å™e) neopomeneme invalidovat pÅ™Ã­sluÅ¡nÃ½ tag:

```php
$cache->clean([
	$cache::TAGS => ["comments/$articleId"],
]);
```

ÄŒeho jsme tÃ­m dosÃ¡hli? Å½e se nÃ¡m HTML cache bude invalidovat (mazat), kdykoliv se zmÄ›nÃ­ ÄlÃ¡nek nebo komentÃ¡Å™e. KdyÅ¾ se edituje ÄlÃ¡nek s ID = 10, dojde k vynucenÃ© invalidaci tagu `article/10` a HTML strÃ¡nka, kterÃ¡ uvedenÃ½ tag nese, se z cache smaÅ¾e. TotÃ©Å¾ nastane pÅ™i vloÅ¾enÃ­ novÃ©ho komentÃ¡Å™e pod pÅ™Ã­sluÅ¡nÃ½ ÄlÃ¡nek.

.[note]
Tagy vyÅ¾adujÃ­ tzv. [#Journal].


Invalidace pomocÃ­ priority
--------------------------

JednotlivÃ½m poloÅ¾kÃ¡m v cache mÅ¯Å¾eme nastavit prioritu, pomocÃ­ kterÃ© je bude moÅ¾nÃ© mazat, kdyÅ¾ tÅ™eba cache pÅ™esÃ¡hne urÄitou velikost:

```php
$dependencies[Cache::PRIORITY] = 50;
```

SmaÅ¾eme vÅ¡echny poloÅ¾ky s prioritou rovnou nebo menÅ¡Ã­ neÅ¾ 100:

```php
$cache->clean([
	$cache::PRIORITY => 100,
]);
```

.[note]
Priority vyÅ¾adujÃ­ tzv. [#Journal].


SmazÃ¡nÃ­ cache
-------------

Parametr `Cache::ALL` smaÅ¾e vÅ¡e:

```php
$cache->clean([
	$cache::ALL => true,
]);
```


HromadnÃ© ÄtenÃ­
==============

Pro hromadnÃ© ÄtenÃ­ a zÃ¡pisy do cache slouÅ¾Ã­ metoda `bulkLoad()`, kterÃ© pÅ™edÃ¡me pole klÃ­ÄÅ¯ a zÃ­skÃ¡me pole hodnot:

```php
$values = $cache->bulkLoad($keys);
```

Metoda `bulkLoad()` funguje podobnÄ› jako `load()` i s druhÃ½m parameterm callbackem, kterÃ©mu se pÅ™edÃ¡vÃ¡ klÃ­Ä generovanÃ© poloÅ¾ky:

```php
$values = $cache->bulkLoad($keys, function ($key, &$dependencies) {
	$computedValue = /* ... */; // nÃ¡roÄnÃ½ vÃ½poÄet
	return $computedValue;
});
```


CachovÃ¡nÃ­ vÃ½stupu
=================

Velmi elegantnÄ› lze zachytÃ¡vat a cachovat vÃ½stup:

```php
if ($capture = $cache->capture($key)) {

	echo ... // vypisujeme data

	$capture->end(); // uloÅ¾Ã­me vÃ½stup do cache
}
```

V pÅ™Ã­padÄ›, Å¾e vÃ½stup uÅ¾ je v cache uloÅ¾en, tak ho metoda `capture()` vypÃ­Å¡e a vrÃ¡tÃ­ `null`, tedy podmÃ­nka se nevykonÃ¡. V opaÄnÃ©m pÅ™Ã­padÄ› zaÄne vÃ½stup zachytÃ¡vat a vrÃ¡tÃ­ objekt `$capture`, pomocÃ­ nÄ›hoÅ¾ nakonec vypsanÃ¡ data uloÅ¾Ã­me do cache.


CachovÃ¡nÃ­ v Latte
=================

CachovÃ¡nÃ­ v Å¡ablonÃ¡ch [Latte|latte:] je velmi snadnÃ©, staÄÃ­ ÄÃ¡st Å¡ablony obalit znaÄkami `{cache}...{/cache}`. Cache se automaticky invaliduje ve chvÃ­li, kdy se zmÄ›nÃ­ zdrojovÃ¡ Å¡ablona (vÄetnÄ› pÅ™Ã­padnÃ½ch inkludovanÃ½ch Å¡ablon uvnitÅ™ bloku cache). ZnaÄky `{cache}` lze vnoÅ™ovat do sebe a kdyÅ¾ se vnoÅ™enÃ½ blok zneplatnÃ­ (napÅ™Ã­klad tagem), zneplatnÃ­ se i blok nadÅ™azenÃ½.

Ve znaÄce je moÅ¾nÃ© uvÃ©st klÃ­Äe, na kterÃ© se bude cache vÃ¡zat (zde promÄ›nnÃ¡ `$id`) a nastavit expiraci a [tagy pro zneplatnÄ›nÃ­ |#Invalidace pomocÃ­ tagÅ¯]

```html
{cache $id, expire => '20 minutes', tags => [tag1, tag2]}
	...
{/cache}
```

VÅ¡echny poloÅ¾ky jsou volitelnÃ©, takÅ¾e nemusÃ­me uvÃ¡dÄ›t ani expiraci, ani tagy, nakonec ani klÃ­Äe.

PouÅ¾itÃ­ cache lze takÃ© podmÃ­nit pomocÃ­ `if` - obsah se pak bude cachovat pouze bude-li splnÄ›na podmÃ­nka:

```html
{cache $id, if => !$form->isSubmitted()}
	{$form}
{/cache}
```


ÃšloÅ¾iÅ¡tÄ›
========

ÃšloÅ¾iÅ¡tÄ› je objekt reprezentujÃ­cÃ­ mÃ­sto, kam se data fyzicky uklÃ¡dajÃ­. MÅ¯Å¾eme pouÅ¾Ã­t databÃ¡zi, server Memcached, nebo nejdostupnÄ›jÅ¡Ã­ ÃºloÅ¾iÅ¡tÄ›, coÅ¾ jsou soubory na disku.

|-----------------
| ÃšloÅ¾iÅ¡tÄ› | Popis
|-----------------
| [#FileStorage] | vÃ½chozÃ­ ÃºloÅ¾iÅ¡tÄ› s uklÃ¡dÃ¡nÃ­m do souborÅ¯ na disk
| [#MemcachedStorage] | vyuÅ¾Ã­vÃ¡ `Memcached` server
| [#MemoryStorage] | data jsou doÄasnÄ› v pamÄ›ti
| [#SQLiteStorage] | data se uklÃ¡dajÃ­ do SQLite databÃ¡ze
| [#DevNullStorage] | data se neuklÃ¡dajÃ­, vhodnÃ© pro testovÃ¡nÃ­

K objektu ÃºloÅ¾iÅ¡tÄ› se dostanete tak, Å¾e si jej nechÃ¡te pÅ™edat pomocÃ­ [dependency injection |/dependency-injection/passing-dependencies] s typem `Nette\Caching\Storage`. Jako vÃ½chozÃ­ ÃºloÅ¾iÅ¡tÄ› poskytuje Nette objekt FileStorage uklÃ¡dajÃ­cÃ­ data do podsloÅ¾ky `cache` v adresÃ¡Å™i pro [doÄasnÃ© soubory|/application/bootstrap#doÄasnÃ© soubory].

ZmÄ›nit ÃºloÅ¾iÅ¡tÄ› mÅ¯Å¾ete v konfiguraci:

```neon
services:
	cache.storage: Nette\Caching\Storages\DevNullStorage
```


FileStorage
-----------

Zapisuje cache do souborÅ¯ na disku. ÃšloÅ¾iÅ¡tÄ› `Nette\Caching\Storages\FileStorage` je velmi dobÅ™e optimalizovanÃ© pro vÃ½kon a pÅ™edevÅ¡Ã­m zajiÅ¡Å¥uje plnou atomicitu operacÃ­. Co to znamenÃ¡? Å½e pÅ™i pouÅ¾itÃ­ cache se nemÅ¯Å¾e stÃ¡t, Å¾e pÅ™eÄteme soubor, kterÃ½ jeÅ¡tÄ› nenÃ­ jinÃ½m vlÃ¡knem kompletnÄ› zapsanÃ½, nebo Å¾e by vÃ¡m jej nÄ›kdo "pod rukama" smazal. PouÅ¾itÃ­ cache je tedy zcela bezpeÄnÃ©.

Toto ÃºloÅ¾iÅ¡tÄ› mÃ¡ takÃ© vestavÄ›nou dÅ¯leÅ¾itou funkci, kterÃ¡ brÃ¡nÃ­ pÅ™ed extrÃ©mnÃ­m nÃ¡rÅ¯stem vyuÅ¾itÃ­ CPU ve chvÃ­li, kdy se cache smaÅ¾e nebo jeÅ¡tÄ› nenÃ­ zahÅ™Ã¡tÃ¡ (tj. vytvoÅ™enÃ¡). JednÃ¡ se o prevenci pÅ™ed "cache stampede":https://en.wikipedia.org/wiki/Cache_stampede.
StÃ¡vÃ¡ se, Å¾e v jednu chvÃ­li se sejde vÄ›tÅ¡Ã­ poÄet soubÄ›Å¾nÃ½ch poÅ¾adavkÅ¯, kterÃ© chtÄ›jÃ­ z cache stejnou vÄ›c (napÅ™. vÃ½sledek drahÃ©ho SQL dotazu) a protoÅ¾e v mezipamÄ›ti nenÃ­, zaÄnou vÅ¡echny procesy vykonÃ¡vat stejnÃ½ SQL dotaz.
VytÃ­Å¾enÃ­ se tak nÃ¡sobÃ­ a mÅ¯Å¾e se dokonce stÃ¡t, Å¾e Å¾Ã¡dnÃ© vlÃ¡kno nestihne odpovÄ›dÄ›t v ÄasovÃ©m limitu, cache se nevytvoÅ™Ã­ a aplikace zkolabuje.
NaÅ¡tÄ›stÃ­ cache v Nette funguje tak, Å¾e pÅ™i vÃ­ce soubÄ›Å¾nÃ½ch poÅ¾adavcÃ­ch na jednu poloÅ¾ku ji generuje pouze prvnÃ­ vlÃ¡kno, ostatnÃ­ ÄekajÃ­ a nÃ¡slednÄ› vyuÅ¾Ã­jÃ­ vygenerovanÃ½ vÃ½sledek.

PÅ™Ã­klad vytvoÅ™enÃ­ FileStorage:

```php
// ÃºloÅ¾iÅ¡tÄ›m bude adresÃ¡Å™ '/path/to/temp' na disku
$storage = new Nette\Caching\Storages\FileStorage('/path/to/temp');
```


MemcachedStorage
----------------

Server [Memcached|https://memcached.org] je vysoce vÃ½konnÃ½ systÃ©m uklÃ¡dÃ¡nÃ­ do distribuovanÃ© pamÄ›ti, jehoÅ¾ adaptÃ©r je `Nette\Caching\Storages\MemcachedStorage`. V konfiguraci uvedeme IP adresu a port, pokud se liÅ¡Ã­ od standardnÃ­ho 11211.

.[caution]
VyÅ¾aduje PHP rozÅ¡Ã­Å™enÃ­ `memcached`.

```neon
services:
	cache.storage: Nette\Caching\Storages\MemcachedStorage('10.0.0.5')
```


MemoryStorage
-------------

`Nette\Caching\Storages\MemoryStorage` je ÃºloÅ¾iÅ¡tÄ›, kterÃ¡ data uklÃ¡dÃ¡ do PHP pole, a tedy se s ukonÄenÃ­m poÅ¾adavku ztratÃ­.


SQLiteStorage
-------------

DatabÃ¡ze SQLite a adaptÃ©r `Nette\Caching\Storages\SQLiteStorage` nabÃ­zÃ­ zpÅ¯sob, jak uklÃ¡dat cache do jedinÃ©ho souboru na disku. V konfiguraci uvedeme cestu k tomuto souboru.

.[caution]
VyÅ¾aduje PHP rozÅ¡Ã­Å™enÃ­ `pdo` a `pdo_sqlite`.

```neon
services:
	cache.storage: Nette\Caching\Storages\SQLiteStorage('%tempDir%/cache.db')
```


DevNullStorage
--------------

SpeciÃ¡lnÃ­ implementacÃ­ ÃºloÅ¾iÅ¡tÄ› je `Nette\Caching\Storages\DevNullStorage`, kterÃ© ve skuteÄnosti data neuklÃ¡dÃ¡ vÅ¯bec. Je tak vhodnÃ© pro testovÃ¡nÃ­, kdyÅ¾ chceme eliminovat vliv cache.


PouÅ¾itÃ­ cache v kÃ³du
====================

PÅ™i pouÅ¾Ã­vÃ¡nÃ­ cache v kÃ³du mÃ¡me dva zpÅ¯soby, jak na to. PrvnÃ­ z nich je ten, Å¾e si nechÃ¡me pÅ™edat pomocÃ­ [dependency injection |/dependency-injection/passing-dependencies] ÃºloÅ¾iÅ¡te a vytvoÅ™Ã­me objekt `Cache`:

```php
use Nette;

class ClassOne
{
	/** @var Nette\Caching\Cache */
	private $cache;

	public function __construct(Nette\Caching\Storage $storage)
	{
		$this->cache = new Nette\Caching\Cache($storage, 'my-namespace');
	}
}
```

DruhÃ¡ moÅ¾nost je, Å¾e si nechÃ¡me rovnou pÅ™edat objekt `Cache`:

```php
class ClassTwo
{
	/** @var Nette\Caching\Cache */
	private $cache;

	public function __construct(Nette\Caching\Cache $cache)
	{
		$this->cache = $cache;
	}
}
```

Objekt `Cache` se potom vytvoÅ™Ã­ pÅ™Ã­mo v konfiguraci tÃ­mto zpÅ¯sobem:

```neon
services:
	- ClassTwo( Nette\Caching\Cache(namespace: 'my-namespace') )
```


Journal
=======

Nette si tagy a priority uklÃ¡dÃ¡ do tzv. journalu. StandardnÄ› se k tomu pouÅ¾Ã­vÃ¡ SQLite a soubor `journal.s3db` a **vyÅ¾adujÃ­ se PHP rozÅ¡Ã­Å™enÃ­ `pdo` a `pdo_sqlite`.**

ZmÄ›nit journal mÅ¯Å¾ete v konfiguraci:

```neon
services:
	cache.journal: MyJournal
```


{{composer: nette/caching}}
{{leftbar: /@menu-topics}}
