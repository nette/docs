DI: tvorba rozšíření
********************

`Configurator` sám však žádný kód negeneruje, o to se stará [api:Nette\Config\Compiler] a [api:Nette\DI\ContainerBuilder]. Nejdříve se spustí [api:Nette\Config\Loader], který načte konfigurační soubory a předá je `Compiler`u. Do `Compiler`u si můžeme připojit vlastní rozšíření.

```php
$configurator->onCompile[] = function ($configurator, $compiler) {
	$compiler->addExtension('blog', new MyBlogExtension);
};
```

Každé rozšíření `Compiler`u musí dědit od [api:Nette\Config\CompilerExtension] a může implementovat tři různé metody, které jsou postupně volány, během sestavování `Container`u.


CompilerExtension::loadConfiguration() .[method]
================================================

Metoda je nad všemi rozšířeními volána jako první a je určena k načtení dodatečných konfiguračních souborů, vytvoření dalších služeb pomocí [api:Nette\DI\ContainerBuilder] a hlavně zpracování konfigurace aplikace.

V configu je možné uvést sekci, která se jmenuje stejně jako naše rozšíření. Pokud tedy budeme uvažovat předchozí příklad, mohlo by v konfigu přibýt například toto

```neon
blog: # stejné jméno jako má extension
	postsPerPage: 10
	comments: FALSE
```

Nastavení si lze přečíst zavoláním metody [getConfig() |api:Nette\Config\CompilerExtension::getConfig()] v rozšíření.

```php
class MyBlogExtension extends Nette\Config\CompilerExtension
{
	public function loadConfiguration()
	{
		$config = $this->getConfig();
		// array(2) [ 'postsPerPage' => 10, 'comments' => FALSE ]
```

Protože uznáváme princip "konvence před konfigurací":https://en.wikipedia.org/wiki/Convention_over_configuration, nastavíme si výchozí hodnoty, aby aplikace fungovala i bez toho, že budeme něco nastavovat. V prvním argumentu metody `getConfig()` můžeme poskytnout výchozí hodnoty, do kterých bude sloučena příslušná sekce konfiguračního souboru.

```php
class MyBlogExtension extends Nette\Config\CompilerExtension
{
	public $defaults = array(
		'postsPerPage' => 5,
		'comments' => TRUE
	);

	public function loadConfiguration()
	{
		$config = $this->getConfig($this->defaults);
```

Nastavení máme v poli `$config`, takže je aplikujeme na služby, které vytvoříme. Použijeme k tomu `ContainerBuilder`, který umožňuje to stejné, jako zápis služby v konfiguračním souboru.

```php
$builder = $this->getContainerBuilder();
```

Vytvoříme si službu `blog.articles`, která bude reprezentovat model pro práci s články a jejich načítání.

.[tip]
Konvence je, prefixovat služby v rozšíření jeho názvem, aby nevznikaly konflikty. Pomůže nám s tím metoda `prefix()`.

```php
$builder->addDefinition($this->prefix('articles'))
	->setClass('MyBlog\ArticlesModel', array('@connection'));
```

Dále si vytvoříme továrnu na komponentu, které předáme `blog.articles` a nastavíme počet zobrazených příspěvků na stránku. Jak používat továrny na komponenty si ukážeme později.

```php
$builder->addDefinition($this->prefix('articlesList'))
	->setClass('MyBlog\Components\ArticlesList', array($this->prefix('@articles')))
	->addSetup('setPostsPerPage', $config['postsPerPage'])
	->setShared(FALSE)->setAutowired(FALSE); // ze služby se stane továrna
```

Budeme potřebovat i modelovou třídu pro komentáře `blog.comments`, které předáme připojení k databázi a `blog.articles` a pokud jsou vyplé komentáře, tak je zakážeme.

```php
$comments = $builder->addDefinition($this->prefix('comments'))
	->setClass('MyBlog\CommentsModel', array('@connection', $this->prefix('@articles')));

if (!$config['comments']) { // volitelné vypnutí komentářů
	$comments->addSetup('disableComments');
}
```

Komentáře se musí také někde zobrazovat a psát, takže přidáme ještě jednu továrnu na komponentu `blog.commentsControl`, která nám bude komentáře zobrazovat a dovolí nám psát nové, pokud nebudou vyplé.

```php
$builder->addDefinition($this->prefix('commentsControl'))
	->setClass('MyBlog\Components\CommentsControl', array($this->prefix('@comments')))
	->setShared(FALSE)->setAutowired(FALSE); // ze služby se stane továrna
```

.[note]
Toto rozdělení na modely a komponenty je pouze ilustrativní.


Načítání dodatečné konfigurace
------------------------------

Pokud se nám nelíbí vytvářet všechny služby v rozšíření, můžeme jeho část přesunout do samostatného konfiguračního souboru.

```neon
services:
	blog.articles:
		class: MyBlog\ArticlesModel(@connection)

	blog.comments:
		class: MyBlog\CommentsModel(@connection, @blog.articles)

factories:
	blog.articlesList:
		class: MyBlog\Components\ArticlesList(@blog.articles)

	blog.commentsControl:
		class: MyBlog\Components\CommentsControl(@blog.comments)
```

Který načteme a dodatečně služby nastavíme

```php
public function loadConfiguration()
{
	$config = $this->getConfig($this->defaults);
	$builder = $this->getContainerBuilder();

	// načtení konfiguračního souboru pro rozšíření
	$this->compiler->parseServices($builder, $this->loadFromFile(__DIR__ . '/blog.neon'));

	// počet článků na stránku v komponentě
	$builder->getDefinition($this->prefix('articlesList'))
		->addSetup('setPostsPerPage', $config['postsPerPage']);

	// volitelné vypnutí komentářů
	if (!$config['comments']) {
		$builder->getDefinition($this->prefix('comments'))
			->addSetup('disableComments');
	}
}
```

Rozšíření se nám krásně vyčistilo a díky syntaxi Neon, jsou definice služeb mnohem lépe čitelné.


CompilerExtension::beforeCompile() .[method]
============================================

V této fázi sestavování už by neměly přibývat další služby. Můžeme ovšem upravovat existující a doplnit některé potřebné vazby mezi službami, například pomocí tagů.


CompilerExtension::afterCompile(Nette\Utils\PhpGenerator\ClassType $class) .[method]
====================================================================================

V této fázi už je třída `Container`u vygenerována, obsahuje všechny metody, které vytváří služby a je připravena na zápis do cache. Díky api třídy [api:Nette\Utils\PhpGenerator\ClassType] můžeme přidávat vlastní kód do kontejneru a upravovat tak výsledný kód, který se stará o vytvoření služeb.

Samotný Nette Framework například přidává metodu `initialize`, ve které zpracovává [některá uživatelská nastavení |api:Nette\Config\Extensions\NetteExtension::afterCompile()]. Tuto metodu pak sám vždy volá po instanciování kontejneru.

Ukážeme si kousek kódu, kde Nette Framework doplňuje do metody `initialize` startování session a automatické spouštění služeb, které mají tag `run`.

```php
public function afterCompile(Nette\Utils\PhpGenerator\ClassType $class)
{
	$container = $this->getContainerBuilder();
	$config = $this->getConfig($this->defaults);

	// metoda initialize
	$initialize = $class->methods['initialize'];

	// automatické startování session
	if ($config['session']['autoStart']) {
		$initialize->addBody('$this->session->start();');
	}

	// služby s tagem run musejí být spouštěny po vytvoření kontejneru
	foreach ($container->findByTag('run') as $name => $foo) {
		$initialize->addBody('$this->getService(?);', array($name));
	}
}
```

Metody `beforeCompile()` a `afterCompile()` se liší pouze v tom, že jedna má přístup ke kódu výsledného `Container`u a druhá ne.
