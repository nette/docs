Stan globalny i singletony
**************************

.[perex]
OstrzeÅ¼enie: PoniÅ¼sze konstrukcje sÄ… oznakÄ… Åºle zaprojektowanego kodu:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` lub `static::$var`

Czy niektÃ³re z tych konstrukcji wystÄ™pujÄ… w Twoim kodzie? W takim razie masz okazjÄ™ do jego ulepszenia. ByÄ‡ moÅ¼e myÅ›lisz, Å¼e sÄ… to powszechne konstrukcje, ktÃ³re widzisz nawet w przykÅ‚adowych rozwiÄ…zaniach rÃ³Å¼nych bibliotek i frameworkÃ³w. JeÅ›li tak jest, to projekt ich kodu nie jest dobry.

Teraz zdecydowanie nie mÃ³wimy o jakiejÅ› akademickiej czystoÅ›ci. Wszystkie te konstrukcje majÄ… jednÄ… wspÃ³lnÄ… cechÄ™: wykorzystujÄ… stan globalny. A ten ma destrukcyjny wpÅ‚yw na jakoÅ›Ä‡ kodu. Klasy kÅ‚amiÄ… o swoich zaleÅ¼noÅ›ciach. Kod staje siÄ™ nieprzewidywalny. MylÄ… programistÃ³w i obniÅ¼ajÄ… ich efektywnoÅ›Ä‡.

W tym rozdziale wyjaÅ›nimy, dlaczego tak jest i jak unikaÄ‡ stanu globalnego.


Globalne powiÄ…zanie
-------------------

W idealnym Å›wiecie obiekt powinien mÃ³c komunikowaÄ‡ siÄ™ tylko z obiektami, ktÃ³re zostaÅ‚y mu [bezpoÅ›rednio przekazane |passing-dependencies]. JeÅ›li utworzÄ™ dwa obiekty `A` i `B` i nigdy nie przekaÅ¼Ä™ referencji miÄ™dzy nimi, to ani `A`, ani `B` nie mogÄ… dostaÄ‡ siÄ™ do drugiego obiektu ani zmieniÄ‡ jego stanu. To jest bardzo poÅ¼Ä…dana wÅ‚aÅ›ciwoÅ›Ä‡ kodu. Jest to podobne do sytuacji, gdy masz bateriÄ™ i Å¼arÃ³wkÄ™; Å¼arÃ³wka nie zaÅ›wieci, dopÃ³ki nie poÅ‚Ä…czysz jej z bateriÄ… drutem.

Ale to nie dotyczy globalnych (statycznych) zmiennych lub singletonÃ³w. Obiekt `A` mÃ³gÅ‚by *bezprzewodowo* dostaÄ‡ siÄ™ do obiektu `C` i zmodyfikowaÄ‡ go bez jakiegokolwiek przekazania referencji, wywoÅ‚ujÄ…c `C::changeSomething()`. JeÅ›li obiekt `B` rÃ³wnieÅ¼ chwyci globalne `C`, to `A` i `B` mogÄ… wzajemnie na siebie wpÅ‚ywaÄ‡ za poÅ›rednictwem `C`.

UÅ¼ycie globalnych zmiennych wprowadza do systemu nowÄ… formÄ™ *bezprzewodowego* powiÄ…zania, ktÃ³ra nie jest widoczna z zewnÄ…trz. Tworzy zasÅ‚onÄ™ dymnÄ… utrudniajÄ…cÄ… zrozumienie i uÅ¼ywanie kodu. Aby programiÅ›ci rzeczywiÅ›cie zrozumieli zaleÅ¼noÅ›ci, muszÄ… przeczytaÄ‡ kaÅ¼dÄ… liniÄ™ kodu ÅºrÃ³dÅ‚owego. Zamiast jedynie zapoznaÄ‡ siÄ™ z interfejsem klas. Jest to ponadto powiÄ…zanie caÅ‚kowicie zbÄ™dne. Stan globalny jest uÅ¼ywany dlatego, Å¼e jest Å‚atwo dostÄ™pny z dowolnego miejsca i pozwala na przykÅ‚ad zapisaÄ‡ do bazy danych za pomocÄ… globalnej (statycznej) metody `DB::insert()`. Ale jak pokaÅ¼emy, korzyÅ›Ä‡, ktÃ³rÄ… to przynosi, jest znikoma, natomiast komplikacje, ktÃ³re powoduje, sÄ… fatalne.

.[note]
Z punktu widzenia zachowania nie ma rÃ³Å¼nicy miÄ™dzy zmiennÄ… globalnÄ… a statycznÄ…. SÄ… rÃ³wnie szkodliwe.


Upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡
------------------------------

"Upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡" - tak sÅ‚ynnie nazwaÅ‚ w 1935 roku Albert Einstein zjawisko w fizyce kwantowej, ktÃ³re przyprawiaÅ‚o go o gÄ™siÄ… skÃ³rkÄ™.
Chodzi o splÄ…tanie kwantowe, ktÃ³rego osobliwoÅ›ciÄ… jest to, Å¼e gdy zmierzysz informacjÄ™ o jednej czÄ…stce, natychmiast wpÅ‚ywasz na drugÄ… czÄ…stkÄ™, nawet jeÅ›li sÄ… oddalone od siebie o miliony lat Å›wietlnych.
Co pozornie narusza podstawowe prawo wszechÅ›wiata, Å¼e nic nie moÅ¼e poruszaÄ‡ siÄ™ szybciej niÅ¼ Å›wiatÅ‚o.

W Å›wiecie oprogramowania moÅ¼emy nazwaÄ‡ "upiornym dziaÅ‚aniem na odlegÅ‚oÅ›Ä‡" sytuacjÄ™, gdy uruchamiamy jakiÅ› proces, o ktÃ³rym sÄ…dzimy, Å¼e jest izolowany (poniewaÅ¼ nie przekazaliÅ›my mu Å¼adnych referencji), ale w odlegÅ‚ych miejscach systemu dochodzi do nieoczekiwanych interakcji i zmian stanu, o ktÃ³rych nie mieliÅ›my pojÄ™cia. MoÅ¼e do tego dojÅ›Ä‡ tylko za poÅ›rednictwem stanu globalnego.

WyobraÅº sobie, Å¼e doÅ‚Ä…czasz do zespoÅ‚u programistÃ³w projektu, ktÃ³ry ma obszernÄ…, dojrzaÅ‚Ä… bazÄ™ kodu. TwÃ³j nowy przeÅ‚oÅ¼ony prosi CiÄ™ o zaimplementowanie nowej funkcji, a Ty jako dobry programista zaczynasz od napisania testu. Ale poniewaÅ¼ jesteÅ› nowy w projekcie, robisz wiele testÃ³w eksploracyjnych typu "co siÄ™ stanie, jeÅ›li wywoÅ‚am tÄ™ metodÄ™". I prÃ³bujesz napisaÄ‡ nastÄ™pujÄ…cy test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // numer Twojej karty
	$cc->charge(100);
}
```

Uruchamiasz kod, moÅ¼e kilka razy, i po jakimÅ› czasie zauwaÅ¼asz na telefonie powiadomienia z banku, Å¼e przy kaÅ¼dym uruchomieniu pobrano 100 dolarÃ³w z Twojej karty pÅ‚atniczej ğŸ¤¦â€â™‚ï¸

Jak, do diabÅ‚a, test mÃ³gÅ‚ spowodowaÄ‡ rzeczywiste pobranie pieniÄ™dzy? Operowanie kartÄ… pÅ‚atniczÄ… nie jest Å‚atwe. Musisz komunikowaÄ‡ siÄ™ z usÅ‚ugÄ… internetowÄ… strony trzeciej, musisz znaÄ‡ adres URL tej usÅ‚ugi, musisz siÄ™ zalogowaÄ‡ i tak dalej.
Å»adna z tych informacji nie jest zawarta w teÅ›cie. Co gorsza, nawet nie wiesz, gdzie te informacje siÄ™ znajdujÄ…, a wiÄ™c ani jak mockowaÄ‡ zewnÄ™trzne zaleÅ¼noÅ›ci, aby kaÅ¼de uruchomienie nie prowadziÅ‚o do ponownego pobrania 100 dolarÃ³w. I skÄ…d jako nowy programista miaÅ‚eÅ› wiedzieÄ‡, Å¼e to, co zamierzasz zrobiÄ‡, doprowadzi do tego, Å¼e bÄ™dziesz o 100 dolarÃ³w biedniejszy?

To jest upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡!

Nie pozostaje Ci nic innego, jak dÅ‚ugo grzebaÄ‡ w mnÃ³stwie kodu ÅºrÃ³dÅ‚owego, pytaÄ‡ starszych i bardziej doÅ›wiadczonych kolegÃ³w, zanim zrozumiesz, jak dziaÅ‚ajÄ… powiÄ…zania w projekcie.
Jest to spowodowane tym, Å¼e patrzÄ…c na interfejs klasy `CreditCard`, nie moÅ¼na zidentyfikowaÄ‡ stanu globalnego, ktÃ³ry naleÅ¼y zainicjowaÄ‡. Nawet spojrzenie na kod ÅºrÃ³dÅ‚owy klasy nie powie Ci, ktÃ³rÄ… metodÄ™ inicjalizacyjnÄ… masz wywoÅ‚aÄ‡. W najlepszym przypadku moÅ¼esz znaleÅºÄ‡ globalnÄ… zmiennÄ…, do ktÃ³rej uzyskuje siÄ™ dostÄ™p, i na jej podstawie prÃ³bowaÄ‡ odgadnÄ…Ä‡, jak jÄ… zainicjowaÄ‡.

Klasy w takim projekcie sÄ… patologicznymi kÅ‚amcami. Karta pÅ‚atnicza udaje, Å¼e wystarczy jÄ… utworzyÄ‡ i wywoÅ‚aÄ‡ metodÄ™ `charge()`. W ukryciu jednak wspÃ³Å‚pracuje z innÄ… klasÄ… `PaymentGateway`, ktÃ³ra reprezentuje bramkÄ™ pÅ‚atniczÄ…. Jej interfejs rÃ³wnieÅ¼ mÃ³wi, Å¼e moÅ¼na jÄ… zainicjowaÄ‡ samodzielnie, ale w rzeczywistoÅ›ci pobiera dane uwierzytelniajÄ…ce z jakiegoÅ› pliku konfiguracyjnego i tak dalej.
Programistom, ktÃ³rzy napisali ten kod, jest jasne, Å¼e `CreditCard` potrzebuje `PaymentGateway`. Napisali kod w ten sposÃ³b. Ale dla kaÅ¼dego, kto jest nowy w projekcie, jest to kompletna zagadka i utrudnia naukÄ™.

Jak naprawiÄ‡ sytuacjÄ™? Åatwo. **Niech API deklaruje zaleÅ¼noÅ›ci.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

ZauwaÅ¼, jak nagle powiÄ…zania wewnÄ…trz kodu stajÄ… siÄ™ oczywiste. DziÄ™ki temu, Å¼e metoda `charge()` deklaruje, Å¼e potrzebuje `PaymentGateway`, nie musisz nikogo pytaÄ‡, jak kod jest powiÄ…zany. Wiesz, Å¼e musisz utworzyÄ‡ jej instancjÄ™, a gdy sprÃ³bujesz to zrobiÄ‡, natkniesz siÄ™ na to, Å¼e musisz podaÄ‡ parametry dostÄ™pu. Bez nich kod nie daÅ‚by siÄ™ nawet uruchomiÄ‡.

A co najwaÅ¼niejsze, teraz moÅ¼esz mockowaÄ‡ bramkÄ™ pÅ‚atniczÄ…, dziÄ™ki czemu przy kaÅ¼dym uruchomieniu testu nie zostanie Ci naliczone 100 dolarÃ³w.

Stan globalny powoduje, Å¼e Twoje obiekty mogÄ… potajemnie uzyskiwaÄ‡ dostÄ™p do rzeczy, ktÃ³re nie sÄ… zadeklarowane w ich API, a w rezultacie czyniÄ… z Twoich API patologicznych kÅ‚amcÃ³w.

ByÄ‡ moÅ¼e wczeÅ›niej o tym tak nie myÅ›laÅ‚eÅ›, ale za kaÅ¼dym razem, gdy uÅ¼ywasz stanu globalnego, tworzysz tajne bezprzewodowe kanaÅ‚y komunikacyjne. Upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡ zmusza programistÃ³w do czytania kaÅ¼dej linii kodu, aby zrozumieÄ‡ potencjalne interakcje, obniÅ¼a produktywnoÅ›Ä‡ programistÃ³w i myli nowych czÅ‚onkÃ³w zespoÅ‚u.
JeÅ›li to Ty stworzyÅ‚eÅ› kod, znasz rzeczywiste zaleÅ¼noÅ›ci, ale kaÅ¼dy, kto przyjdzie po Tobie, jest bezradny.

Nie pisz kodu, ktÃ³ry wykorzystuje stan globalny, preferuj przekazywanie zaleÅ¼noÅ›ci. Czyli dependency injection.


KruchoÅ›Ä‡ stanu globalnego
-------------------------

W kodzie, ktÃ³ry uÅ¼ywa stanu globalnego i singletonÃ³w, nigdy nie jest pewne, kiedy i kto ten stan zmieniÅ‚. To ryzyko pojawia siÄ™ juÅ¼ przy inicjalizacji. PoniÅ¼szy kod ma utworzyÄ‡ poÅ‚Ä…czenie z bazÄ… danych i zainicjowaÄ‡ bramkÄ™ pÅ‚atniczÄ…, jednak ciÄ…gle rzuca wyjÄ…tek, a znalezienie przyczyny jest niezwykle czasochÅ‚onne:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Musisz szczegÃ³Å‚owo przeglÄ…daÄ‡ kod, aby dowiedzieÄ‡ siÄ™, Å¼e obiekt `PaymentGateway` uzyskuje bezprzewodowy dostÄ™p do innych obiektÃ³w, z ktÃ³rych niektÃ³re wymagajÄ… poÅ‚Ä…czenia z bazÄ… danych. Czyli konieczne jest zainicjowanie bazy danych przed `PaymentGateway`. Jednak zasÅ‚ona dymna stanu globalnego ukrywa to przed TobÄ…. Ile czasu byÅ› zaoszczÄ™dziÅ‚, gdyby API poszczegÃ³lnych klas nie kÅ‚amaÅ‚o i deklarowaÅ‚o swoje zaleÅ¼noÅ›ci?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Podobny problem pojawia siÄ™ rÃ³wnieÅ¼ przy uÅ¼yciu globalnego dostÄ™pu do poÅ‚Ä…czenia z bazÄ… danych:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Przy wywoÅ‚aniu metody `save()` nie jest pewne, czy poÅ‚Ä…czenie z bazÄ… danych zostaÅ‚o juÅ¼ utworzone i kto jest odpowiedzialny za jego utworzenie. JeÅ›li chcemy na przykÅ‚ad zmieniaÄ‡ poÅ‚Ä…czenie z bazÄ… danych w trakcie dziaÅ‚ania, na przykÅ‚ad w celu testÃ³w, musielibyÅ›my najprawdopodobniej utworzyÄ‡ dodatkowe metody, takie jak `DB::reconnect(...)` lub `DB::reconnectForTest()`.

RozwaÅ¼my przykÅ‚ad:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

SkÄ…d mamy pewnoÅ›Ä‡, Å¼e przy wywoÅ‚aniu `$article->save()` rzeczywiÅ›cie uÅ¼ywana jest testowa baza danych? Co jeÅ›li metoda `Foo::doSomething()` zmieniÅ‚a globalne poÅ‚Ä…czenie z bazÄ… danych? Aby to sprawdziÄ‡, musielibyÅ›my przeanalizowaÄ‡ kod ÅºrÃ³dÅ‚owy klasy `Foo` i prawdopodobnie wielu innych klas. To podejÅ›cie przyniosÅ‚oby jednak tylko krÃ³tkoterminowÄ… odpowiedÅº, poniewaÅ¼ sytuacja moÅ¼e siÄ™ w przyszÅ‚oÅ›ci zmieniÄ‡.

A co jeÅ›li przeniesiemy poÅ‚Ä…czenie z bazÄ… danych do zmiennej statycznej wewnÄ…trz klasy `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

To w ogÃ³le nic nie zmieniÅ‚o. Problemem jest stan globalny i jest zupeÅ‚nie obojÄ™tne, w ktÃ³rej klasie siÄ™ ukrywa. W tym przypadku, podobnie jak w poprzednim, przy wywoÅ‚aniu metody `$article->save()` nie mamy Å¼adnej wskazÃ³wki co do tego, do jakiej bazy danych zostanie zapisany. Ktokolwiek na drugim koÅ„cu aplikacji mÃ³gÅ‚ w dowolnym momencie za pomocÄ… `Article::setDb()` zmieniÄ‡ bazÄ™ danych. Nam pod nosem.

Stan globalny czyni naszÄ… aplikacjÄ™ **niezwykle kruchÄ…**.

Istnieje jednak prosty sposÃ³b, aby poradziÄ‡ sobie z tym problemem. Wystarczy pozwoliÄ‡ API deklarowaÄ‡ zaleÅ¼noÅ›ci, co zapewni poprawnÄ… funkcjonalnoÅ›Ä‡.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

DziÄ™ki temu podejÅ›ciu znika obawa o ukryte i nieoczekiwane zmiany poÅ‚Ä…czenia z bazÄ… danych. Teraz mamy pewnoÅ›Ä‡, gdzie artykuÅ‚ jest zapisywany, a Å¼adne modyfikacje kodu wewnÄ…trz innej, niepowiÄ…zanej klasy nie mogÄ… juÅ¼ zmieniÄ‡ sytuacji. Kod nie jest juÅ¼ kruchy, ale stabilny.

Nie pisz kodu, ktÃ³ry wykorzystuje stan globalny, preferuj przekazywanie zaleÅ¼noÅ›ci. Czyli dependency injection.


Singleton
---------

Singleton to wzorzec projektowy, ktÃ³ry wedÅ‚ug "definicji":https://en.wikipedia.org/wiki/Singleton_pattern ze znanej publikacji Gang of Four ogranicza klasÄ™ do jednej instancji i oferuje do niej globalny dostÄ™p. Implementacja tego wzorca zwykle przypomina nastÄ™pujÄ…cy kod:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// i inne metody peÅ‚niÄ…ce funkcje danej klasy
}
```

Niestety, singleton wprowadza do aplikacji stan globalny. A jak pokazaliÅ›my wyÅ¼ej, stan globalny jest niepoÅ¼Ä…dany. Dlatego singleton jest uwaÅ¼any za antywzorzec.

Nie uÅ¼ywaj w swoim kodzie singletonÃ³w i zastÄ…p je innymi mechanizmami. Singletony naprawdÄ™ nie sÄ… potrzebne. JeÅ›li jednak potrzebujesz zagwarantowaÄ‡ istnienie jednej instancji klasy dla caÅ‚ej aplikacji, pozostaw to [kontenerowi DI |container].
StwÃ³rz w ten sposÃ³b singleton aplikacyjny, czyli usÅ‚ugÄ™. DziÄ™ki temu klasa przestanie zajmowaÄ‡ siÄ™ zapewnieniem swojej wÅ‚asnej unikalnoÅ›ci (tj. nie bÄ™dzie miaÅ‚a metody `getInstance()` i zmiennej statycznej) i bÄ™dzie peÅ‚niÄ‡ tylko swoje funkcje. W ten sposÃ³b przestanie naruszaÄ‡ zasadÄ™ pojedynczej odpowiedzialnoÅ›ci.


Stan globalny a testy
---------------------

Podczas pisania testÃ³w zakÅ‚adamy, Å¼e kaÅ¼dy test jest izolowanÄ… jednostkÄ… i Å¼e nie wchodzi do niego Å¼aden zewnÄ™trzny stan. I Å¼aden stan nie opuszcza testÃ³w. Po zakoÅ„czeniu testu caÅ‚y powiÄ…zany z nim stan powinien zostaÄ‡ automatycznie usuniÄ™ty przez garbage collector. DziÄ™ki temu testy sÄ… izolowane. Dlatego moÅ¼emy uruchamiaÄ‡ testy w dowolnej kolejnoÅ›ci.

JeÅ›li jednak obecne sÄ… stany globalne/singletony, wszystkie te przyjemne zaÅ‚oÅ¼enia siÄ™ rozpadajÄ…. Stan moÅ¼e wchodziÄ‡ do testu i wychodziÄ‡ z niego. Nagle kolejnoÅ›Ä‡ testÃ³w moÅ¼e mieÄ‡ znaczenie.

Aby w ogÃ³le mÃ³c testowaÄ‡ singletony, programiÅ›ci czÄ™sto muszÄ… rozluÅºniÄ‡ ich wÅ‚aÅ›ciwoÅ›ci, na przykÅ‚ad pozwalajÄ…c na zastÄ…pienie instancji innÄ…. Takie rozwiÄ…zania sÄ… w najlepszym przypadku hackiem, ktÃ³ry tworzy trudny do utrzymania i zrozumienia kod. KaÅ¼dy test lub metoda `tearDown()`, ktÃ³ra wpÅ‚ywa na jakikolwiek stan globalny, musi te zmiany cofnÄ…Ä‡.

Stan globalny to najwiÄ™kszy bÃ³l gÅ‚owy przy testach jednostkowych!

Jak naprawiÄ‡ sytuacjÄ™? Åatwo. Nie pisz kodu, ktÃ³ry wykorzystuje singletony, preferuj przekazywanie zaleÅ¼noÅ›ci. Czyli dependency injection.


StaÅ‚e globalne
--------------

Stan globalny nie ogranicza siÄ™ tylko do uÅ¼ywania singletonÃ³w i zmiennych statycznych, ale moÅ¼e dotyczyÄ‡ rÃ³wnieÅ¼ staÅ‚ych globalnych.

StaÅ‚e, ktÃ³rych wartoÅ›Ä‡ nie wnosi nam Å¼adnej nowej (`M_PI`) lub uÅ¼ytecznej (`PREG_BACKTRACK_LIMIT_ERROR`) informacji, sÄ… jednoznacznie w porzÄ…dku.
Natomiast staÅ‚e, ktÃ³re sÅ‚uÅ¼Ä… jako sposÃ³b na *bezprzewodowe* przekazanie informacji do wnÄ™trza kodu, sÄ… niczym innym jak ukrytÄ… zaleÅ¼noÅ›ciÄ…. Jak na przykÅ‚ad `LOG_FILE` w poniÅ¼szym przykÅ‚adzie.
UÅ¼ycie staÅ‚ej `FILE_APPEND` jest caÅ‚kowicie poprawne.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

W tym przypadku powinniÅ›my zadeklarowaÄ‡ parametr w konstruktorze klasy `Foo`, aby staÅ‚ siÄ™ czÄ™Å›ciÄ… API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Teraz moÅ¼emy przekazaÄ‡ informacjÄ™ o Å›cieÅ¼ce do pliku logÃ³w i Å‚atwo jÄ… zmieniaÄ‡ w zaleÅ¼noÅ›ci od potrzeb, co uÅ‚atwia testowanie i konserwacjÄ™ kodu.


Funkcje globalne i metody statyczne
-----------------------------------

Chcemy podkreÅ›liÄ‡, Å¼e samo uÅ¼ywanie metod statycznych i funkcji globalnych nie jest problematyczne. WyjaÅ›nialiÅ›my, na czym polega nieodpowiednioÅ›Ä‡ uÅ¼ycia `DB::insert()` i podobnych metod, ale zawsze chodziÅ‚o tylko o kwestiÄ™ stanu globalnego, ktÃ³ry jest przechowywany w jakiejÅ› zmiennej statycznej. Metoda `DB::insert()` wymaga istnienia zmiennej statycznej, poniewaÅ¼ w niej jest przechowywane poÅ‚Ä…czenie z bazÄ… danych. Bez tej zmiennej implementacja metody byÅ‚aby niemoÅ¼liwa.

UÅ¼ywanie deterministycznych metod statycznych i funkcji, takich jak `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` i wielu innych, jest w caÅ‚kowitej zgodzie z dependency injection. Funkcje te zawsze zwracajÄ… te same wyniki dla tych samych parametrÃ³w wejÅ›ciowych i sÄ… zatem przewidywalne. Nie uÅ¼ywajÄ… Å¼adnego stanu globalnego.

IstniejÄ… jednak rÃ³wnieÅ¼ funkcje w PHP, ktÃ³re nie sÄ… deterministyczne. NaleÅ¼y do nich na przykÅ‚ad funkcja `htmlspecialchars()`. Jej trzeci parametr `$encoding`, jeÅ›li nie jest podany, domyÅ›lnie przyjmuje wartoÅ›Ä‡ opcji konfiguracyjnej `ini_get('default_charset')`. Dlatego zaleca siÄ™ zawsze podawaÄ‡ ten parametr, aby zapobiec ewentualnemu nieprzewidywalnemu zachowaniu funkcji. Nette konsekwentnie to robi.

NiektÃ³re funkcje, takie jak `strtolower()`, `strtoupper()` i podobne, w niedawnej przeszÅ‚oÅ›ci zachowywaÅ‚y siÄ™ niedeterministycznie i byÅ‚y zaleÅ¼ne od ustawienia `setlocale()`. PowodowaÅ‚o to wiele komplikacji, najczÄ™Å›ciej przy pracy z jÄ™zykiem tureckim.
Ten bowiem rozrÃ³Å¼nia maÅ‚Ä… i duÅ¼Ä… literÄ™ `I` z kropkÄ… i bez kropki. Tak wiÄ™c `strtolower('I')` zwracaÅ‚o znak `Ä±`, a `strtoupper('i')` znak `Ä°`, co prowadziÅ‚o do tego, Å¼e aplikacje zaczÄ™Å‚y powodowaÄ‡ szereg zagadkowych bÅ‚Ä™dÃ³w.
Ten problem zostaÅ‚ jednak usuniÄ™ty w PHP w wersji 8.2 i funkcje nie sÄ… juÅ¼ zaleÅ¼ne od locale.

Jest to piÄ™kny przykÅ‚ad, jak stan globalny napsuÅ‚ krwi tysiÄ…com programistÃ³w na caÅ‚ym Å›wiecie. RozwiÄ…zaniem byÅ‚o zastÄ…pienie go przez dependency injection.


Kiedy moÅ¼na uÅ¼yÄ‡ stanu globalnego?
----------------------------------

IstniejÄ… pewne specyficzne sytuacje, w ktÃ³rych moÅ¼na wykorzystaÄ‡ stan globalny. Na przykÅ‚ad podczas debugowania kodu, gdy potrzebujesz wypisaÄ‡ wartoÅ›Ä‡ zmiennej lub zmierzyÄ‡ czas trwania okreÅ›lonej czÄ™Å›ci programu. W takich przypadkach, ktÃ³re dotyczÄ… tymczasowych dziaÅ‚aÅ„, ktÃ³re zostanÄ… pÃ³Åºniej usuniÄ™te z kodu, uzasadnione jest wykorzystanie globalnie dostÄ™pnego dumpera lub stopera. Te narzÄ™dzia bowiem nie sÄ… czÄ™Å›ciÄ… projektu kodu.

Innym przykÅ‚adem sÄ… funkcje do pracy z wyraÅ¼eniami regularnymi `preg_*`, ktÃ³re wewnÄ™trznie przechowujÄ… skompilowane wyraÅ¼enia regularne w statycznej pamiÄ™ci podrÄ™cznej w pamiÄ™ci. Kiedy wiÄ™c wywoÅ‚ujesz to samo wyraÅ¼enie regularne wielokrotnie w rÃ³Å¼nych miejscach kodu, kompiluje siÄ™ ono tylko raz. PamiÄ™Ä‡ podrÄ™czna oszczÄ™dza wydajnoÅ›Ä‡, a jednoczeÅ›nie jest dla uÅ¼ytkownika caÅ‚kowicie niewidoczna, dlatego takie wykorzystanie moÅ¼na uznaÄ‡ za uzasadnione.


Podsumowanie
------------

OmÃ³wiliÅ›my, dlaczego warto:

1) UsunÄ…Ä‡ wszystkie zmienne statyczne z kodu
2) DeklarowaÄ‡ zaleÅ¼noÅ›ci
3) I uÅ¼ywaÄ‡ dependency injection

Kiedy zastanawiasz siÄ™ nad projektem kodu, pamiÄ™taj, Å¼e kaÅ¼de `static $foo` stanowi problem. Aby TwÃ³j kod byÅ‚ Å›rodowiskiem szanujÄ…cym DI, konieczne jest caÅ‚kowite wyeliminowanie stanu globalnego i zastÄ…pienie go za pomocÄ… dependency injection.

Podczas tego procesu byÄ‡ moÅ¼e odkryjesz, Å¼e trzeba podzieliÄ‡ klasÄ™, poniewaÅ¼ ma wiÄ™cej niÅ¼ jednÄ… odpowiedzialnoÅ›Ä‡. Nie bÃ³j siÄ™ tego; dÄ…Å¼ do zasady pojedynczej odpowiedzialnoÅ›ci.

*ChciaÅ‚bym podziÄ™kowaÄ‡ MiÅ¡kovi Hevery'emu, ktÃ³rego artykuÅ‚y, takie jak [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], sÄ… podstawÄ… tego rozdziaÅ‚u.*
