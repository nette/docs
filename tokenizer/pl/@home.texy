Tokenizer: tokenizacja ciągów znaków
************************************

.[perex]
Tokenizer jest bardzo prostym narzędziem, które wykorzystuje wyrażenia regularne do podziału ciągu na tokeny. **Ta biblioteka nie jest już w fazie rozwoju**.

Instalacja:

```shell
composer require nette/tokenizer
```


Tokenizacja łańcucha .[#toc-tokenizace-retezce]
-----------------------------------------------

Tworzymy prosty tokenizer, który oddziela ciągi znaków od liczb, spacji i liter.

```php
$tokenizer = new Nette\Tokenizer\Tokenizer([
	T_DNUMBER => '\d+',
	T_WHITESPACE => '\s+',
	T_STRING => '\w+',
]);
```

W przypadku, gdy zastanawiasz się, skąd pochodzą stałe T_, są to "wewnętrzne typy":https://www.php.net/manual/tokens.php, które są używane do parsowania kodu. Obejmują one większość wspólnych nazw tokenów, których zazwyczaj potrzebujemy. Pamiętaj, że ich wartość nie jest gwarantowana, więc nie używaj liczb do porównania.

Teraz, gdy przekażemy mu ciąg znaków, zwróci on [strumień |api:Nette\Tokenizer\Stream] [tokenów |api:Nette\Tokenizer\Token]:

```php
$stream = $tokenizer->tokenize("say \n123");
```

Wynikowa tablica tokenów `$stream->tokens` wygląda tak.

```php
[
	new Token('say', T_STRING, 0),
	new Token(" \n", T_WHITESPACE, 3),
	new Token('123', T_DNUMBER, 5),
]
```

Możesz uzyskać dostęp do poszczególnych właściwości tokena:

```php
$firstToken = $stream->tokens[0];
$firstToken->value; // hodnota tokenu: say
$firstToken->type; // hodnota T_STRING
$firstToken->offset; // pozice v řetězci: 0
```

Proste, prawda?


Przetwarzanie tokenów .[#toc-zpracovani-tokenu]
-----------------------------------------------

Teraz wiemy, jak tworzyć tokeny z ciągu znaków. Możemy je efektywnie przetwarzać za pomocą [Stream |api:Nette\Tokenizer\Stream]. Ma wiele naprawdę niesamowitych metod, jeśli potrzebujesz przekazać żetony!

Spróbujmy sparsować prostą adnotację z PHPDoc i stworzyć z niej obiekt. Jakie wyrażenia regularne są nam potrzebne dla tokenów? Wszystkie adnotacje zaczynają się od znaku `@`, po którym następuje ich nazwa, spacje i wartość.

- `@` aby rozpocząć adnotację
- `\s+` dla znaków białych przestrzeni
- `\w+` dla smyczków

.[note]
Nigdy nie używaj podciągów przechwytujących, takich jak `'(ab)+c'` w wyrażeniach regularnych Tokenizera , używaj ich nie przechwytujących wariantów `'(?:ab)+c'`.

To powinno działać na prostych adnotacjach, prawda? Teraz pokażmy ciąg wejściowy, który będziemy próbowali parsować.

```php
$input = '
	@author David Grudl
	@package Nette
';
```

Stwórzmy klasę `Parser`, która przyjmuje ciąg znaków i zwraca tablicę par '['nazwa, wartość |název, hodnota]''. To będzie bardzo naiwne i proste.

```php
use Nette\Tokenizer\Tokenizer;
use Nette\Tokenizer\Stream;

class Parser
{
	const T_AT = 1;
	const T_WHITESPACE = 2;
	const T_STRING = 3;

	private Tokenizer $tokenizer;
	private Stream $stream;

	public function __construct()
	{
		$this->tokenizer = new Tokenizer([
			self::T_AT => '@',
			self::T_WHITESPACE => '\s+',
			self::T_STRING => '\w+',
		]);
	}

	public function parse(string $input): array
	{
		$this->stream = $this->tokenizer->tokenize($input);

		$result = [];
		while ($this->stream->nextToken()) {
			if ($this->stream->isCurrent(self::T_AT)) {
				$result[] = $this->parseAnnotation();
			}
		}

		return $result;
	}

	private function parseAnnotation(): array
	{
		$name = $this->stream->joinUntil(self::T_WHITESPACE);
		$this->stream->nextUntil(self::T_STRING);
		$content = $this->stream->joinUntil(self::T_AT);

		return [$name, trim($content)];
	}
}
```

```php
$parser = new Parser;
$annotations = $parser->parse($input);
```

Co więc robi metoda `parse()`? Przechodzi przez tokeny i szukając `@`, což je symbol začátku anotace. Volání `nextToken()` przenosi kursor na następny token. Metoda `isCurrent()` sprawdza, czy bieżący token na kursorze jest tego typu. Następnie, jeśli `@`, metoda `parse()` zostanie znaleziony, wywołuje `parseAnnotation()`, który oczekuje, że adnotacje będą w bardzo specyficznym formacie.

Najpierw używa metody `joinUntil()`, aby przesunąć kursor i konkatenować ciąg tokenów w buforze, aż znajdzie token żądanego typu, a następnie zatrzymuje się i zwraca cały ciąg. Ponieważ w danej pozycji znajduje się tylko jeden token typu `T_STRING`, zmienna `$name` będzie zawierała ciąg `'name'`.

Metoda `nextUntil()` jest podobna do `joinUntil()`, ale bez bufora. Przesuwa kursor tylko do momentu trafienia na oczekiwany token. Więc to wywołanie po prostu pomija wszystkie spacje po nazwie adnotacji.

A potem jest jeszcze jedna `joinUntil()`, która szuka kolejnej `@`. Toto konkrétní volání vrátí `"David Grudl\n "`.

I oto mamy, sparsowaliśmy jedną całą adnotację! Zmienna `$content` prawdopodobnie będzie zawierać białe znaki, więc musimy ją przyciąć. Teraz zwrócimy tę konkretną adnotację jako parę `[$name, $content]`.

Spróbuj skopiować kod i uruchomić go. Jeśli wyprowadzisz zmienną `$annotations`, zobaczysz podobne dane wyjściowe.

```
array (2)
   0 => array (2)
   |  0 => 'author'
   |  1 => 'David Grudl'
   1 => array (2)
   |  0 => 'package'
   |  1 => 'Nette'
```


Metody klasy Stream .[#toc-metody-tridy-stream]
-----------------------------------------------

Stream może zwrócić bieżący token za pomocą metody `currentToken()` lub tylko jego wartość za pomocą `currentValue()`.

`nextToken()` przesuwa kursor i zwraca token. Jeśli nie podasz mu żadnych argumentów, po prostu zwraca kolejny token.

`nextValue()` jest taki sam jak `nextToken()`, ale zwraca tylko wartość tokena.

Większość metod przyjmuje również wiele argumentów, więc możesz wyszukiwać wiele typów jednocześnie.

```php
// hledá, dokud nenalezne řetězec nebo prázdný znak, a poté vrátí následující token
$token = $stream->nextToken(T_STRING, T_WHITESPACE);

// dejte mi další token
$token = $stream->nextToken();
```

Możesz również wyszukać tokeny według wartości.

```php
// přesouvej kurzor, dokud nenajdeš token '@', poté zastav a vrať jej
$token = $stream->nextToken('@');
```

`nextUntil()` przesuwa kursor i zwraca tablicę wszystkich znalezionych tokenów, aż do znalezienia żądanego tokena, w którym to momencie zatrzymuje się. Może przyjąć wiele argumentów.

`joinUntil()` Jest podobne do `nextUntil()`, ale zwraca zwarty łańcuch wszystkich przekazanych tokenów.

`joinAll()` Po prostu konkatenuje wszystkie pozostałe wartości tokenów i zwraca je. Przenosi kursor na koniec strumienia tokenów.

`nextAll()` Jest takie samo jak `joinAll()`, ale zwraca tablicę tokenów.

`isCurrent()` Sprawdza, czy bieżący token lub wartość tokena jest równa jednemu z argumentów.

```php
// je aktuální token '@' nebo typ T_AT?
$stream->isCurrent(T_AT, '@');
```

`isNext()` jest taki sam jak `isCurrent()`, ale sprawdza następujący token.

`isPrev()` jest taka sama jak `isCurrent()`, ale sprawdza poprzedni token.

Ostatnia metoda, `reset()`, zwraca kursor na początek, więc możesz powtórzyć przekazywanie tokenów.


{{leftbar: utils:@left-menu}}
