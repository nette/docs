Сгенерированные фабрики
***********************

.[perex]
Nette DI может автоматически генерировать код фабрик на основе интерфейса, что избавляет вас от написания кода.

Фабрика — это класс, который создает и настраивает объекты. Поэтому он передает им и их зависимости. Мы показали, как выглядит такая фабрика во [введении|introduction#Фабрика]:

```php
class ArticleFactory
{
	private Nette\Database\Connection $db;

	public function __construct(Nette\Database\Connection $db)
	{
		$this->db = $db;
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

Всё, что вам нужно сделать, это создать интерфейс, а Nette DI сгенерирует его реализацию. Интерфейс должен иметь ровно один метод с именем `create` и объявлять возвращаемый тип:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

Итак, фабрика `ArticleFactory` имеет метод `create`, который создает объекты `Article`. Класс `Article` может выглядеть, например, следующим образом:

```php
class Article
{
	private $db;

	public function __construct(Nette\Database\Connection $db)
	{
		$this->db = $db;
	}
}
```

Добавьте фабрику в файл конфигурации:

```neon
services:
	- ArticleFactory
```

Nette DI создаст соответствующую реализацию фабрики.

Таким образом, в коде, использующем фабрику, мы запрашиваем объект по интерфейсу, а Nette DI использует сгенерированную реализацию:

```php
class UserController
{
	private $articleFactory;

	public function __construct(ArticleFactory $articleFactory)
	{
		$this->articleFactory = $articleFactory;
	}

	public function foo()
	{
		// let the factory create an object
		$article = $this->articleFactory->create();
	}
}
```


Параметризированная фабрика
===========================

Метод фабрики `create` может принимать параметры, которые он затем передает конструктору. Например, давайте добавим ID автора статьи в класс `Article`:

```php
class Article
{
	private $db;
	private $authorId;

	public function __construct(Nette\Database\Connection $db, int $authorId)
	{
		$this->db = $db;
		$this->authorId = $authorId;
	}
}
```

Мы также добавим параметр в фабрику:

```php
interface ArticleFactory
{
	function create(int $authorId): Article;
}
```

Поскольку параметр в конструкторе и параметр в фабрике имеют одинаковое имя, Nette DI передаст их автоматически.


Расширенное определение
=======================

Определение также может быть записано в многострочной форме с помощью ключа `implement`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
```

При написании таким удлиненным способом можно предоставить дополнительные аргументы для конструктора в ключе `arguments` и дополнительную конфигурацию с помощью `setup`, как и для обычных сервисов.

Пример: Если бы метод `create()` не принимал параметр `$authorId`, мы могли бы указать в конфигурации фиксированное значение, которое передавалось бы в конструктор `Article`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
		arguments:
			authorId: 123
```

Или, наоборот, если бы `create()` принимал параметр `$authorId`, но он не был частью конструктора и был передан методом `Article::setAuthorId()`, мы бы обратились к нему в секции `setup`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
		setup:
			- setAuthorId($authorId)
```


Аксессор
========

Помимо фабрик, Nette также может генерировать так называемые аксессоры. Это объекты с методом `get()`, которы возвращает конкретный сервис из DI-контейнера. Повторные вызовы `get()` по-прежнему возвращают один и тот же экземпляр.

Аксессор обеспечивает ленивую загрузку зависимостей. Пусть у нас есть класс, который записывает ошибки в специальную базу данных. Если бы в этом классе соединение с базой данных передавалось конструктором как зависимость, то соединение приходилось бы создавать всегда, хотя на практике ошибка возникает очень редко, и поэтому соединение обычно оставалось бы неиспользованным.
Вместо этого класс передает метод доступа, и только при вызове его `get()` создается объект базы данных:

Как создать аксессор? Просто напишите интерфейс, и Nette DI сгенерирует реализацию. Интерфейс должен иметь ровно один метод с именем `get` и объявить возвращаемый тип:

```php
interface PDOAccessor
{
	function get(): PDO;
}
```

Мы добавим аксессор в файл конфигурации, который также содержит определение сервиса, который он вернет:

```neon
services:
	- PDOAccessor
	- PDO(%dsn%, %user%, %password%)
```

Поскольку метод доступа возвращает службу `PDO`, а в конфигурации есть только один такой сервис, он вернет его. Если сервисов данного типа больше, мы определяем возвращаемый сервис по имени, например `- PDOAccessor(@db1)`.


Несколько фабрик/аксессоров
===========================

До сих пор наши фабрики и аксессоры всегда могли производить или возвращать только один объект. Однако очень легко создать несколько фабрик в сочетании с аксессорами. Интерфейс такого класса будет содержать любое количество методов с именами `create<name>()` и `get<name>()`, например:

```php
interface MultiFactory
{
	function createArticle(): Article;
    function createFoo(): Model\Foo;
    function getDb(): PDO;
}
```

Поэтому вместо того, чтобы передавать несколько сгенерированных фабрик и аксессоров, мы собираемся передать ещё одну сложную фабрику, которая может делать больше.

Как вариант, вместо нескольких методов можно использовать параметры `create()` и `get()`:

```php
interface MultiFactoryAlt
{
	function create($name);
    function get($name): PDO;
}
```

Затем `MultiFactory::createArticle()` делает то же самое, что и `MultiFactoryAlt::create('article')`. Однако альтернативная нотация имеет тот недостаток, что неясно, какие значения `$name` поддерживаются, и логически невозможно различить разные возвращаемые значения для разных `$name` в интерфейсе.


Определение списка
------------------

А как определить множественную фабрику в конфигурации? Мы создадим три сервиса, которые будут создавать/возвращать, а затем и саму фабрику:

```neon
services:
	article: Article
	- Model\Foo
	- PDO(%dsn%, %user%, %password%)
    - MultiFactory(
        article: @article  # createArticle()
        foo: @Model\Foo    # createFoo()
        db: @\PDO          # getDb()
    )
```

Определения с использованием тегов
----------------------------------

Второй вариант — использовать [теги|services#Теги] для определения:

```neon
services:
	- App\Router\RouterFactory::createRouter
	- App\Model\DatabaseAccessor(
	    db1: @database.db1.context
	)
```



Фабрика компонентов
===================

Как создать сложные компоненты со многими зависимостями, не «испортив» презентеры, которые будут их использовать? Благодаря умным функциям контейнера DI в Nette, как и при использовании классических сервисов, мы можем оставить большую часть работы фреймворку.

Возьмем в качестве примера компонент, который имеет зависимости от нескольких сервисов:

```php
class MyControl extends Nette\Application\UI\Control
{
	public function __construct(
		EmailValidator $emailValidator,
		Registrator $registrator,
		Mailer $mailer
	) {
		//
	}
}
```

Если бы мы писали классический сервис, то беспокоиться было бы не о чем. Контейнер внедрения зависимостей незаметно позаботится о передаче всех зависимостей. Но обычно мы обрабатываем компоненты, создавая их новый экземпляр непосредственно в презентере в фабричных методах `createComponent…()`.
И передача всех наших зависимостей презентеру, чтобы затем передать их компоненту, является утомительным и громоздким решением. Это означает введение в презентере приватных переменных, которые не находят применения вне одного метода. И мысль о количестве кода, который вам нужно написать...

```php
class MyPresenter extends Nette\Application\UI\Presenter
{
	private $emailValidator;
	private $registrator;
	private $mailer;

	public function __construct(
		EmailValidator $emailValidator,
		Registrator $registrator,
		Mailer $mailer
	) {
		$this->emailValidator = $emailValidator;
		$this->registrator = $registrator;
		$this->mailer = $mailer;
	}

	protected function createComponentMyControl(): MyControl
	{
		$control = new MyControl(
			$this->emailValidator,
			$this->registrator,
			$this->mailer
		);
		return $control;
	}
}
```

Логичный вопрос: почему бы нам просто не зарегистрировать компонент как классический сервис, передать его презентеру, а затем вернуть в методе `createComponent…()`? Однако такой подход крайне неуместен, потому что обычно мы хотим создать компонент несколько раз.

Архитектурно правильное решение, не загрязняющее презентер лишними зависимостями — написать фабрику для компонента. Опять же, мы можем сгенерировать его на основе интерфейса. Например, наш интерфейс для компонента может выглядеть так:

```php
interface MyControlFactory
{
	public function create(): MyControl;
}
```

Прописываем фабрику в конфигурационном файле:

```neon
services:
	- MyControlFactory
```

В презентере тогда будет достаточно получить фабрику и вызвать метод `create`:

```php
class MyPresenter extends Nette\Application\UI\Presenter
{
	private $myControlFactory;

	public function __construct(MyControlFactory $myControlFactory)
	{
		$this->myControlFactory = $myControlFactory;
	}

	protected function createComponentMyControl(): MyControl
	{
		$control = $this->myControlFactory->create();
		return $control;
	}
}
```

Созданный компонент будет автоматически передавать свои зависимости конструктором.

{{composer: nette/di}}
/--comment
TODO: extensive update
\--
