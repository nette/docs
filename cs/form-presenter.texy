Formuláře v presenterech
************************

.[perex]
Nette Forms zásadně usnadňují vytváření a zpracování webových formulářů ve vašich aplikacích. V této kapitole se seznámíte s používáním formulářů uvnitř presenterů.

Pokud nepoužíváte presentery a Nette Application, je pro vás určen návod pro [samostatné použití|form-standalone].


První formulář
==============

Zkusíme si napsat jednoduchý registrační formulář. Jeho kód bude vypadat takto:

```php
use Nette\Application\UI\Form;

$form = new Form;
$form->addText('name', 'Jméno:');
$form->addPassword('password', 'Heslo:');
$form->addSubmit('send', 'Registrovat');
$form->onSuccess[] = [$this, 'formSucceeded'];
```

a v prohlížeči bude vypadat takto:

[* form-cs.png *]

Vytvořili jsme formulář s [prvky|form fields] jméno, heslo a odesílací tlačítko. V presenterech vždy používáme pro formuláře třídu `Nette\Application\UI\Form`, její předchůdce `Nette\Forms\Form` je určen pro samostatné užití. A nakonec řádek s `$form->onSuccess` říká, že po odeslání a úspěšné validaci se má zavolat metoda `$this->formSucceeded()`.

Z pohledu presenteru je formulář běžná komponenta. Proto se s ním jako s komponentou zachází a začleníme ji do presenteru pomocí [tovární metody |components#Tovární metody]. Bude to vypadat takto:

```php .{data-file:app/Presenters/HomepagePresenter.php}
use Nette;
use Nette\Application\UI\Form;

class HomepagePresenter extends Nette\Application\UI\Presenter
{
	protected function createComponentRegistrationForm(): Form
	{
		$form = new Form;
		$form->addText('name', 'Jméno:');
		$form->addPassword('password', 'Heslo:');
		$form->addSubmit('send', 'Registrovat');
		$form->onSuccess[] = [$this, 'formSucceeded'];
		return $form;
	}

	public function formSucceeded(Form $form, $data): void
	{
		// tady zpracujeme data odeslaná formulářem
		// $data->name obsahuje jméno
		// $data->password obsahuje heslo
		$this->flashMessage('Byl jste úspěšně registrován.');
		$this->redirect('Homepage:');
	}
}
```

A v šabloně formulář vykreslíme značkou `{control}`:

```html .{data-file:app/Presenters/templates/Homepage/default.latte}
<h1>Registrace</h1>

{control registrationForm}
```

A to je vlastně vše :-) Máme funkční a perfektně [zabezpečený|#Ochrana před zranitelnostmi] formulář.

A teď si nejspíš říkáte, že to bylo moc hrr, přemýšlíte, jak je možné, že se zavolá metoda `formSucceeded()` a co jsou parametry, které dostává. Jistě, máte pravdu, tohle si zaslouží vysvětlení.

Nette totiž přichází se svěžím mechanismem, kterému říkáme [Hollywood style|components#Hollywood style]. Místo toho, abyste se jako vývojář musel neustále vyptávat, jestli se něco událo („byl formulář odeslaný?“, „byl odeslaný validně?“ a „nedošlo k jeho podvržení?“), řeknete frameworku „až bude formulář validně vyplněný, zavolej tuhle metodu“ a necháte další práci na něm. Pokud programujete v JavaScriptu, tento styl programování důvěrně znáte. Píšete funkce které se volají, až nastane určitá událost. A jazyk jim předá příslušné parametry.

Právě takhle je postaven i výše uvedený kód presenteru. Pole `$form->onSuccess` představuje seznam PHP callbacků, které Nette zavolá v okamžiku, kdy je formulář odeslán a správně vyplněn.
V rámci [životního cyklu presenteru |presenters#zivotni-cyklus-presenteru] jde o tzv. signál, volají se tedy po `action*` metodě a před `render*` metodou.
A každému callbacku předá jako první parametr samotný formulář a jako druhý odeslaná data v podobě objektu [ArrayHash |arrays#ArrayHash]. Druhý parametr umí být mazanější, ale o tom až [později|#Mapování na třídy].

Proměnná `$data` obsahuje klíče `name` a `password` s údaji, které vyplnil uživatel. Obvykle data rovnou posíláme k dalšímu zpracování, jako je například vložení do databáze.

Po zpracování formuláře přesměrujeme na další stránku. Zabrání se tak nechtěnému opětovnému odeslání formuláře tlačítkem Obnovit, Zpět nebo pohybem v historii prohlížeče.


Přístup k prvkům
================

Formulář je komponenta presenteru, v našem případě pojmenovaná `registrationForm` (dle jména tovární metody `createComponentRegistrationForm`), takže kdekoliv v presenteru se k formuláři dostanete pomocí:

```php
$form = $this->getComponent('registrationForm');
// alternativní syntax: $form = $this['registrationForm'];
```

Komponenty jsou i jednotlivé prvky formuláře, proto se k nim dostanete stejným způsobem:

```php
$input = $form->getComponent('name'); // nebo $input = $form['name'];
$button = $form->getComponent('send'); // nebo $button = $form['send'];
```


Validační pravidla
==================

Několikrát tu padlo slovo *validní,* ale formulář zatím žádná validační pravidla nemá. Pojďme to napravit.

Jméno bude povinné, proto je označíme metodou `setRequired()`, jejíž volitelný argument je vlastní text chybové hlášky, která se zobrazí, pokud uživatel jméno nevyplní. Pokud argument neuvedeme, použije se výchozí chybová hláška.

```php
$form->addText('name', 'Jméno:')
	->setRequired('Zadejte prosím jméno');
```

Zkuste si odeslat formulář bez vyplněného jména a uvidíte, že se zobrazí chybová hláška a prohlížeč či server jej bude odmítat do té doby, dokud políčko nevyplníte.

Zároveň systém neošidíte tím, že do políčka napíšete třeba jen mezery. Kdepak. Nette levo- i pravostranné mezery automaticky odstraňuje. Vyzkoušejte si to. Je to věc, kterou byste měli s každým jednořádkovým inputem vždy udělat, ale často se na to zapomíná. Nette to dělá automaticky.

Formulář se vždy validuje na straně serveru, ale také generuje JavaScriptovou validaci na straně prohlížeče, která proběhne bleskově a uživatel se o chybě dozví okamžitě, bez nutnosti formulář odesílat na server. Tohle má na starosti skript `netteForms.js`.
Pokud vycházíte z *nette/sandbox*, už jej máte zalinkovaný v layoutu stránky. V opačném případě si jej vložte do stránky:

```html
<script src="https://nette.github.io/resources/js/3/netteForms.min.js"></script>
```

Pokud se podíváte do zdrojového kódu stránky, můžete si všimnout, že Nette povinné prvky vkládá do elementu s CSS třídou `required`. Zkuste přidat do šablony následující stylopis a popiska „Jméno“ bude červená. Elegantně tak uživateli označíme povinné prvky:

```html
<style>
.required label { color: maroon }
</style>
```

Další validační pravidla přidáme metodou `addRule()`. První parametr je [pravidlo|form-validation#pravidla], druhý je opět vlastní text chybové hlášky a může ještě následovat argument validačního pravidla.

Formulář rozšíříme o nové nepovinné políčko „věk“, které musí být celé číslo (`addInteger()`) a navíc v povoleném rozsahu (`$form::RANGE`). Zde využijeme třetí parametr metody `addRule()`, kterým předáme validátoru požadovaný rozsah jako dvojici `[od, do]`:

```php
$form->addInteger('age', 'Věk:')
	->addRule($form::RANGE, 'Věk musí být od 18 do 120', [18, 120]);
```

.[tip]
Pokud uživatel políčko nevyplní, nebudou se validační pravidla ověřovat, neboť prvek je nepovinný.

Zde vzniká prostor pro drobný refactoring. V chybové hlášce a ve třetím parametru jsou čísla uvedená duplicitně, což není ideální. Pokud bychom tvořili [vícejazyčné formuláře |translations] a hláška obsahující čísla by se musela přeložit do více jazyků, ztížila by se pozdější změna hodnot. Z toho důvodu je možné použít zástupné znaky `%d` a Nette hodnoty doplní:

```php
	->addRule($form::RANGE, 'Věk musí být od %d do %d let', [18, 120]);
```

Vraťme se k prvku `password`, který taktéž učiníme povinným a ještě ověříme minimální délku hesla (`$form::MIN_LENGTH`), opět s využitím zástupného znaku:

```php
$form->addPassword('password', 'Heslo:')
	->setRequired('Zvolte si heslo')
	->addRule($form::MIN_LENGTH, 'Heslo musí mít alespoň %d znaků', 8);
```

Přidáme do formuláře ještě políčko `passwordVerify`, kde uživatel zadá heslo ještě jednou, pro kontrolu. Pomocí validačních pravidel zkontrolujeme, zda jsou obě hesla stejná (`$form::EQUAL`). Všimněte si dynamické odvolávky na první heslo pomocí [hranatých závorek|#Přístup k prvkům]:

```php
$form->addPassword('passwordVerify', 'Heslo pro kontrolu:')
	->setRequired('Zadejte prosím heslo ještě jednou pro kontrolu')
	->addRule($form::EQUAL, 'Hesla se neshodují', $form['password'])
	->setOmitted(); // po validaci údaj zahodí a nepředá do $data
```

Tímto máme hotový plně funkční formulář, který disponuje na chlup stejnou validací na straně prohlížeče i serveru. Automaticky ošetřuje zda útočník neposílá nevalidní UTF-8 řetězce apod., nepodvrhuje formulář z jiné domény, atd. Na tyto věci prostě nemusíte myslet, dělá je Nette za vás.

Zkuste si přidat i další [formulářové prvky|form-fields]. Inspiraci najdete také v distribuci v adresáři [examples|https://github.com/nette/forms/tree/master/examples].


Výchozí hodnoty
===============

Prvkům formuláře běžne nastavujeme výchozí hodnoty. Třeba když formulář slouží k editaci záznamů. Přečteme jej z databáze a předáme formuláři jako pole výchozích hodnot:

```php
$items = [
	'name' => 'John',
	'age' => '33'
];
$form->setDefaults($items);
```

Volejte `setDefaults()` až po definici prvků.

Metodou `setDefaultValue()` lze nastavit výchozí hodnotu jednotlivým prvkům:

```php
$form->addEmail('email', 'E-mail')
	->setDefaultValue('user@example.com');
```


Vykreslení formuláře
====================

Standardně se formulář vykreslí jako tabulka. Jednotlivé prvky splňují základní pravidlo přístupnosti - všechny popisky jsou zapsány jako `<label>` a provázané s příslušným formulářovým prvkem. Při kliknutí na popisku se kurzor automaticky objeví ve formulářovém políčku.

Každému prvku můžeme nastavovat libovolné HTML atributy. Třeba přidat placeholder:

```php
$form->addInteger('age', 'Věk:')
	->setHtmlAttribute('placeholder', 'Prosím vyplňte věk');
```

Způsobů, jak vykreslit formulář, je opravdu velké množství, takže je tomu věnována [samostatná kapitola o vykreslování|form-rendering].


Mapování na třídy
=================

Vraťme se k metodě `formSucceeded()`, která jako druhý parametr `$data` dostává objekt `ArrayHash` s odeslanými daty. Protože jde o generický objekt, něco jako `stdClass`, nebude nám samozřejmě fungovat našeptávání nebo [statická analýza kódu|editors-and-tools#PHPStan].
Šikovnější by proto bylo vytvořit si pro každý formulář třídu, kde properties představují jednotlivé prvky. Např.:

```php
class RegistrationFormData
{
	/** @var string */
	public $name;
	/** @var int */
	public $age;
	/** @var string */
	public $password;
}
```

Nyní nám stačí tuto třídu uvést jako typehint pro `$data` a ejhle, Nette vytvoří a předá nám právě tento objekt:

```php
public function formSucceeded(Form $form, RegistrationFormData $data): void
{
	$name = $data->name;
	...
```

Naopak pokud by vám více vyhovovalo získat data jako čisté pole, uveďte type hint `array`.


Více tlačítek
=============

Pokud má formulář více než jedno tlačítko, potřebujeme zpravidla rozlišit, které z nich bylo stlačeno. Jednou z možností je vytvořit více handlerů a nechat, pro každé tlačítko jiný. Nastavíme je pro událost `onClick` u tlačítek:

```php
$form->addSubmit('save', 'Uložit')
	->onClick[] = [$this, 'saveButtonPressed'];

$form->addSubmit('delete', 'Smazat')
	->onClick[] = [$this, 'deleteButtonPressed'];
```

Tyto handlery se volají také pouze v případě validně vyplněného formuláře a to před handlery pro událost `onSuccess`. Rozdíl je v tom, že jako první parametr se nepředává formulář, ale odesílací tlačítko:

```php
public function saveButtonPressed(Nette\Forms\Controls\Button $button, $data)
{
	$form = $button->getForm();
	...
```

Když se formulář odešle tlačítkem *enter*, za odesílací tlačítko se považuje to první.



Ochrana před zranitelnostmi
===========================

Nette Framework klade velký důraz na bezpečnost a proto úzkostlivě dbá i na dobré zabezpečení formulářů. Dělá to zcela transparentně a nevyžaduje manuálně nic nastavovat. Ochrání vaše aplikace před útokem [Cross Site Scripting (XSS) |vulnerability-protection#cross-site-scripting-xss] i [Cross-Site Request Forgery (CSRF)|vulnerability-protection#Cross-Site Request Forgery (CSRF)], odfiltruje ze vstupů kontrolní znaky, ověří validitu UTF-8 kódování nebo jestli nejsou položky vybrané v select boxech podvržené atd.

CSRF útok spočívá v tom, že útočník naláká oběť na stránku, která nenápadně v prohlížeči oběti vykoná požadavek na server, na kterém je oběť přihlášena, a server se domnívá, že požadavek vykonala oběť o své vůli. Proto Nette zabraňuje odeslání formuláře z jiné domény. Pokud z nějakého důvodu chcete ochranu vypnout a dovolit odesílat formulář z jiné domény, použijte:

```php
$form->disableSameSiteProtection(); // POZOR! Vypne ochranu!
```


Stejný formulář ve více presenterech
====================================

Pokud potřebujete jeden formulář použít ve více presenterech, doporučujeme si pro něj vytvořit továrnu, kterou si pak předáte do presenteru. Vhodné umístění pro takovou třídu je např. adresář `app/Forms`.

Naše tovární třída bude vypadat takto:

```php
use Nette\Application\UI\Form;

class SignInFormFactory
{
	public function create(): Form
	{
		$form = new Form;
		$form->addText('name', 'Jméno:');
		$form->addSubmit('send', 'Přihlásit se');
		return $form;
	}
}
```

V tovární metodě pro komponenty v presenterech, které náš formulář používají, jej následně vytvoříme voláním metody `create()`:

```php
protected function createComponentSignInForm(): Form
{
	$form = (new SignInFormFactory)->create();
	$form['send']->caption = 'Pokračovat'; // můžeme také formulář pozměnit
	$form->onSuccess[] = [$this, 'signInFormSuceeded']; // a přidat handler
	return $form;
}
```

Samozřejme zpracování formuláře může být už součástí továrny:

```php
use Nette\Application\UI\Form;

class SignInFormFactory
{
	public function create(): Form
	{
		$form = new Form;
		$form->addText('name', 'Jméno:');
		$form->addSubmit('send', 'Přihlásit se');
		$form->onSuccess[] = function (Form $form, $data): void {
			// zde provedeme zpracování formuláře
		};
		return $form;
	}
}
```

/--comment
Chybí addError()

Občas se může hodit formulář resetovat do stavu před jeho odesláním. To je možné zařídit zavoláním metody `reset()` na odeslaném formuláři:
```php
$form->isSubmitted(); // true
$form->reset(); //formulář je nyní ve stavu, jako by nebyl nikdy odeslán
$form->isSubmitted(); // false
```
\---

{{composer: nette/forms}}
