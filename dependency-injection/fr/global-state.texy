√âtat global et singletons
*************************

.[perex]
Avertissement : Les constructions suivantes sont le signe d'un code mal con√ßu :

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ou `static::$var`

Certaines de ces constructions apparaissent-elles dans votre code ? Alors vous avez l'occasion de l'am√©liorer. Vous pensez peut-√™tre qu'il s'agit de constructions courantes que vous voyez m√™me dans les exemples de solutions de diverses biblioth√®ques et frameworks. Si c'est le cas, alors la conception de leur code n'est pas bonne.

Nous ne parlons certainement pas ici d'une sorte de puret√© acad√©mique. Toutes ces constructions ont une chose en commun : elles utilisent l'√©tat global. Et celui-ci a un impact destructeur sur la qualit√© du code. Les classes mentent sur leurs d√©pendances. Le code devient impr√©visible. Il embrouille les programmeurs et r√©duit leur efficacit√©.

Dans ce chapitre, nous expliquerons pourquoi il en est ainsi et comment √©viter l'√©tat global.


Couplage global
---------------

Dans un monde id√©al, un objet ne devrait pouvoir communiquer qu'avec les objets qui lui ont √©t√© [directement pass√©s |passing-dependencies]. Si je cr√©e deux objets `A` et `B` et que je ne passe jamais de r√©f√©rence entre eux, alors ni `A` ni `B` ne peuvent acc√©der √† l'autre objet ou modifier son √©tat. C'est une propri√©t√© tr√®s souhaitable du code. C'est similaire √† avoir une batterie et une ampoule ; l'ampoule ne s'allumera pas tant que vous ne la connecterez pas √† la batterie avec un fil.

Mais cela ne s'applique pas aux variables globales (statiques) ou aux singletons. L'objet `A` pourrait acc√©der *sans fil* √† l'objet `C` et le modifier sans aucun passage de r√©f√©rence, en appelant `C::changeSomething()`. Si l'objet `B` s'empare √©galement du `C` global, alors `A` et `B` peuvent s'influencer mutuellement via `C`.

L'utilisation de variables globales introduit dans le syst√®me une nouvelle forme de couplage *sans fil*, qui n'est pas visible de l'ext√©rieur. Elle cr√©e un √©cran de fum√©e compliquant la compr√©hension et l'utilisation du code. Pour que les d√©veloppeurs comprennent r√©ellement les d√©pendances, ils doivent lire chaque ligne du code source. Au lieu de simplement se familiariser avec l'interface des classes. De plus, il s'agit d'un couplage totalement inutile. L'√©tat global est utilis√© parce qu'il est facilement accessible de n'importe o√π et permet, par exemple, d'√©crire dans la base de donn√©es via la m√©thode globale (statique) `DB::insert()`. Mais comme nous le montrerons, l'avantage que cela apporte est minime, tandis que les complications qu'il provoque sont fatales.

.[note]
Du point de vue du comportement, il n'y a pas de diff√©rence entre une variable globale et une variable statique. Elles sont tout aussi nuisibles.


Action fant√¥me √† distance
-------------------------

"Action fant√¥me √† distance" - c'est ainsi qu'Albert Einstein a fameusement nomm√© en 1935 un ph√©nom√®ne de la physique quantique qui lui donnait la chair de poule.
Il s'agit de l'intrication quantique, dont la particularit√© est que lorsque vous mesurez une information sur une particule, vous influencez instantan√©ment l'autre particule, m√™me si elles sont s√©par√©es par des millions d'ann√©es-lumi√®re.
Ce qui semble violer la loi fondamentale de l'univers selon laquelle rien ne peut se propager plus vite que la lumi√®re.

Dans le monde logiciel, nous pouvons appeler "action fant√¥me √† distance" une situation o√π nous lan√ßons un processus que nous croyons isol√© (parce que nous ne lui avons pass√© aucune r√©f√©rence), mais o√π des interactions et des changements d'√©tat inattendus se produisent dans des endroits √©loign√©s du syst√®me, dont nous n'avions aucune id√©e. Cela ne peut se produire que par le biais de l'√©tat global.

Imaginez que vous rejoigniez une √©quipe de d√©veloppeurs sur un projet dot√© d'une base de code vaste et mature. Votre nouveau responsable vous demande d'impl√©menter une nouvelle fonctionnalit√© et, en tant que bon d√©veloppeur, vous commencez par √©crire un test. Mais comme vous √™tes nouveau dans le projet, vous effectuez de nombreux tests exploratoires du type "que se passe-t-il si j'appelle cette m√©thode". Et vous essayez d'√©crire le test suivant :

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // votre num√©ro de carte
	$cc->charge(100);
}
```

Vous ex√©cutez le code, peut-√™tre plusieurs fois, et apr√®s un certain temps, vous remarquez des notifications de votre banque sur votre mobile indiquant qu'√† chaque ex√©cution, 100 dollars ont √©t√© d√©bit√©s de votre carte de cr√©dit ü§¶‚Äç‚ôÇÔ∏è

Comment diable le test a-t-il pu provoquer un d√©bit r√©el d'argent ? Op√©rer avec une carte de cr√©dit n'est pas facile. Vous devez communiquer avec un service web tiers, vous devez conna√Ætre l'URL de ce service web, vous devez vous connecter, etc.
Aucune de ces informations n'est contenue dans le test. Pire encore, vous ne savez m√™me pas o√π ces informations sont pr√©sentes, et donc vous ne savez pas non plus comment mocker les d√©pendances externes pour que chaque ex√©cution n'entra√Æne pas √† nouveau le d√©bit de 100 dollars. Et comment, en tant que nouveau d√©veloppeur, auriez-vous pu savoir que ce que vous alliez faire vous rendrait 100 dollars plus pauvre ?

C'est l'action fant√¥me √† distance !

Il ne vous reste plus qu'√† fouiller longuement dans de nombreux codes sources, √† interroger des coll√®gues plus √¢g√©s et plus exp√©riment√©s, avant de comprendre comment fonctionnent les liens dans le projet.
Cela est d√ª au fait qu'en regardant l'interface de la classe `CreditCard`, on ne peut pas d√©terminer l'√©tat global qu'il faut initialiser. M√™me un coup d'≈ìil au code source de la classe ne vous dira pas quelle m√©thode d'initialisation appeler. Au mieux, vous pouvez trouver une variable globale √† laquelle on acc√®de et essayer d'en d√©duire comment l'initialiser.

Les classes d'un tel projet sont des menteurs pathologiques. La carte de cr√©dit pr√©tend qu'il suffit de l'instancier et d'appeler la m√©thode `charge()`. En secret, elle coop√®re avec une autre classe `PaymentGateway`, qui repr√©sente la passerelle de paiement. Son interface dit √©galement qu'elle peut √™tre initialis√©e s√©par√©ment, mais en r√©alit√©, elle extrait les informations d'identification d'un fichier de configuration, etc.
Pour les d√©veloppeurs qui ont √©crit ce code, il est clair que `CreditCard` a besoin de `PaymentGateway`. Ils ont √©crit le code de cette mani√®re. Mais pour quiconque est nouveau dans le projet, c'est un myst√®re complet et cela entrave l'apprentissage.

Comment corriger la situation ? Facilement. **Laissez l'API d√©clarer les d√©pendances.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Remarquez comment les interconnexions √† l'int√©rieur du code deviennent soudainement √©videntes. Le fait que la m√©thode `charge()` d√©clare avoir besoin de `PaymentGateway` signifie que vous n'avez pas besoin de demander √† qui que ce soit comment le code est interconnect√©. Vous savez que vous devez cr√©er son instance, et lorsque vous essayez de le faire, vous r√©alisez que vous devez fournir les param√®tres d'acc√®s. Sans eux, le code ne pourrait m√™me pas s'ex√©cuter.

Et surtout, vous pouvez maintenant mocker la passerelle de paiement, de sorte que 100 dollars ne vous seront pas factur√©s √† chaque ex√©cution du test.

L'√©tat global fait que vos objets peuvent acc√©der secr√®tement √† des choses qui ne sont pas d√©clar√©es dans leur API et, par cons√©quent, font de vos API des menteurs pathologiques.

Vous n'y avez peut-√™tre pas pens√© de cette fa√ßon auparavant, mais chaque fois que vous utilisez l'√©tat global, vous cr√©ez des canaux de communication secrets sans fil. L'action fant√¥me √† distance oblige les d√©veloppeurs √† lire chaque ligne de code pour comprendre les interactions potentielles, r√©duit la productivit√© des d√©veloppeurs et embrouille les nouveaux membres de l'√©quipe.
Si c'est vous qui avez cr√©√© le code, vous connaissez les d√©pendances r√©elles, mais quiconque viendra apr√®s vous sera d√©sempar√©.

N'√©crivez pas de code qui utilise l'√©tat global, pr√©f√©rez le passage de d√©pendances. C'est-√†-dire l'injection de d√©pendances.


Fragilit√© de l'√©tat global
--------------------------

Dans le code qui utilise l'√©tat global et les singletons, on n'est jamais s√ªr de quand et qui a modifi√© cet √©tat. Ce risque appara√Æt d√®s l'initialisation. Le code suivant est cens√© cr√©er une connexion √† la base de donn√©es et initialiser la passerelle de paiement, mais il l√®ve constamment une exception et trouver la cause est extr√™mement long :

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Vous devez parcourir le code en d√©tail pour d√©couvrir que l'objet `PaymentGateway` acc√®de sans fil √† d'autres objets, dont certains n√©cessitent une connexion √† la base de donn√©es. Il est donc n√©cessaire d'initialiser la base de donn√©es avant `PaymentGateway`. Cependant, l'√©cran de fum√©e de l'√©tat global vous le cache. Combien de temps auriez-vous gagn√© si les API des classes individuelles ne mentaient pas et d√©claraient leurs d√©pendances ?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Un probl√®me similaire se pose lors de l'utilisation d'un acc√®s global √† la connexion √† la base de donn√©es :

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Lors de l'appel de la m√©thode `save()`, on n'est pas certain que la connexion √† la base de donn√©es a d√©j√† √©t√© cr√©√©e et qui est responsable de sa cr√©ation. Si nous voulons, par exemple, modifier la connexion √† la base de donn√©es √† la vol√©e, par exemple pour des tests, nous devrions probablement cr√©er d'autres m√©thodes comme `DB::reconnect(...)` ou `DB::reconnectForTest()`.

Consid√©rons un exemple :

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

O√π avons-nous la certitude que lors de l'appel de `$article->save()`, la base de donn√©es de test est r√©ellement utilis√©e ? Et si la m√©thode `Foo::doSomething()` avait modifi√© la connexion globale √† la base de donn√©es ? Pour le savoir, nous devrions examiner le code source de la classe `Foo` et probablement de nombreuses autres classes. Cette approche ne fournirait cependant qu'une r√©ponse √† court terme, car la situation pourrait changer √† l'avenir.

Et si nous d√©placions la connexion √† la base de donn√©es dans une variable statique √† l'int√©rieur de la classe `Article` ?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Cela ne change absolument rien. Le probl√®me est l'√©tat global et peu importe dans quelle classe il se cache. Dans ce cas, comme dans le pr√©c√©dent, nous n'avons aucune id√©e, lors de l'appel de la m√©thode `$article->save()`, dans quelle base de donn√©es l'√©criture aura lieu. N'importe qui √† l'autre bout de l'application aurait pu modifier la base de donn√©es √† tout moment en utilisant `Article::setDb()`. Sous notre nez.

L'√©tat global rend notre application **extr√™mement fragile**.

Il existe cependant un moyen simple de traiter ce probl√®me. Il suffit de laisser l'API d√©clarer les d√©pendances, ce qui garantit le bon fonctionnement.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Gr√¢ce √† cette approche, la crainte de modifications cach√©es et inattendues de la connexion √† la base de donn√©es dispara√Æt. Nous avons maintenant la certitude de l'endroit o√π l'article est enregistr√© et aucune modification du code √† l'int√©rieur d'une autre classe non li√©e ne peut plus changer la situation. Le code n'est plus fragile, mais stable.

N'√©crivez pas de code qui utilise l'√©tat global, pr√©f√©rez le passage de d√©pendances. C'est-√†-dire l'injection de d√©pendances.


Singleton
---------

Le singleton est un patron de conception qui, selon la ["d√©finition":https://en.wikipedia.org/wiki/Singleton_pattern] de la c√©l√®bre publication du Gang of Four, limite une classe √† une seule instance et offre un acc√®s global √† celle-ci. L'impl√©mentation de ce patron ressemble g√©n√©ralement au code suivant :

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// et d'autres m√©thodes remplissant les fonctions de la classe donn√©e
}
```

Malheureusement, le singleton introduit un √©tat global dans l'application. Et comme nous l'avons montr√© ci-dessus, l'√©tat global est ind√©sirable. C'est pourquoi le singleton est consid√©r√© comme un anti-patron.

N'utilisez pas de singletons dans votre code et remplacez-les par d'autres m√©canismes. Vous n'avez vraiment pas besoin de singletons. Cependant, si vous devez garantir l'existence d'une seule instance d'une classe pour toute l'application, laissez cela au [conteneur DI |container].
Cr√©ez ainsi un singleton d'application, c'est-√†-dire un service. De cette fa√ßon, la classe cessera de s'occuper d'assurer sa propre unicit√© (c'est-√†-dire qu'elle n'aura pas de m√©thode `getInstance()` ni de variable statique) et ne remplira que ses fonctions. Elle cessera ainsi de violer le principe de responsabilit√© unique.


√âtat global versus tests
------------------------

Lors de l'√©criture de tests, nous supposons que chaque test est une unit√© isol√©e et qu'aucun √©tat externe n'y entre. Et aucun √©tat ne quitte les tests. Une fois le test termin√©, tout l'√©tat li√© au test devrait √™tre automatiquement supprim√© par le garbage collector. Gr√¢ce √† cela, les tests sont isol√©s. Nous pouvons donc ex√©cuter les tests dans n'importe quel ordre.

Cependant, s'il y a des √©tats globaux/singletons, toutes ces hypoth√®ses agr√©ables s'effondrent. L'√©tat peut entrer et sortir du test. Soudain, l'ordre des tests peut avoir de l'importance.

Pour pouvoir tester les singletons, les d√©veloppeurs doivent souvent assouplir leurs propri√©t√©s, par exemple en permettant de remplacer l'instance par une autre. De telles solutions sont au mieux des hacks qui cr√©ent un code difficile √† maintenir et √† comprendre. Chaque test ou m√©thode `tearDown()` qui affecte un √©tat global doit annuler ces changements.

L'√©tat global est le plus grand casse-t√™te des tests unitaires !

Comment corriger la situation ? Facilement. N'√©crivez pas de code qui utilise des singletons, pr√©f√©rez le passage de d√©pendances. C'est-√†-dire l'injection de d√©pendances.


Constantes globales
-------------------

L'√©tat global ne se limite pas √† l'utilisation de singletons et de variables statiques, mais peut √©galement concerner les constantes globales.

Les constantes dont la valeur ne nous apporte aucune information nouvelle (`M_PI`) ou utile (`PREG_BACKTRACK_LIMIT_ERROR`) sont clairement acceptables.
En revanche, les constantes qui servent de moyen de passer *sans fil* des informations √† l'int√©rieur du code ne sont rien d'autre qu'une d√©pendance cach√©e. Comme `LOG_FILE` dans l'exemple suivant.
L'utilisation de la constante `FILE_APPEND` est tout √† fait correcte.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Dans ce cas, nous devrions d√©clarer un param√®tre dans le constructeur de la classe `Foo` pour qu'il fasse partie de l'API :

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Maintenant, nous pouvons passer l'information sur le chemin du fichier journal et la modifier facilement selon les besoins, ce qui facilite les tests et la maintenance du code.


Fonctions globales et m√©thodes statiques
----------------------------------------

Nous tenons √† souligner que l'utilisation de m√©thodes statiques et de fonctions globales n'est pas probl√©matique en soi. Nous avons expliqu√© pourquoi l'utilisation de `DB::insert()` et de m√©thodes similaires est inappropri√©e, mais il s'agissait toujours uniquement d'une question d'√©tat global stock√© dans une variable statique. La m√©thode `DB::insert()` n√©cessite l'existence d'une variable statique car la connexion √† la base de donn√©es y est stock√©e. Sans cette variable, il serait impossible d'impl√©menter la m√©thode.

L'utilisation de m√©thodes statiques et de fonctions d√©terministes, telles que `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` et bien d'autres, est parfaitement conforme √† l'injection de d√©pendances. Ces fonctions renvoient toujours les m√™mes r√©sultats pour les m√™mes param√®tres d'entr√©e et sont donc pr√©visibles. Elles n'utilisent aucun √©tat global.

Il existe cependant des fonctions en PHP qui ne sont pas d√©terministes. Parmi elles, par exemple, la fonction `htmlspecialchars()`. Son troisi√®me param√®tre `$encoding`, s'il n'est pas sp√©cifi√©, prend par d√©faut la valeur de l'option de configuration `ini_get('default_charset')`. C'est pourquoi il est recommand√© de toujours sp√©cifier ce param√®tre et d'√©viter ainsi un comportement √©ventuellement impr√©visible de la fonction. Nette le fait syst√©matiquement.

Certaines fonctions, telles que `strtolower()`, `strtoupper()` et similaires, se comportaient de mani√®re non d√©terministe dans un pass√© r√©cent et d√©pendaient du param√®tre `setlocale()`. Cela causait de nombreuses complications, le plus souvent lors du travail avec la langue turque.
Celle-ci distingue en effet les lettres `I` majuscules et minuscules avec et sans point. Ainsi, `strtolower('I')` renvoyait le caract√®re `ƒ±` et `strtoupper('i')` le caract√®re `ƒ∞`, ce qui entra√Ænait l'apparition de nombreuses erreurs myst√©rieuses dans les applications.
Ce probl√®me a cependant √©t√© corrig√© dans la version PHP 8.2 et les fonctions ne d√©pendent plus de la locale.

C'est un bel exemple de la fa√ßon dont l'√©tat global a tourment√© des milliers de d√©veloppeurs dans le monde entier. La solution a √©t√© de le remplacer par l'injection de d√©pendances.


Quand est-il possible d'utiliser l'√©tat global ?
------------------------------------------------

Il existe certaines situations sp√©cifiques o√π il est possible d'utiliser l'√©tat global. Par exemple, lors du d√©bogage de code, lorsque vous devez afficher la valeur d'une variable ou mesurer la dur√©e d'une certaine partie du programme. Dans de tels cas, qui concernent des actions temporaires qui seront ult√©rieurement supprim√©es du code, il est l√©gitime d'utiliser un dumper ou un chronom√®tre globalement disponible. Ces outils ne font en effet pas partie de la conception du code.

Un autre exemple sont les fonctions pour travailler avec les expressions r√©guli√®res `preg_*`, qui stockent en interne les expressions r√©guli√®res compil√©es dans un cache statique en m√©moire. Ainsi, lorsque vous appelez la m√™me expression r√©guli√®re plusieurs fois √† diff√©rents endroits du code, elle n'est compil√©e qu'une seule fois. Le cache √©conomise les performances et est en m√™me temps totalement invisible pour l'utilisateur, c'est pourquoi une telle utilisation peut √™tre consid√©r√©e comme l√©gitime.


R√©sum√©
------

Nous avons discut√© des raisons pour lesquelles il est judicieux de :

1) Supprimer toutes les variables statiques du code
2) D√©clarer les d√©pendances
3) Et utiliser l'injection de d√©pendances

Lorsque vous r√©fl√©chissez √† la conception du code, gardez √† l'esprit que chaque `static $foo` repr√©sente un probl√®me. Pour que votre code soit un environnement respectant la DI, il est essentiel d'√©radiquer compl√®tement l'√©tat global et de le remplacer par l'injection de d√©pendances.

Au cours de ce processus, vous d√©couvrirez peut-√™tre qu'il est n√©cessaire de diviser une classe car elle a plus d'une responsabilit√©. N'ayez pas peur de cela ; visez le principe de responsabilit√© unique.

*Je tiens √† remercier Mi≈°ko Hevery, dont les articles, tels que [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], sont √† la base de ce chapitre.*
