Estado global y Singletons
**************************

.[perex]
Advertencia: Las siguientes construcciones son s√≠ntomas de un c√≥digo mal dise√±ado:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` o `static::$var`

¬øEncuentra alguna de estas construcciones en su c√≥digo? Si es as√≠, tienes la oportunidad de mejorarlo. Podr√≠a pensar que se trata de construcciones comunes, vistas a menudo en soluciones de ejemplo de diversas bibliotecas y frameworks. Si es as√≠, el dise√±o de su c√≥digo es defectuoso.

No estamos hablando de una pureza acad√©mica. Todas estas construcciones tienen una cosa en com√∫n: utilizan estado global. Y esto tiene un impacto destructivo en la calidad del c√≥digo. Las clases enga√±an sobre sus dependencias. El c√≥digo se vuelve impredecible. Confunde a los desarrolladores y reduce su eficiencia.

En este cap√≠tulo explicaremos por qu√© ocurre esto y c√≥mo evitar el estado global.


Interconexi√≥n global .[#toc-global-interlinking]
------------------------------------------------

En un mundo ideal, un objeto s√≥lo deber√≠a comunicarse con objetos que [le hayan sido pasados directamente |passing-dependencies]. Si creo dos objetos `A` y `B` y nunca paso una referencia entre ellos, entonces ni `A` ni `B` pueden acceder o modificar el estado del otro. Esta es una propiedad muy deseable del c√≥digo. Es como tener una pila y una bombilla; la bombilla no se enciende hasta que la conectas a la pila con un cable.

Sin embargo, esto no es cierto para las variables globales (est√°ticas) o singletons. El objeto `A` podr√≠a acceder *inal√°mbricamente* al objeto `C` y modificarlo sin ning√∫n paso de referencia, llamando a `C::changeSomething()`. Si el objeto `B` tambi√©n accede al global `C`, entonces `A` y `B` pueden influirse mutuamente a trav√©s de `C`.

El uso de variables globales introduce una nueva forma de acoplamiento *inal√°mbrico* que no es visible externamente. Crea una cortina de humo que complica la comprensi√≥n y el uso del c√≥digo. Para comprender realmente las dependencias, los desarrolladores tienen que leer cada l√≠nea del c√≥digo fuente, en lugar de limitarse a familiarizarse con las interfaces de las clases. Adem√°s, este enredo es totalmente innecesario. El estado global se utiliza porque es f√°cilmente accesible desde cualquier lugar y permite, por ejemplo, escribir en una base de datos a trav√©s de un m√©todo global (est√°tico) `DB::insert()`. Sin embargo, como veremos, el beneficio que ofrece es m√≠nimo, mientras que las complicaciones que introduce son graves.

.[note]
En t√©rminos de comportamiento, no hay diferencia entre una variable global y una est√°tica. Son igualmente perjudiciales.


La espeluznante acci√≥n a distancia .[#toc-the-spooky-action-at-a-distance]
--------------------------------------------------------------------------

"Espeluznante acci√≥n a distancia": as√≠ llam√≥ Albert Einstein en 1935 a un fen√≥meno de la f√≠sica cu√°ntica que le puso los pelos de punta.
Se trata del entrelazamiento cu√°ntico, cuya peculiaridad es que cuando se mide informaci√≥n sobre una part√≠cula, afecta inmediatamente a otra, aunque est√©n a millones de a√±os luz de distancia.
Lo que aparentemente viola la ley fundamental del universo de que nada puede viajar m√°s r√°pido que la luz.

En el mundo del software, podemos llamar "espeluznante acci√≥n a distancia" a una situaci√≥n en la que ejecutamos un proceso que creemos aislado (porque no le hemos pasado ninguna referencia), pero se producen interacciones inesperadas y cambios de estado en lugares distantes del sistema de los que no hemos informado al objeto. Esto s√≥lo puede ocurrir a trav√©s del estado global.

Imagina que te unes a un equipo de desarrollo de un proyecto que tiene una base de c√≥digo grande y madura. Tu nuevo jefe te pide que implementes una nueva funci√≥n y, como buen desarrollador, empiezas escribiendo una prueba. Pero como eres nuevo en el proyecto, haces muchas pruebas exploratorias del tipo "qu√© pasa si llamo a este m√©todo". Y tratas de escribir la siguiente prueba:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // su n√∫mero de tarjeta
	$cc->charge(100);
}
```

Ejecutas el c√≥digo, tal vez varias veces, y despu√©s de un tiempo notas notificaciones en tu tel√©fono del banco que cada vez que lo ejecutas, $100 fueron cargados a tu tarjeta de cr√©dito ü§¶‚Äç‚ôÇÔ∏è

¬øC√≥mo diablos pudo la prueba causar un cargo real? No es f√°cil operar con tarjeta de cr√©dito. Tienes que interactuar con un servicio web de terceros, tienes que conocer la URL de ese servicio web, tienes que iniciar sesi√≥n, etc.
Ninguna de estas informaciones se incluye en la prueba. Peor a√∫n, ni siquiera sabes d√≥nde est√° presente esta informaci√≥n y, por lo tanto, c√≥mo simular las dependencias externas para que cada ejecuci√≥n no suponga un nuevo cargo de 100 d√≥lares. Y como nuevo desarrollador, ¬øc√≥mo ibas a saber que lo que estabas a punto de hacer te llevar√≠a a ser 100 d√≥lares m√°s pobre?

¬°Eso es una acci√≥n espeluznante a distancia!

No te queda m√°s remedio que escarbar en un mont√≥n de c√≥digo fuente, preguntando a colegas m√°s veteranos y experimentados, hasta que entiendes c√≥mo funcionan las conexiones en el proyecto.
Esto se debe al hecho de que al mirar la interfaz de la clase `CreditCard`, no puedes determinar el estado global que necesita ser inicializado. Incluso mirando el c√≥digo fuente de la clase no le dir√° qu√© m√©todo de inicializaci√≥n para llamar. Como mucho, puedes encontrar la variable global a la que se accede e intentar adivinar c√≥mo inicializarla a partir de ah√≠.

Las clases de un proyecto as√≠ son mentirosas patol√≥gicas. La tarjeta de pago finge que puedes simplemente instanciarla y llamar al m√©todo `charge()`. Sin embargo, secretamente interact√∫a con otra clase, `PaymentGateway`. Incluso su interfaz dice que se puede inicializar de forma independiente, pero en realidad extrae credenciales de alg√∫n archivo de configuraci√≥n y dem√°s.
Est√° claro para los desarrolladores que escribieron este c√≥digo que `CreditCard` necesita a `PaymentGateway`. Ellos escribieron el c√≥digo de esta manera. Pero para cualquiera que sea nuevo en el proyecto, esto es un completo misterio y dificulta el aprendizaje.

¬øC√≥mo arreglar la situaci√≥n? F√°cil. **Deja que la API declare las dependencias.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Observa c√≥mo las relaciones dentro del c√≥digo son repentinamente obvias. Al declarar que el m√©todo `charge()` necesita `PaymentGateway`, no tienes que preguntar a nadie c√≥mo el c√≥digo es interdependiente. Sabes que tienes que crear una instancia del mismo, y cuando intentas hacerlo, te encuentras con el hecho de que tienes que suministrar par√°metros de acceso. Sin ellos, el c√≥digo ni siquiera se ejecutar√≠a.

Y lo m√°s importante, ahora puedes simular la pasarela de pago para que no te cobren 100 d√≥lares cada vez que ejecutes una prueba.

El estado global hace que tus objetos puedan acceder secretamente a cosas que no est√°n declaradas en sus APIs, y como resultado hace que tus APIs sean mentirosas patol√≥gicas.

Puede que no lo hayas pensado as√≠ antes, pero siempre que usas estado global, est√°s creando canales secretos de comunicaci√≥n inal√°mbrica. La espeluznante acci√≥n remota obliga a los desarrolladores a leer cada l√≠nea de c√≥digo para entender las posibles interacciones, reduce la productividad de los desarrolladores y confunde a los nuevos miembros del equipo.
Si eres t√∫ quien ha creado el c√≥digo, conoces las dependencias reales, pero cualquiera que venga despu√©s no tiene ni idea.

No escribas c√≥digo que utilice estado global, prefiere pasar dependencias. Es decir, inyecci√≥n de dependencias.


La fragilidad del Estado mundial .[#toc-brittleness-of-the-global-state]
------------------------------------------------------------------------

En c√≥digo que utiliza estado global y singletons, nunca se sabe con certeza cu√°ndo y por qui√©n ha cambiado ese estado. Este riesgo ya est√° presente en la inicializaci√≥n. El siguiente c√≥digo se supone que debe crear una conexi√≥n a la base de datos e inicializar la pasarela de pago, pero sigue lanzando una excepci√≥n y encontrar la causa es extremadamente tedioso:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Hay que revisar el c√≥digo en detalle para descubrir que el objeto `PaymentGateway` accede a otros objetos de forma inal√°mbrica, algunos de los cuales requieren una conexi√≥n a la base de datos. As√≠, debe inicializar la base de datos antes de `PaymentGateway`. Sin embargo, la cortina de humo del estado global te lo oculta. ¬øCu√°nto tiempo ahorrar√≠as si la API de cada clase no mintiera y declarara sus dependencias?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Un problema similar surge cuando se utiliza el acceso global a una conexi√≥n de base de datos:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Cuando se llama al m√©todo `save()`, no se sabe con certeza si ya se ha creado una conexi√≥n a la base de datos y qui√©n es el responsable de crearla. Por ejemplo, si quisi√©ramos cambiar la conexi√≥n a la base de datos sobre la marcha, quiz√°s con fines de prueba, probablemente tendr√≠amos que crear m√©todos adicionales como `DB::reconnect(...)` o `DB::reconnectForTest()`.

Veamos un ejemplo:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

¬øD√≥nde podemos estar seguros de que se est√° utilizando realmente la base de datos de prueba cuando se llama a `$article->save()`? ¬øQu√© pasar√≠a si el m√©todo `Foo::doSomething()` cambiara la conexi√≥n global a la base de datos? Para averiguarlo, tendr√≠amos que examinar el c√≥digo fuente de la clase `Foo` y probablemente de muchas otras clases. Sin embargo, este enfoque s√≥lo proporcionar√≠a una respuesta a corto plazo, ya que la situaci√≥n podr√≠a cambiar en el futuro.

¬øY si trasladamos la conexi√≥n a la base de datos a una variable est√°tica dentro de la clase `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Esto no cambia nada en absoluto. El problema es un estado global y no importa en qu√© clase se esconda. En este caso, como en el anterior, no tenemos ni idea de en qu√© base de datos se est√° escribiendo cuando se llama al m√©todo `$article->save()`. Cualquiera en el extremo distante de la aplicaci√≥n podr√≠a cambiar la base de datos en cualquier momento usando `Article::setDb()`. Bajo nuestras manos.

El estado global hace que nuestra aplicaci√≥n sea **extremadamente fr√°gil**.

Sin embargo, hay una forma sencilla de lidiar con este problema. Basta con hacer que la API declare dependencias para garantizar una funcionalidad adecuada.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Este enfoque elimina la preocupaci√≥n de cambios ocultos e inesperados en las conexiones a la base de datos. Ahora estamos seguros de d√≥nde se almacena el art√≠culo y ninguna modificaci√≥n de c√≥digo dentro de otra clase no relacionada puede cambiar la situaci√≥n nunca m√°s. El c√≥digo ya no es fr√°gil, sino estable.

No escribas c√≥digo que use estado global, prefiere pasar dependencias. Por lo tanto, la inyecci√≥n de dependencia.


Singleton .[#toc-singleton]
---------------------------

Singleton es un patr√≥n de dise√±o que, por [definici√≥n |https://en.wikipedia.org/wiki/Singleton_pattern] de la famosa publicaci√≥n Gang of Four, restringe una clase a una √∫nica instancia y ofrece acceso global a la misma. La implementaci√≥n de este patr√≥n suele parecerse al siguiente c√≥digo:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// y otros m√©todos que realizan las funciones de la clase
}
```

Desafortunadamente, el singleton introduce estado global en la aplicaci√≥n. Y como hemos demostrado anteriormente, el estado global no es deseable. Por eso el singleton se considera un antipatr√≥n.

No utilices singletons en tu c√≥digo y sustit√∫yelos por otros mecanismos. Realmente no necesitas singletons. Sin embargo, si necesitas garantizar la existencia de una √∫nica instancia de una clase para toda la aplicaci√≥n, d√©jalo en manos del [contenedor DI |container].
Por lo tanto, cree un singleton de aplicaci√≥n, o servicio. Esto evitar√° que la clase proporcione su propia unicidad (es decir, no tendr√° un m√©todo `getInstance()` y una variable est√°tica) y s√≥lo realizar√° sus funciones. As√≠, dejar√° de violar el principio de responsabilidad √∫nica.


Estado global frente a pruebas .[#toc-global-state-versus-tests]
----------------------------------------------------------------

Cuando escribimos pruebas, asumimos que cada prueba es una unidad aislada y que ning√∫n estado externo entra en ella. Y ning√∫n estado sale de las pruebas. Cuando una prueba se completa, cualquier estado asociado con la prueba debe ser eliminado autom√°ticamente por el recolector de basura. Esto hace que las pruebas est√©n aisladas. Por lo tanto, podemos ejecutar las pruebas en cualquier orden.

Sin embargo, si hay estados/singletons globales, todas estas suposiciones se vienen abajo. Un estado puede entrar y salir de una prueba. De repente, el orden de las pruebas puede ser importante.

Para probar los singletons, los desarrolladores a menudo tienen que relajar sus propiedades, tal vez permitiendo que una instancia sea sustituida por otra. Estas soluciones son, en el mejor de los casos, trucos que producen un c√≥digo dif√≠cil de mantener y comprender. Cualquier prueba o m√©todo `tearDown()` que afecte a cualquier estado global debe deshacer esos cambios.

El estado global es el mayor dolor de cabeza en las pruebas unitarias.

¬øC√≥mo arreglar la situaci√≥n? F√°cil. No escribas c√≥digo que utilice singletons, prefiere pasar dependencias. Es decir, inyecci√≥n de dependencias.


Constantes globales .[#toc-global-constants]
--------------------------------------------

El estado global no se limita al uso de singletons y variables est√°ticas, sino que tambi√©n puede aplicarse a las constantes globales.

Las constantes cuyo valor no nos proporciona ninguna informaci√≥n nueva (`M_PI`) o √∫til (`PREG_BACKTRACK_LIMIT_ERROR`) est√°n claramente bien.
Por el contrario, las constantes que sirven para pasar informaci√≥n de forma *inal√°mbrica* dentro del c√≥digo no son m√°s que una dependencia oculta. Como `LOG_FILE` en el siguiente ejemplo.
Utilizar la constante `FILE_APPEND` es perfectamente correcto.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

En este caso, debemos declarar el par√°metro en el constructor de la clase `Foo` para que forme parte de la API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ahora podemos pasar informaci√≥n sobre la ruta al archivo de registro y cambiarla f√°cilmente seg√∫n sea necesario, lo que facilita las pruebas y el mantenimiento del c√≥digo.


Funciones globales y m√©todos est√°ticos .[#toc-global-functions-and-static-methods]
----------------------------------------------------------------------------------

Queremos enfatizar que el uso de m√©todos est√°ticos y funciones globales no es problem√°tico en s√≠ mismo. Hemos explicado lo inapropiado de usar `DB::insert()` y m√©todos similares, pero siempre ha sido una cuesti√≥n de estado global almacenado en una variable est√°tica. El m√©todo `DB::insert()` requiere la existencia de una variable est√°tica porque almacena la conexi√≥n a la base de datos. Sin esta variable, ser√≠a imposible implementar el m√©todo.

El uso de m√©todos y funciones est√°ticas deterministas, como `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` y muchos otros, es perfectamente coherente con la inyecci√≥n de dependencias. Estas funciones siempre devuelven los mismos resultados a partir de los mismos par√°metros de entrada y, por lo tanto, son predecibles. No utilizan ning√∫n estado global.

Sin embargo, hay funciones en PHP que no son deterministas. Estas incluyen, por ejemplo, la funci√≥n `htmlspecialchars()`. Su tercer par√°metro, `$encoding`, si no se especifica, toma por defecto el valor de la opci√≥n de configuraci√≥n `ini_get('default_charset')`. Por lo tanto, se recomienda especificar siempre este par√°metro para evitar un posible comportamiento impredecible de la funci√≥n. Nette lo hace sistem√°ticamente.

Algunas funciones, como `strtolower()`, `strtoupper()`, y similares, han tenido un comportamiento no determinista en el pasado reciente y han dependido del par√°metro `setlocale()`. Esto causaba muchas complicaciones, sobre todo cuando se trabajaba con el idioma turco.
Esto se debe a que el idioma turco distingue entre may√∫sculas y min√∫sculas `I` con y sin punto. As√≠ que `strtolower('I')` devolv√≠a el car√°cter `ƒ±` y `strtoupper('i')` devolv√≠a el car√°cter `ƒ∞`, lo que provocaba en las aplicaciones una serie de misteriosos errores.
Sin embargo, este problema se solucion√≥ en la versi√≥n 8.2 de PHP y las funciones ya no dependen de la configuraci√≥n regional.

Este es un buen ejemplo de c√≥mo el estado global ha plagado a miles de desarrolladores en todo el mundo. La soluci√≥n fue reemplazarlo con inyecci√≥n de dependencia.


¬øCu√°ndo es posible utilizar el Estado Global? .[#toc-when-is-it-possible-to-use-global-state]
---------------------------------------------------------------------------------------------

Hay ciertas situaciones espec√≠ficas en las que es posible utilizar el estado global. Por ejemplo, cuando se depura c√≥digo y se necesita volcar el valor de una variable o medir la duraci√≥n de una parte concreta del programa. En estos casos, que se refieren a acciones temporales que m√°s tarde se eliminar√°n del c√≥digo, es leg√≠timo utilizar un dumper o un cron√≥metro disponibles globalmente. Estas herramientas no forman parte del dise√±o del c√≥digo.

Otro ejemplo son las funciones para trabajar con expresiones regulares `preg_*`, que almacenan internamente expresiones regulares compiladas en una cach√© est√°tica en memoria. Cuando se llama a la misma expresi√≥n regular varias veces en distintas partes del c√≥digo, s√≥lo se compila una vez. La cach√© ahorra rendimiento y adem√°s es completamente invisible para el usuario, por lo que este uso puede considerarse leg√≠timo.


Resumen .[#toc-summary]
-----------------------

Hemos demostrado por qu√© tiene sentido

1) Eliminar todas las variables est√°ticas del c√≥digo
2) Declarar dependencias
3) Y utilizar la inyecci√≥n de dependencias

Cuando contemples el dise√±o del c√≥digo, ten en cuenta que cada `static $foo` representa un problema. Para que tu c√≥digo sea un entorno respetuoso con DI, es esencial erradicar por completo el estado global y sustituirlo por la inyecci√≥n de dependencias.

Durante este proceso, puede que descubras que necesitas dividir una clase porque tiene m√°s de una responsabilidad. No te preocupes por ello; esfu√©rzate por el principio de una sola responsabilidad.

*Me gustar√≠a dar las gracias a Mi≈°ko Hevery, cuyos art√≠culos como [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] forman la base de este cap√≠tulo.*
