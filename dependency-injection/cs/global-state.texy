GlobÃ¡lnÃ­ stav a singletony
**************************

.[perex]
VarovÃ¡nÃ­: NÃ¡sledujÃ­cÃ­ konstrukce jsou pÅ™Ã­znakem Å¡patnÃ©ho nÃ¡vrhu kÃ³du:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` nebo `static::$var`

VyskytujÃ­ se nÄ›kterÃ© z tÄ›chto konstrukcÃ­ ve vaÅ¡em kÃ³du? Pak mÃ¡te pÅ™Ã­leÅ¾itost k zlepÅ¡enÃ­. MoÅ¾nÃ¡ si Å™Ã­kÃ¡te, Å¾e jde o bÄ›Å¾nÃ© konstrukce, kterÃ© vÃ­dÃ¡me i v ukÃ¡zkovÃ½ch Å™eÅ¡enÃ­ch rÅ¯znÃ½ch knihoven a frameworkÅ¯.
BohuÅ¾el, i pÅ™esto jsou jasnÃ½m indikÃ¡torem Å¡patnÃ©ho nÃ¡vrhu. Spojuje je jedno: pouÅ¾Ã­vÃ¡nÃ­ globÃ¡lnÃ­ho stavu.

NynÃ­ rozhodnÄ› nemluvÃ­me o jakÃ©si akademickÃ© ÄistotÄ›. PouÅ¾Ã­vÃ¡nÃ­ globÃ¡lnÃ­ho stavu a singletonÅ¯ mÃ¡ destruktivnÃ­ dopady na kvalitu kÃ³du. Jeho chovÃ¡nÃ­ se stÃ¡vÃ¡ nepÅ™edvÃ­datelnÃ©, sniÅ¾uje produktivitu vÃ½vojÃ¡Å™Å¯ a nutÃ­ rozhranÃ­ tÅ™Ã­d lhÃ¡t o svÃ½ch skuteÄnÃ½ch zÃ¡vislostech. CoÅ¾ mate programÃ¡tory.

V tÃ©to kapitole si ukÃ¡Å¾eme, jak je to moÅ¾nÃ©.


GlobÃ¡lnÃ­ provÃ¡zÃ¡nÃ­
------------------

ZÃ¡kladnÃ­ problÃ©m globÃ¡lnÃ­ho stavu spoÄÃ­vÃ¡ v tom, Å¾e je globÃ¡lnÄ› pÅ™Ã­stupnÃ½. DÃ­ky tomu je tÅ™eba moÅ¾nÃ© zapsat do databÃ¡ze pÅ™es globÃ¡lnÃ­ (statickou) metodu `DB::insert()`.
V ideÃ¡lnÃ­m svÄ›tÄ› by mÄ›l bÃ½t objekt schopen komunikovat pouze s jinÃ½mi objekty, kterÃ© mu byly [pÅ™Ã­mo pÅ™edÃ¡ny |passing-dependencies].
Pokud vytvoÅ™Ã­m dva objekty `A` a `B` a nikdy nepÅ™edÃ¡m referenci z `A` na `B`, pak se ani `A`, ani `B` nemohou dostat k druhÃ©mu objektu nebo zmÄ›nit jeho stav.
To je velmi Å¾Ã¡doucÃ­ vlastnost kÃ³du. Je to podobnÃ©, jako kdyÅ¾ mÃ¡te baterii a Å¾Ã¡rovku; Å¾Ã¡rovka nebude svÃ­tit, dokud je nepropojÃ­te drÃ¡tem.

To ale neplatÃ­ u globÃ¡lnÃ­ch (statickÃ½ch) promÄ›nnÃ½ch nebo singletonÅ¯. Objekt `A` by se mohl *bezdrÃ¡tovÄ›* dostat k objektu `C` a modifikovat jej bez jakÃ©hokoliv pÅ™edÃ¡nÃ­ reference, tÃ­m, Å¾e zavolÃ¡ `C::changeSomething()`.
Pokud se objekt `B` takÃ© chopÃ­ globÃ¡lnÃ­ho `C`, pak se `A` a `B` mohou navzÃ¡jem ovlivÅˆovat prostÅ™ednictvÃ­m `C`.

PouÅ¾itÃ­ globÃ¡lnÃ­ch promÄ›nnÃ½ch do systÃ©mu vnÃ¡Å¡Ã­ novou formu *bezdrÃ¡tovÃ©* provÃ¡zanosti, kterÃ¡ nenÃ­ zvenÄÃ­ vidÄ›t.
VytvÃ¡Å™Ã­ kouÅ™ovou clonu komplikujÃ­cÃ­ pochopenÃ­ a pouÅ¾Ã­vÃ¡nÃ­ kÃ³du.
Aby vÃ½vojÃ¡Å™i zÃ¡vislostem skuteÄnÄ› porozumÄ›li, musÃ­ pÅ™eÄÃ­st kaÅ¾dÃ½ Å™Ã¡dek zdrojovÃ©ho kÃ³du. MÃ­sto pouhÃ©ho seznÃ¡menÃ­ se s rozhranÃ­m tÅ™Ã­d.
Jde navÃ­c o provÃ¡zanost zcela zbyteÄnou.

.[note]
Z hlediska chovÃ¡nÃ­ nenÃ­ rozdÃ­l mezi globÃ¡lnÃ­ a statickou promÄ›nnou. Jsou stejnÄ› Å¡kodlivÃ©.


StraÅ¡idelnÃ© pÅ¯sobenÃ­ na dÃ¡lku
-----------------------------

"StraÅ¡idelnÃ© pÅ¯sobenÃ­ na dÃ¡lku" - tak slavnÄ› nazval roku 1935 Albert Einstein jev v kvantovÃ© fyzice, kterÃ½ mu nahÃ¡nÄ›l husÃ­ kÅ¯Å¾i.
JednÃ¡ se o kvantovÃ© propojenÃ­, jehoÅ¾ zvlÃ¡Å¡tnostÃ­ je, Å¾e kdyÅ¾ zmÄ›Å™Ã­te informaci o jednÃ© ÄÃ¡stici, okamÅ¾itÄ› tÃ­m ovlivnÃ­te ÄÃ¡stici druhou, i kdyÅ¾ jsou od sebe vzdÃ¡leny miliony svÄ›telnÃ½ch let.
CoÅ¾ zdÃ¡nlivÄ› poruÅ¡uje zÃ¡kladnÃ­ zÃ¡kon vesmÃ­ru, Å¾e nic se nemÅ¯Å¾e Å¡Ã­Å™it rychleji neÅ¾ svÄ›tlo.

V softwarovÃ©m svÄ›tÄ› mÅ¯Å¾eme "straÅ¡idelnÃ½m pÅ¯sobenÃ­ na dÃ¡lku" nazvat situaci, kdy spustÃ­me nÄ›jakÃ½ proces, o kterÃ©m se domnÃ­vÃ¡me, Å¾e je izolovanÃ½ (protoÅ¾e jsme mu nepÅ™edali Å¾Ã¡dnÃ© reference), ale ve vzdÃ¡lenÃ½ch mÃ­stech systÃ©mu dojde k neoÄekÃ¡vanÃ½m interakcÃ­m a zmÄ›nÃ¡m stavu, o kterÃ½ch jsme nemÄ›li tuÅ¡enÃ­. K tomu mÅ¯Å¾e dojÃ­t pouze prostÅ™ednictvÃ­m globÃ¡lnÃ­ho stavu.

PÅ™edstavte si, Å¾e se pÅ™ipojÃ­te k tÃ½mu vÃ½vojÃ¡Å™Å¯ projektu, kterÃ½ mÃ¡ rozsÃ¡hlou vyspÄ›lou kÃ³dovou zÃ¡kladnu. VÃ¡Å¡ novÃ½ vedoucÃ­ vÃ¡s poÅ¾Ã¡dÃ¡ o implementaci novÃ© funkce a vy jako sprÃ¡vnÃ½ vÃ½vojÃ¡Å™ zaÄnete psanÃ­m testu. ProtoÅ¾e jste ale v projektu novÃ­, dÄ›lÃ¡te spoustu prÅ¯zkumnÃ½ch testÅ¯ typu "co se stane, kdyÅ¾ zavolÃ¡m tuto metodu". A zkusÃ­te napsat nÃ¡sledujÃ­cÃ­ test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // ÄÃ­slo vaÅ¡Ã­ karty
	$cc->charge(100);
}
```

SpustÃ­te kÃ³d, tÅ™eba nÄ›kolikrÃ¡t, a po nÄ›jakÃ© dobÄ› si vÅ¡imnete na mobilu notifikacÃ­ z banky, Å¾e pÅ™i kaÅ¾dÃ©m spuÅ¡tÄ›nÃ­ se strhlo 100 dolarÅ¯ z vaÅ¡Ã­ platebnÃ­ karty ğŸ¤¦â€â™‚ï¸

Jak proboha mohl test zpÅ¯sobit skuteÄnÃ© strÅ¾enÃ­ penÄ›z? Operovat s platebnÃ­ kartou nenÃ­ snadnÃ©. MusÃ­te komunikovat s webovou sluÅ¾bou tÅ™etÃ­ strany, musÃ­te znÃ¡t URL tÃ©to webovÃ© sluÅ¾by, musÃ­te se pÅ™ihlÃ¡sit a tak dÃ¡le.
Å½Ã¡dnÃ¡ z tÄ›chto informacÃ­ nenÃ­ v testu obsaÅ¾ena. Ba co hÅ¯Å™, ani nevÃ­te, kde jsou tyto informace pÅ™Ã­tomny, a tedy ani jak mockovat externÃ­ zÃ¡vislosti, aby kaÅ¾dÃ© spuÅ¡tÄ›nÃ­ nevedlo k tomu, Å¾e se znovu strhne 100 dolarÅ¯. A jak jste mÄ›l jako novÃ½ vÃ½vojÃ¡Å™ vÄ›dÄ›t, Å¾e to, co se chystÃ¡te udÄ›lat, povede k tomu, Å¾e budete o 100 dolarÅ¯ chudÅ¡Ã­?

To je straÅ¡idelnÃ© pÅ¯sobenÃ­ na dÃ¡lku!

NezbÃ½vÃ¡ vÃ¡m, neÅ¾ se dlouze hrabat ve spoustÄ› zdrojovÃ½ch kÃ³dÅ¯, ptÃ¡t se starÅ¡Ã­ch a zkuÅ¡enÄ›jÅ¡Ã­ch kolegÅ¯, neÅ¾ pochopÃ­te, jak vazby v projektu fungujÃ­.
To je zpÅ¯sobeno tÃ­m, Å¾e pÅ™i pohledu na rozhranÃ­ tÅ™Ã­dy `CreditCard` nelze zjistit globÃ¡lnÃ­ stav, kterÃ½ je tÅ™eba inicializovat. Dokonce ani pohled do zdrojovÃ©ho kÃ³du tÅ™Ã­dy vÃ¡m neprozradÃ­, kterou inicializaÄnÃ­ metodu mÃ¡te zavolat. V nejlepÅ¡Ã­m pÅ™Ã­padÄ› mÅ¯Å¾ete najÃ­t globÃ¡lnÃ­ promÄ›nnou, ke kterÃ© se pÅ™istupuje, a z nÃ­ se pokusit odhadnout, jak ji inicializovat.

TÅ™Ã­dy v takovÃ©m projektu jsou patologickÃ½mi lhÃ¡Å™i. PlatebnÃ­ karta pÅ™edstÃ­rÃ¡, Å¾e ji staÄÃ­ instancovat a zavolat metodu `charge()`. Ve skrytu vÅ¡ak spolupracuje s jinou tÅ™Ã­dou `PaymentGateway`, kterÃ¡ pÅ™edstavuje platebnÃ­ brÃ¡nu. I jejÃ­ rozhranÃ­ Å™Ã­kÃ¡, Å¾e ji lze inicializovat samostatnÄ›, ale ve skuteÄnosti si vytÃ¡hne credentials z nÄ›jakÃ©ho konfiguraÄnÃ­ho souboru a tak dÃ¡le.
VÃ½vojÃ¡Å™Å¯m, kteÅ™Ã­ tento kÃ³d napsali, je jasnÃ©, Å¾e `CreditCard` potÅ™ebuje `PaymentGateway`. Napsali kÃ³d tÃ­mto zpÅ¯sobem. Ale pro kaÅ¾dÃ©ho, kdo je v projektu novÃ½, je to naprostÃ¡ zÃ¡hada a brÃ¡nÃ­ to uÄenÃ­.

Jak situaci opravit? Snadno. **Nechte API deklarovat zÃ¡vislosti.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

VÅ¡imnÄ›te si, jak jsou najednou provÃ¡zanosti uvnitÅ™ kÃ³du zÅ™ejmÃ©. TÃ­m, Å¾e metoda `charge()` deklaruje, Å¾e potÅ™ebuje `PaymentGateway`, nemusÃ­te se na to, jak je kÃ³d provÃ¡zanÃ½, nikoho ptÃ¡t. VÃ­te, Å¾e musÃ­te vytvoÅ™it jejÃ­ instanci, a kdyÅ¾ se o to pokusÃ­te, narazÃ­te na to, Å¾e musÃ­te dodat pÅ™Ã­stupovÃ© parametry. Bez nich by kÃ³d neÅ¡el ani spustit.

A hlavnÄ› nynÃ­ mÅ¯Å¾ete platebnÃ­ brÃ¡nu mockovat, takÅ¾e se vÃ¡m pÅ™i kaÅ¾dÃ©m spuÅ¡tÄ›nÃ­ testu nebude ÃºÄtovat 100 dolarÅ¯.

GlobÃ¡lnÃ­ stav zpÅ¯sobuje, Å¾e se vaÅ¡e objekty mohou tajnÄ› dostat k vÄ›cem, kterÃ© nejsou deklarovÃ¡ny v jejich API, a v dÅ¯sledku toho dÄ›lajÃ­ z vaÅ¡ich API patologickÃ© lhÃ¡Å™e.

MoÅ¾nÃ¡ jste o tom dÅ™Ã­ve takto nepÅ™emÃ½Å¡leli, ale kdykoli pouÅ¾Ã­vÃ¡te globÃ¡lnÃ­ stav, vytvÃ¡Å™Ã­te tajnÃ© bezdrÃ¡tovÃ© komunikaÄnÃ­ kanÃ¡ly. StraÅ¡idelnÃ¡ akce na dÃ¡lku nutÃ­ vÃ½vojÃ¡Å™e ÄÃ­st kaÅ¾dÃ½ Å™Ã¡dek kÃ³du, aby pochopili potenciÃ¡lnÃ­ interakce, sniÅ¾uje produktivitu vÃ½vojÃ¡Å™Å¯ a mate novÃ© Äleny tÃ½mu.
Pokud jste vy ten, kdo kÃ³d vytvoÅ™il, znÃ¡te skuteÄnÃ© zÃ¡vislosti, ale kaÅ¾dÃ½, kdo pÅ™ijde po vÃ¡s, je bezradnÃ½.

NepiÅ¡te kÃ³d, kterÃ½ vyuÅ¾Ã­vÃ¡ globÃ¡lnÃ­ stav, dejte pÅ™ednost pÅ™edÃ¡vÃ¡nÃ­ zÃ¡vislostÃ­. Tedy dependency injection.


KÅ™ehkost globÃ¡lnÃ­ho stavu
-------------------------

V kÃ³du, kterÃ½ pouÅ¾Ã­vÃ¡ globÃ¡lnÃ­ stav a singletony, nenÃ­ nikdy jistÃ©, kdy a kdo tento stav zmÄ›nil. Toto riziko se objevuje jiÅ¾ pÅ™i inicializaci. NÃ¡sledujÃ­cÃ­ kÃ³d mÃ¡ vytvoÅ™it databÃ¡zovÃ© spojenÃ­ a inicializovat platebnÃ­ brÃ¡nu, avÅ¡ak neustÃ¡le vyhazuje vÃ½jimku a hledÃ¡nÃ­ pÅ™Ã­Äiny je nesmÃ­rnÄ› zdlouhavÃ©:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

MusÃ­te podrobnÄ› prochÃ¡zet kÃ³d, abyste zjistili, Å¾e objekt `PaymentGateway` pÅ™istupuje bezdrÃ¡tovÄ› k dalÅ¡Ã­m objektÅ¯m, z nichÅ¾ nÄ›kterÃ© vyÅ¾adujÃ­ databÃ¡zovÃ© pÅ™ipojenÃ­. Tedy je nutnÃ© inicializovat databÃ¡zi dÅ™Ã­ve neÅ¾ `PaymentGateway`. NicmÃ©nÄ› kouÅ™ovÃ¡ clona globÃ¡lnÃ­ho stavu toto pÅ™ed vÃ¡mi skrÃ½vÃ¡. Kolik Äasu byste uÅ¡etÅ™ili, kdyby API jednotlivÃ½ch tÅ™Ã­d neklamalo a deklarovalo svÃ© zÃ¡vislosti?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

PodobnÃ½ problÃ©m se objevuje i pÅ™i pouÅ¾itÃ­ globÃ¡lnÃ­ho pÅ™Ã­stupu k databÃ¡zovÃ©mu spojenÃ­:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

PÅ™i volÃ¡nÃ­ metody `save()` nenÃ­ jistÃ©, zda bylo jiÅ¾ vytvoÅ™eno pÅ™ipojenÃ­ k databÃ¡zi a kdo nese odpovÄ›dnost za jeho vytvoÅ™enÃ­. Pokud chceme napÅ™Ã­klad mÄ›nit databÃ¡zovÃ© pÅ™ipojenÃ­ za bÄ›hu, tÅ™eba kvÅ¯li testÅ¯m, museli bychom nejspÃ­Å¡ vytvoÅ™it dalÅ¡Ã­ metody jako napÅ™Ã­klad `DB::reconnect(...)` nebo `DB::reconnectForTest()`.

ZvaÅ¾me pÅ™Ã­klad:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Kde mÃ¡me jistotu, Å¾e pÅ™i volÃ¡nÃ­ `$article->save()` se opravdu pouÅ¾Ã­vÃ¡ testovacÃ­ databÃ¡ze? Co kdyÅ¾ metoda `Foo::doSomething()` zmÄ›nila globÃ¡lnÃ­ databÃ¡zovÃ© pÅ™ipojenÃ­? Pro zjiÅ¡tÄ›nÃ­ bychom museli prozkoumat zdrojovÃ½ kÃ³d tÅ™Ã­dy `Foo` a pravdÄ›podobnÄ› i mnoha dalÅ¡Ã­ch tÅ™Ã­d. Tento pÅ™Ã­stup by vÅ¡ak pÅ™inesl pouze krÃ¡tkodobou odpovÄ›Ä, jelikoÅ¾ se situace mÅ¯Å¾e v budoucnu zmÄ›nit.

A co kdyÅ¾ pÅ™ipojenÃ­ k databÃ¡zi pÅ™esuneme do statickÃ© promÄ›nnÃ© uvnitÅ™ tÅ™Ã­dy `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db)
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

TÃ­m se vÅ¯bec nic nezmÄ›nilo. ProblÃ©mem je globÃ¡lnÃ­ stav a je ÃºplnÄ› jedno, ve kterÃ© tÅ™Ã­dÄ› se skrÃ½vÃ¡. V tomto pÅ™Ã­padÄ›, stejnÄ› jako v pÅ™edchozÃ­m, nemÃ¡me pÅ™i volÃ¡nÃ­ metody `$article->save()` Å¾Ã¡dnÃ© vodÃ­tko k tomu, do jakÃ© databÃ¡ze se zapÃ­Å¡e. Kdokoliv na druhÃ©m konci aplikace mohl kdykoliv pomocÃ­ `Article::setDb()` databÃ¡zi zmÄ›nit. NÃ¡m pod rukama.

GlobÃ¡lnÃ­mu stav ÄinnÃ­ naÅ¡i aplikaci **nesmÃ­rnÄ› kÅ™ehkou**.

Existuje vÅ¡ak jednoduchÃ½ zpÅ¯sob, jak s tÃ­mto problÃ©mem naloÅ¾it. StaÄÃ­ nechat API deklarovat zÃ¡vislosti, ÄÃ­mÅ¾ se zajistÃ­ sprÃ¡vnÃ¡ funkÄnost.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

DÃ­ky tomuto pÅ™Ã­stupu odpadÃ¡ obava o skrytÃ© a neoÄekÃ¡vanÃ© zmÄ›ny pÅ™ipojenÃ­ k databÃ¡zi. NynÃ­ mÃ¡me jistotu, kam se ÄlÃ¡nek uklÃ¡dÃ¡ a Å¾Ã¡dnÃ© Ãºpravy kÃ³du uvnitÅ™ jinÃ© nesouvisejÃ­cÃ­ tÅ™Ã­dy jiÅ¾ nemohou situaci zmÄ›nit. KÃ³d uÅ¾ nenÃ­ kÅ™ehkÃ½, ale stabilnÃ­.

NepiÅ¡te kÃ³d, kterÃ½ vyuÅ¾Ã­vÃ¡ globÃ¡lnÃ­ stav, dejte pÅ™ednost pÅ™edÃ¡vÃ¡nÃ­ zÃ¡vislostÃ­. Tedy dependency injection.


Singleton
---------

Singleton je nÃ¡vrhovÃ½ vzor, kterÃ½ podle "definice":https://en.wikipedia.org/wiki/Singleton_pattern ze znÃ¡mÃ© publikace Gang of Four omezuje tÅ™Ã­du na jedinou instanci a nabÃ­zÃ­ k nÃ­ globÃ¡lnÃ­ pÅ™Ã­stup. Implementace tohoto vzoru se obvykle podobÃ¡ nÃ¡sledujÃ­cÃ­mu kÃ³du:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// a dalÅ¡Ã­ metody plnÃ­cÃ­ funkce danÃ© tÅ™Ã­dy
}
```

BohuÅ¾el, singleton zavÃ¡dÃ­ do aplikace globÃ¡lnÃ­ stav. A jak jsme si ukÃ¡zali vÃ½Å¡e, globÃ¡lnÃ­ stav je neÅ¾Ã¡doucÃ­. Proto je singleton povaÅ¾ovÃ¡n za antipattern.

NepouÅ¾Ã­vejte ve svÃ©m kÃ³du singletony a nahraÄte je jinÃ½mi mechanismy. Singletony opravdu nepotÅ™ebujete. Pokud vÅ¡ak potÅ™ebujete zaruÄit existenci jedinÃ© instance tÅ™Ã­dy pro celou aplikaci, nechte to na [DI kontejneru |container].
VytvoÅ™te tak aplikaÄnÃ­ singleton, neboli sluÅ¾bu. TÃ­m se tÅ™Ã­da pÅ™estane vÄ›novat zajiÅ¡tÄ›nÃ­ svÃ© vlastnÃ­ jedineÄnosti (tj. nebude mÃ­t metodu `getInstance()` a statickou promÄ›nnou) a bude plnit pouze svÃ© funkce. Tak pÅ™estane poruÅ¡ovat princip jedinÃ© odpovÄ›dnosti.


GlobÃ¡lnÃ­ stav versus testy
--------------------------

PÅ™i psanÃ­ testÅ¯ pÅ™edpoklÃ¡dÃ¡me, Å¾e kaÅ¾dÃ½ test je izolovanou jednotkou a Å¾e do nÄ›j nevstupuje Å¾Ã¡dnÃ½ externÃ­ stav. A Å¾Ã¡dnÃ½ stav testy neopouÅ¡tÃ­. Po dokonÄenÃ­ testu by mÄ›l bÃ½t veÅ¡kerÃ½ souvisejÃ­cÃ­ stav s testem odstranÄ›n automaticky garbage collectorem. DÃ­ky tomu jsou testy izolovanÃ©. Proto mÅ¯Å¾eme testy spouÅ¡tÄ›t v libovolnÃ©m poÅ™adÃ­.

Pokud jsou vÅ¡ak pÅ™Ã­tomny globÃ¡lnÃ­ stavy/singletony, vÅ¡echny tyto pÅ™Ã­jemnÃ© pÅ™edpoklady se rozpadajÃ­. Stav mÅ¯Å¾e do testu vstupovat a vystupovat z nÄ›j. Najednou mÅ¯Å¾e zÃ¡leÅ¾et na poÅ™adÃ­ testÅ¯.

Abychom vÅ¯bec mohli testovat singletony, vÃ½vojÃ¡Å™i Äasto musÃ­ rozvolnit jejich vlastnosti, tÅ™eba tÃ­m, Å¾e dovolÃ­ instanci nahradit jinou. TakovÃ¡ Å™eÅ¡enÃ­ jsou v nejlepÅ¡Ã­m pÅ™Ã­padÄ› hackem, kterÃ½ vytvÃ¡Å™Ã­ obtÃ­Å¾nÄ› udrÅ¾ovatelnÃ½ a srozumitelnÃ½ kÃ³d. KaÅ¾dÃ½ test nebo metoda `tearDown()`, kterÃ¡ ovlivnÃ­ jakÃ½koli globÃ¡lnÃ­ stav, musÃ­ tyto zmÄ›ny vrÃ¡tit zpÄ›t.

GlobÃ¡lnÃ­ stav je nejvÄ›tÅ¡Ã­ bolestÃ­ hlavy pÅ™i unit testovÃ¡nÃ­!

Jak situaci opravit? Snadno. NepiÅ¡te kÃ³d, kterÃ½ vyuÅ¾Ã­vÃ¡ singletony, dejte pÅ™ednost pÅ™edÃ¡vÃ¡nÃ­ zÃ¡vislostÃ­. Tedy dependency injection.


GlobÃ¡lnÃ­ konstanty
------------------

GlobÃ¡lnÃ­ stav se neomezuje pouze na pouÅ¾Ã­vÃ¡nÃ­ singletonÅ¯ a statickÃ½ch promÄ›nnÃ½ch, ale mÅ¯Å¾e se tÃ½kat takÃ© globÃ¡lnÃ­ch konstant.

Konstanty, jejichÅ¾ hodnota nÃ¡m nepÅ™inÃ¡Å¡Ã­ Å¾Ã¡dnou novou (`M_PI`) nebo uÅ¾iteÄnou (`PREG_BACKTRACK_LIMIT_ERROR`) informaci, jsou jednoznaÄnÄ› v poÅ™Ã¡dku.
Naopak konstanty, kterÃ© slouÅ¾Ã­ jako zpÅ¯sob, jak *bezdrÃ¡tovÄ›* pÅ™edat informaci dovnitÅ™ kÃ³du, nejsou niÄÃ­m jinÃ½m neÅ¾ skrytou zÃ¡vislostÃ­. Jako tÅ™eba `LOG_FILE` v nÃ¡sledujÃ­cÃ­m pÅ™Ã­kladu.
PouÅ¾itÃ­ konstanty `FILE_APPEND` je zcela korektnÃ­.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

V tomto pÅ™Ã­padÄ› bychom mÄ›li deklarovat parametr v konstruktoru tÅ™Ã­dy `Foo`, aby se stal souÄÃ¡stÃ­ API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

NynÃ­ mÅ¯Å¾eme pÅ™edat informaci o cestÄ› k souboru pro logovÃ¡nÃ­ a snadno ji mÄ›nit podle potÅ™eby, coÅ¾ usnadÅˆuje testovÃ¡nÃ­ a ÃºdrÅ¾bu kÃ³du.


GlobÃ¡lnÃ­ funkce a statickÃ© metody
---------------------------------

Chceme zdÅ¯ranit, Å¾e samotnÃ© pouÅ¾Ã­vÃ¡nÃ­ statickÃ½ch metod a globÃ¡lnÃ­ch funkcÃ­ nenÃ­ problematickÃ©. VysvÄ›tlovali jsme, v Äem spoÄÃ­vÃ¡ nevhodnost pouÅ¾itÃ­ `DB::insert()` a podobnÃ½ch metod, ale vÅ¾dy se jednalo pouze o zÃ¡leÅ¾itost globÃ¡lnÃ­ho stavu, kterÃ½ je uloÅ¾en v nÄ›jakÃ© statickÃ© promÄ›nnÃ©. Metoda `DB::insert()` vyÅ¾aduje existenci statickÃ© promÄ›nnÃ©, protoÅ¾e v nÃ­ je uloÅ¾eno pÅ™ipojenÃ­ k databÃ¡zi. Bez tÃ©to promÄ›nnÃ© by bylo nemoÅ¾nÃ© metodu implementovat.

PouÅ¾Ã­vÃ¡nÃ­ deterministickÃ½ch statickÃ½ch metod a funkcÃ­, jako napÅ™Ã­klad `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` a mnoha dalÅ¡Ã­ch, je v naprostÃ©m souladu s dependency injection. Tyto funkce vÅ¾dy vracejÃ­ stejnÃ© vÃ½sledky ze stejnÃ½ch vstupnÃ­ch parametrÅ¯ a jsou tedy pÅ™edvÃ­datelnÃ©. NepouÅ¾Ã­vajÃ­ Å¾Ã¡dnÃ½ globÃ¡lnÃ­ stav.

ExistujÃ­ ovÅ¡em i funkce v PHP, kterÃ© nejsou deterministickÃ©. K nim patÅ™Ã­ napÅ™Ã­klad funkce `htmlspecialchars()`. JejÃ­ tÅ™etÃ­ parametr `$encoding`, pokud nenÃ­ uveden, jako vÃ½chozÃ­ hodnotu mÃ¡ hodnotu konfiguraÄnÃ­ volby `ini_get('default_charset')`. Proto se doporuÄuje tento parametr vÅ¾dy uvÃ¡dÄ›t a pÅ™edejÃ­t tak pÅ™Ã­padnÃ©mu nepÅ™edvÃ­datelnÃ©mu chovÃ¡nÃ­ funkce. Nette to dÅ¯slednÄ› dÄ›lÃ¡.

NÄ›kterÃ© funkce, jako napÅ™Ã­klad `strtolower()`, `strtoupper()` a podobnÃ©, se v nedÃ¡vnÃ© minulosti nedeterministicky chovaly a byly zÃ¡vislÃ© na nastavenÃ­ `setlocale()`. To zpÅ¯sobovalo mnoho komplikacÃ­, nejÄastÄ›ji pÅ™i prÃ¡ci s tureckÃ½m jazykem.
Ten totiÅ¾ rozliÅ¡uje malÃ© i velkÃ© pÃ­smeno `I` s teÄkou i bez teÄky. TakÅ¾e `strtolower('I')` vracelo znak `Ä±` a `strtoupper('i')` znak `Ä°`, coÅ¾ vedlo k tomu, Å¾e aplikace zaÄaly zpÅ¯sobovat Å™adu zÃ¡hadnÃ½ch chyb.
Tento problÃ©m byl vÅ¡ak odstranÄ›n v PHP verze 8.2 a funkce jiÅ¾ nejsou zÃ¡vislÃ© na locale.

Jde o pÄ›knÃ½ pÅ™Ã­klad, jak globÃ¡lnÃ­ stav potrÃ¡pil tisÃ­ce vÃ½vojÃ¡Å™Å¯ na celÃ©m svÄ›tÄ›. Å˜eÅ¡enÃ­m bylo nahradit jej za dependency injection.


ShrnutÃ­
-------

UkÃ¡zali jsme si, proÄ mÃ¡ smysl

1) Odstranit veÅ¡kerÃ© statickÃ© promÄ›nnÃ© z kÃ³du
2) Deklarovat zÃ¡vislosti
3) A pouÅ¾Ã­vat dependency injection

NeexistujÃ­ Å¾Ã¡dnÃ© vÃ½jimky, Å¾Ã¡dnÃ© situace, kdy by globÃ¡lnÃ­ stav byl uÅ¾iteÄnÃ½m kamarÃ¡dem. KaÅ¾dÃ© `static $foo` uvnitÅ™ kÃ³du znamenÃ¡ problÃ©m. Aby vÃ¡Å¡ kÃ³d byl prostÅ™edÃ­m respektujÃ­cÃ­m DI, je nezbytnÃ© ÃºplnÄ› vymÃ½tit globÃ¡lnÃ­ stav a nahradit ho pomocÃ­ dependency injection.

BÄ›hem tohoto procesu moÅ¾nÃ¡ zjistÃ­te, Å¾e je tÅ™eba tÅ™Ã­du rozdÄ›lit, protoÅ¾e mÃ¡ vÃ­ce neÅ¾ jednu odpovÄ›dnost. Nebojte se toho; usilujte o princip jednÃ© odpovÄ›dnosti.

*RÃ¡d bych podÄ›koval MiÅ¡kovi Heverymu, jehoÅ¾ ÄlÃ¡nky, jako je [Flaw: Brittle Global State & Singletons |http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], jsou zÃ¡kladem tÃ©to kapitoly.*
