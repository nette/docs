DI: Services
************

.[perex]
Configuration is where we place the definitions of custom services. This is done in section `services`.

For example, this is how we create a service named `database`, which will be an instance of class `PDO`:

```neon
services:
	database: PDO('sqlite::memory:')
```

The naming of services is used to allow us to [reference|#Referencing Services] them. If a service is not referenced, there is no need to name it. So we just use a bullet point instead of a name:

```neon
services:
	- PDO('sqlite::memory:')  #  anonymous service
```

A one-line entry can be broken up into multiple lines to allow additional keys to be added, such as [#setup]:

```neon
services:
	database:
		factory: PDO('sqlite::memory:')
		setup: ...
```

We then retrieve the service from the DI container using the method `getService()` by name, or better yet, the method `getByType()` by type:

```php
$database = $container->getService('database');
$database = $container->getByType(PDO::class);
```


Creating a Service
==================

Most often, we create a service by simply creating an instance of a class:

```neon
services:
	database: PDO('mysql:host=127.0.0.1;dbname=test', root, secret)
```

Which will generate a factory method in [DI container|di-container]:

```php
public function createServiceDatabase()
{
	return new PDO('mysql:host=127.0.0.1;dbname=test', 'root', 'secret');
}
```

Alternatively, a key `arguments` can be used to pass [arguments|#Arguments]:

```neon
services:
	database:
		factory: PDO
		arguments: ['mysql:host=127.0.0.1;dbname=test', root, secret]
```

A static method can also create a service:

```neon
services:
	database: My\Database::create(root, secret)
```

Corresponds to PHP code:

```php
public function createServiceDatabase()
{
	return My\Database::create('root', 'secret');
}
```

A static method `My\Database::create()` is assumed to have a defined return value, either using the `@return` annotation or PHP 7 type hints, that the DI container needs to know. If it does not have it, we write the type to the configuration:

```neon
services:
	database:
		factory: My\Database::create(root, secret)
		type: PDO
```

Nette DI gives you extremely powerful expression facilities to write almost anything. For example, to [refer|#Referencing Services] to another service and call its method. For simplicity, `::` is used instead of `->`.

```neon
services:
	routerFactory: App\Router\Factory
	router: @routerFactory::create()
```

Corresponds to PHP code:

```php
public function createServiceRouterFactory()
{
	return new App\Router\Factory;
}

public function createServiceRouter()
{
	return $this->getService('routerFactory')->create();
}
```

Method calls can be chained together as in PHP:

```neon
services:
	foo: FooFactory::build()::get()
```

Corresponds to PHP code:

```php
public function createServiceFoo()
{
	return FooFactory::build()->get();
}
```


Arguments
=========

Named parameters can also be used to pass arguments:

```neon
services:
	database: PDO(
		'mysql:host=127.0.0.1;dbname=test'  # positional
		username: root                      # named
		password: secret                    # named
	)
```

The use of commas is optional when breaking arguments into multiple lines.

Of course, we can also use [other services|#Referencing Services] or [parameters|di-configuration#parameters] as arguments:

```neon
services:
	- Foo(@anotherService, %appDir%)
```

Corresponds to PHP code:

```php
public function createService01()
{
	return new Foo($this->getService('anotherService'), '...');
}
```

If the first argument is [autowired|di-autowiring] and you want to specify the second one, omit the first one with the `_` character, for example `Foo(_, %appDir%)`. Or better yet, pass only the second argument as a named parameter, e.g. `Foo(path: %appDir%)`.

Nette DI and the NEON format give you extremely powerful expressive facilities to write almost anything. Thus an argument can be a newly created object, you can call static methods, methods of other services, or even global functions using special notation:

```neon
services:
	analyser: My\Analyser(
		FilesystemIterator(%appDir%)         # create object
		DateTime::createFromFormat('Y-m-d')  # call static method
		@anotherService                      # passing another service
		@http.request::getRemoteAddress()    # calling another service method
		::getenv(NETTE_MODE)                 # call a global function
	)
```

Corresponds to PHP code:

```php
public function createServiceAnalyser()
{
	return new My\Analyser(
		new FilesystemIterator('...'),
		DateTime::createFromFormat('Y-m-d'),
		$this->getService('anotherService'),
		$this->getService('http.request')->getRemoteAddress(),
		getenv('NETTE_MODE')
	);
}
```


Referencing Services
====================

Individual services are referenced using character `@` and name, so for example `@database`:

```neon
services:
	- factory: Foo(@database)
	  setup:
			- setCacheStorage(@cache.storage)
```

Corresponds to PHP code:

```php
public function createService01()
{
	$service = new Foo($this->getService('database'));
	$service->setCacheStorage($this->getService('cache.storage'));
	return $service;
}
```

Even anonymous services can be referenced using a callback, just specify their type (class or interface) instead of their name. However, this is usually not necessary due to [autowiring|di-autowiring].

```neon
services:
	- factory: Foo(@Nette\Database\Connection)  # or @\PDO
	  setup:
			- setCacheStorage(@cache.storage)
```


Setup
=====

In the setup section we list the methods to be called when creating the service:

```neon
services:
	database:
		factory: PDO(%dsn%, %user%, %password%)
		setup:
			- setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION)
```

Corresponds to PHP code:

```php
public function createServiceDatabase()
{
	$service = new PDO('...', '...', '...');
	$service->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	return $service;
}
```

Properites can also be set. Adding an element to an array is also supported, and should be written in quotes so as not to conflict with NEON syntax:


```neon
services:
	foo:
		factory: Foo
		setup:
			- $value = 123
			- '$onClick[]' = [@bar, clickHandler]
```

Corresponds to PHP code:

```php
public function createServiceFoo()
{
	$service = new Foo;
	$service->value = 123;
	$service->onClick[] = [$this->getService('bar'), 'clickHandler'];
	return $service;
}
```

However, static methods or methods of other services can also be called in the setup. We pass the actual service to them as `@self`:


```neon
services:
	foo:
		factory: Foo
		setup:
			- My\Helpers::initializeFoo(@self)
			- @anotherService::setFoo(@self)
```

Corresponds to PHP code:

```php
public function createServiceFoo()
{
	$service = new Foo;
	My\Helpers::initializeFoo($service);
	$this->getService('anotherService')->setFoo($service);
	return $service;
}
```


Autowiring
==========

The autowired key can be used to exclude a service from autowiring or to influence its behavior. See [chapter on autowiring|di-autowiring] for more information.

```neon
services:
	foo:
		factory: Foo
		autowired: false     # foo is removed from autowiring
```


Tags
====

User information can be added to individual services in the form of tags:

```neon
services:
	foo:
		factory: Foo
		tags:
			- cached
```

Tags can also have a value:

```neon
services:
	foo:
		factory: Foo
		tags:
			logger: monolog.logger.event
```

Service names can be obtained from the DI container using the method `findByTag()`:

```php
$names = $container->findByTag('logger');
// $names is an array containing the service name and tag value
// i.e. ['foo' => 'monolog.logger.event', ...]
```


Inject Mode
===========

The `inject: true` flag is used to activate the passing of dependencies via public variables with the [inject |di-passing-dependencies#Inject Annotations] annotation and the [inject*() |di-passing-dependencies#Passing by an inject Method] methods.

```neon
services:
	articles:
		factory: App\Model\Articles
		inject: true
```

By default, `inject` is only activated for presenters.


Modification of Services
========================

There are a number of services in the DI container that have been added by built-in or [your extension|#di-extensions]. The definitions of these services can be modified in the configuration. For example, for service `application.application`, which is by default an object `Nette\Application\Application`, we can change the class:

```neon
services:
	application.application:
		factory: MyApplication
		alteration: true
```

The `alteration` flag is informative and says that we are just modifying an existing service.

We can also add a setup:

```neon
services:
	application.application:
		factory: MyApplication
		alteration: true
		setup:
			- '$onStartup[]' = [@resource, init]
```

When rewriting a service, we may want to remove the original arguments, setup items or tags, which is what `reset` is for:

```neon
services:
	application.application:
		factory: MyApplication
		alteration: true
		reset:
			- arguments
			- setup
			- tags
```

A service added by extension can also be removed from the container:

```neon
services:
	cache.journal: false
```

{{composer: nette/di}}
