Stare globalÄƒ È™i singleton-uri
******************************

.[perex]
Avertisment: UrmÄƒtoarele construcÈ›ii sunt un semn al unui cod prost proiectat:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` sau `static::$var`

Apar unele dintre aceste construcÈ›ii Ã®n codul dvs.? Atunci aveÈ›i ocazia sÄƒ Ã®l Ã®mbunÄƒtÄƒÈ›iÈ›i. Poate vÄƒ gÃ¢ndiÈ›i cÄƒ sunt construcÈ›ii obiÈ™nuite, pe care le vedeÈ›i poate chiar È™i Ã®n soluÈ›ii demonstrative ale diverselor biblioteci È™i framework-uri. DacÄƒ este aÈ™a, atunci designul codului lor nu este bun.

Acum nu vorbim deloc despre vreo puritate academicÄƒ. Toate aceste construcÈ›ii au un lucru Ã®n comun: utilizeazÄƒ starea globalÄƒ. È˜i aceasta are un impact distructiv asupra calitÄƒÈ›ii codului. Clasele mint despre dependenÈ›ele lor. Codul devine imprevizibil. ÃncurcÄƒ programatorii È™i le reduce eficienÈ›a.

Ãn acest capitol vom explica de ce este aÈ™a È™i cum sÄƒ evitaÈ›i starea globalÄƒ.


Cuplare globalÄƒ
---------------

Ãntr-o lume idealÄƒ, un obiect ar trebui sÄƒ poatÄƒ comunica doar cu obiectele care i-au fost [transmise direct |passing-dependencies]. DacÄƒ creez douÄƒ obiecte `A` È™i `B` È™i nu transmit niciodatÄƒ o referinÈ›Äƒ Ã®ntre ele, atunci nici `A`, nici `B`, nu pot ajunge la celÄƒlalt obiect sau sÄƒ Ã®i modifice starea. Aceasta este o proprietate foarte doritÄƒ a codului. Este similar cu situaÈ›ia Ã®n care aveÈ›i o baterie È™i un bec; becul nu va lumina pÃ¢nÄƒ nu Ã®l conectaÈ›i la baterie cu un fir.

Dar acest lucru nu este valabil pentru variabilele globale (statice) sau singleton-uri. Obiectul `A` ar putea ajunge *fÄƒrÄƒ fir* la obiectul `C` È™i sÄƒ Ã®l modifice fÄƒrÄƒ nicio transmitere de referinÈ›Äƒ, prin apelarea `C::changeSomething()`. DacÄƒ obiectul `B` se agaÈ›Äƒ È™i el de `C` global, atunci `A` È™i `B` se pot influenÈ›a reciproc prin intermediul `C`.

Utilizarea variabilelor globale introduce Ã®n sistem o nouÄƒ formÄƒ de cuplare *fÄƒrÄƒ fir*, care nu este vizibilÄƒ din exterior. CreeazÄƒ o perdea de fum care complicÄƒ Ã®nÈ›elegerea È™i utilizarea codului. Pentru ca dezvoltatorii sÄƒ Ã®nÈ›eleagÄƒ cu adevÄƒrat dependenÈ›ele, trebuie sÄƒ citeascÄƒ fiecare linie de cod sursÄƒ. Ãn loc sÄƒ se familiarizeze pur È™i simplu cu interfaÈ›a claselor. Mai mult, este o cuplare complet inutilÄƒ. Starea globalÄƒ se foloseÈ™te deoarece este uÈ™or accesibilÄƒ de oriunde È™i permite, de exemplu, scrierea Ã®n baza de date prin metoda globalÄƒ (staticÄƒ) `DB::insert()`. Dar, aÈ™a cum vom arÄƒta, avantajul pe care Ã®l aduce este nesemnificativ, Ã®n timp ce complicaÈ›iile pe care le provoacÄƒ sunt fatale.

.[note]
Din punct de vedere comportamental, nu existÄƒ nicio diferenÈ›Äƒ Ã®ntre o variabilÄƒ globalÄƒ È™i una staticÄƒ. Sunt la fel de dÄƒunÄƒtoare.


AcÈ›iune Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ
----------------------------------

"AcÈ›iune Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ" - aÈ™a a numit celebrul Albert Einstein Ã®n 1935 un fenomen din fizica cuanticÄƒ care Ã®i dÄƒdea fiori.
Este vorba despre inseparabilitatea cuanticÄƒ, a cÄƒrei particularitate este cÄƒ atunci cÃ¢nd mÄƒsori informaÈ›ia despre o particulÄƒ, influenÈ›ezi instantaneu cealaltÄƒ particulÄƒ, chiar dacÄƒ sunt la milioane de ani-luminÄƒ distanÈ›Äƒ.
Ceea ce pare sÄƒ Ã®ncalce legea fundamentalÄƒ a universului, cÄƒ nimic nu se poate propaga mai repede decÃ¢t lumina.

Ãn lumea software, putem numi "acÈ›iune Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ" situaÈ›ia Ã®n care pornim un proces despre care credem cÄƒ este izolat (deoarece nu i-am transmis nicio referinÈ›Äƒ), dar Ã®n locuri Ã®ndepÄƒrtate ale sistemului apar interacÈ›iuni neaÈ™teptate È™i modificÄƒri de stare despre care nu aveam nicio idee. Acest lucru se poate Ã®ntÃ¢mpla doar prin intermediul stÄƒrii globale.

ImaginaÈ›i-vÄƒ cÄƒ vÄƒ alÄƒturaÈ›i unei echipe de dezvoltatori ai unui proiect care are o bazÄƒ de cod extinsÄƒ È™i maturÄƒ. Noul dvs. È™ef vÄƒ cere sÄƒ implementaÈ›i o nouÄƒ funcÈ›ionalitate È™i, ca un dezvoltator bun, Ã®ncepeÈ›i prin scrierea unui test. Dar, fiind nou Ã®n proiect, faceÈ›i multe teste exploratorii de tipul "ce se Ã®ntÃ¢mplÄƒ dacÄƒ apelez aceastÄƒ metodÄƒ". È˜i Ã®ncercaÈ›i sÄƒ scrieÈ›i urmÄƒtorul test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // numÄƒrul cardului dvs.
	$cc->charge(100);
}
```

RulaÈ›i codul, poate de mai multe ori, È™i dupÄƒ un timp observaÈ›i pe mobil notificÄƒri de la bancÄƒ cÄƒ la fiecare rulare s-au retras 100 de dolari de pe cardul dvs. de platÄƒ ğŸ¤¦â€â™‚ï¸

Cum naiba a putut testul sÄƒ provoace retragerea realÄƒ de bani? Operarea cu un card de platÄƒ nu este uÈ™oarÄƒ. Trebuie sÄƒ comunicaÈ›i cu un serviciu web terÈ›, trebuie sÄƒ cunoaÈ™teÈ›i URL-ul acestui serviciu web, trebuie sÄƒ vÄƒ autentificaÈ›i È™i aÈ™a mai departe.
Nicio informaÈ›ie de acest gen nu este conÈ›inutÄƒ Ã®n test. Mai rÄƒu, nici mÄƒcar nu È™tiÈ›i unde sunt prezente aceste informaÈ›ii È™i, prin urmare, nici cum sÄƒ mock-uiÈ›i dependenÈ›ele externe, astfel Ã®ncÃ¢t fiecare rulare sÄƒ nu ducÄƒ la retragerea din nou a 100 de dolari. È˜i cum trebuia sÄƒ È™tiÈ›i, ca dezvoltator nou, cÄƒ ceea ce urmaÈ›i sÄƒ faceÈ›i va duce la sÄƒrÄƒcirea cu 100 de dolari?

Aceasta este acÈ›iunea Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ!

Nu vÄƒ rÄƒmÃ¢ne decÃ¢t sÄƒ scormoniÈ›i Ã®ndelung Ã®n multe coduri sursÄƒ, sÄƒ Ã®ntrebaÈ›i colegii mai vechi È™i mai experimentaÈ›i, pÃ¢nÄƒ cÃ¢nd Ã®nÈ›elegeÈ›i cum funcÈ›ioneazÄƒ legÄƒturile Ã®n proiect.
Acest lucru este cauzat de faptul cÄƒ, privind interfaÈ›a clasei `CreditCard`, nu se poate identifica starea globalÄƒ care trebuie iniÈ›ializatÄƒ. Nici mÄƒcar privirea Ã®n codul sursÄƒ al clasei nu vÄƒ dezvÄƒluie ce metodÄƒ de iniÈ›ializare trebuie sÄƒ apelaÈ›i. Ãn cel mai bun caz, puteÈ›i gÄƒsi o variabilÄƒ globalÄƒ la care se acceseazÄƒ È™i din ea sÄƒ Ã®ncercaÈ›i sÄƒ ghiciÈ›i cum sÄƒ o iniÈ›ializaÈ›i.

Clasele dintr-un astfel de proiect sunt mincinoÈ™i patologici. Cardul de platÄƒ pretinde cÄƒ este suficient sÄƒ Ã®l instanÈ›iaÈ›i È™i sÄƒ apelaÈ›i metoda `charge()`. Ãn secret, Ã®nsÄƒ, colaboreazÄƒ cu o altÄƒ clasÄƒ `PaymentGateway`, care reprezintÄƒ poarta de platÄƒ. È˜i interfaÈ›a sa spune cÄƒ poate fi iniÈ›ializatÄƒ separat, dar Ã®n realitate Ã®È™i extrage credenÈ›ialele dintr-un fiÈ™ier de configurare È™i aÈ™a mai departe.
Dezvoltatorilor care au scris acest cod le este clar cÄƒ `CreditCard` are nevoie de `PaymentGateway`. Au scris codul Ã®n acest fel. Dar pentru oricine este nou Ã®n proiect, este un mister total È™i Ã®mpiedicÄƒ Ã®nvÄƒÈ›area.

Cum sÄƒ reparaÈ›i situaÈ›ia? UÈ™or. **LÄƒsaÈ›i API-ul sÄƒ declare dependenÈ›ele.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

ObservaÈ›i cum legÄƒturile din interiorul codului devin brusc evidente. Prin faptul cÄƒ metoda `charge()` declarÄƒ cÄƒ are nevoie de `PaymentGateway`, nu trebuie sÄƒ Ã®ntrebaÈ›i pe nimeni cum este legat codul. È˜tiÈ›i cÄƒ trebuie sÄƒ creaÈ›i instanÈ›a sa È™i, cÃ¢nd Ã®ncercaÈ›i sÄƒ faceÈ›i acest lucru, veÈ›i descoperi cÄƒ trebuie sÄƒ furnizaÈ›i parametrii de acces. FÄƒrÄƒ ei, codul nici mÄƒcar nu ar rula.

È˜i, cel mai important, acum puteÈ›i mock-ui poarta de platÄƒ, astfel Ã®ncÃ¢t sÄƒ nu vi se taxeze 100 de dolari la fiecare rulare a testului.

Starea globalÄƒ face ca obiectele dvs. sÄƒ poatÄƒ accesa Ã®n secret lucruri care nu sunt declarate Ã®n API-ul lor È™i, Ã®n consecinÈ›Äƒ, transformÄƒ API-urile dvs. Ã®n mincinoÈ™i patologici.

Poate cÄƒ nu v-aÈ›i gÃ¢ndit la asta Ã®nainte Ã®n acest fel, dar ori de cÃ¢te ori utilizaÈ›i starea globalÄƒ, creaÈ›i canale de comunicare secrete fÄƒrÄƒ fir. AcÈ›iunea Ã®nfricoÈ™Äƒtoare la distanÈ›Äƒ Ã®i obligÄƒ pe dezvoltatori sÄƒ citeascÄƒ fiecare linie de cod pentru a Ã®nÈ›elege interacÈ›iunile potenÈ›iale, reduce productivitatea dezvoltatorilor È™i Ã®i Ã®ncurcÄƒ pe noii membri ai echipei.
DacÄƒ sunteÈ›i cel care a creat codul, cunoaÈ™teÈ›i dependenÈ›ele reale, dar oricine vine dupÄƒ dvs. este neajutorat.

Nu scrieÈ›i cod care utilizeazÄƒ starea globalÄƒ, preferaÈ›i transmiterea dependenÈ›elor. AdicÄƒ injecÈ›ia de dependenÈ›Äƒ.


Fragilitatea stÄƒrii globale
---------------------------

Ãn codul care utilizeazÄƒ starea globalÄƒ È™i singleton-uri, nu este niciodatÄƒ sigur cÃ¢nd È™i cine a modificat aceastÄƒ stare. Acest risc apare deja la iniÈ›ializare. UrmÄƒtorul cod ar trebui sÄƒ creeze o conexiune la baza de date È™i sÄƒ iniÈ›ializeze poarta de platÄƒ, Ã®nsÄƒ aruncÄƒ constant o excepÈ›ie È™i gÄƒsirea cauzei este extrem de anevoioasÄƒ:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Trebuie sÄƒ parcurgeÈ›i codul Ã®n detaliu pentru a descoperi cÄƒ obiectul `PaymentGateway` acceseazÄƒ fÄƒrÄƒ fir alte obiecte, dintre care unele necesitÄƒ o conexiune la baza de date. Prin urmare, este necesar sÄƒ iniÈ›ializaÈ›i baza de date Ã®nainte de `PaymentGateway`. Cu toate acestea, perdeaua de fum a stÄƒrii globale ascunde acest lucru de dvs. CÃ¢t timp aÈ›i economisi dacÄƒ API-urile claselor individuale nu ar minÈ›i È™i È™i-ar declara dependenÈ›ele?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

O problemÄƒ similarÄƒ apare È™i la utilizarea accesului global la conexiunea bazei de date:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

La apelarea metodei `save()`, nu este sigur dacÄƒ a fost deja creatÄƒ conexiunea la baza de date È™i cine poartÄƒ responsabilitatea pentru crearea sa. DacÄƒ dorim, de exemplu, sÄƒ schimbÄƒm conexiunea la baza de date Ã®n timpul rulÄƒrii, de exemplu pentru teste, ar trebui probabil sÄƒ creÄƒm alte metode precum `DB::reconnect(...)` sau `DB::reconnectForTest()`.

SÄƒ luÄƒm Ã®n considerare un exemplu:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Unde avem certitudinea cÄƒ la apelarea `$article->save()` se utilizeazÄƒ Ã®ntr-adevÄƒr baza de date de test? Ce se Ã®ntÃ¢mplÄƒ dacÄƒ metoda `Foo::doSomething()` a schimbat conexiunea globalÄƒ la baza de date? Pentru a afla, ar trebui sÄƒ examinÄƒm codul sursÄƒ al clasei `Foo` È™i probabil È™i al multor altor clase. AceastÄƒ abordare ar aduce Ã®nsÄƒ doar un rÄƒspuns pe termen scurt, deoarece situaÈ›ia se poate schimba Ã®n viitor.

È˜i ce se Ã®ntÃ¢mplÄƒ dacÄƒ mutÄƒm conexiunea la baza de date Ã®ntr-o variabilÄƒ staticÄƒ Ã®n interiorul clasei `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Acest lucru nu a schimbat absolut nimic. Problema este starea globalÄƒ È™i este complet irelevant Ã®n ce clasÄƒ se ascunde. Ãn acest caz, la fel ca Ã®n cel precedent, nu avem niciun indiciu la apelarea metodei `$article->save()` despre Ã®n ce bazÄƒ de date se va scrie. Oricine de la celÄƒlalt capÄƒt al aplicaÈ›iei ar fi putut schimba oricÃ¢nd baza de date folosind `Article::setDb()`. Sub nasul nostru.

Starea globalÄƒ face aplicaÈ›ia noastrÄƒ **extrem de fragilÄƒ**.

ExistÄƒ Ã®nsÄƒ o modalitate simplÄƒ de a aborda aceastÄƒ problemÄƒ. Este suficient sÄƒ lÄƒsÄƒm API-ul sÄƒ declare dependenÈ›ele, asigurÃ¢ndu-se astfel funcÈ›ionalitatea corectÄƒ.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

DatoritÄƒ acestei abordÄƒri, dispare teama de modificÄƒri ascunse È™i neaÈ™teptate ale conexiunii la baza de date. Acum avem certitudinea unde se salveazÄƒ articolul È™i nicio modificare a codului Ã®n interiorul altei clase nelegate nu mai poate schimba situaÈ›ia. Codul nu mai este fragil, ci stabil.

Nu scrieÈ›i cod care utilizeazÄƒ starea globalÄƒ, preferaÈ›i transmiterea dependenÈ›elor. AdicÄƒ injecÈ›ia de dependenÈ›Äƒ.


Singleton
---------

Singleton este un pattern de design care, conform ["definiÈ›iei":https://en.wikipedia.org/wiki/Singleton_pattern] din celebra publicaÈ›ie Gang of Four, limiteazÄƒ clasa la o singurÄƒ instanÈ›Äƒ È™i oferÄƒ acces global la aceasta. Implementarea acestui pattern seamÄƒnÄƒ de obicei cu urmÄƒtorul cod:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// È™i alte metode care Ã®ndeplinesc funcÈ›iile clasei respective
}
```

Din pÄƒcate, singleton introduce starea globalÄƒ Ã®n aplicaÈ›ie. È˜i, aÈ™a cum am arÄƒtat mai sus, starea globalÄƒ este nedoritÄƒ. Prin urmare, singleton este considerat un antipattern.

Nu utilizaÈ›i singleton-uri Ã®n codul dvs. È™i Ã®nlocuiÈ›i-le cu alte mecanisme. Chiar nu aveÈ›i nevoie de singleton-uri. Cu toate acestea, dacÄƒ trebuie sÄƒ garantaÈ›i existenÈ›a unei singure instanÈ›e a clasei pentru Ã®ntreaga aplicaÈ›ie, lÄƒsaÈ›i acest lucru pe seama [containerului DI |container].
CreaÈ›i astfel un singleton de aplicaÈ›ie, adicÄƒ un serviciu. Astfel, clasa Ã®nceteazÄƒ sÄƒ se mai ocupe de asigurarea propriei unicitÄƒÈ›i (adicÄƒ nu va avea metoda `getInstance()` È™i variabila staticÄƒ) È™i va Ã®ndeplini doar funcÈ›iile sale. Astfel, nu va mai Ã®ncÄƒlca principiul responsabilitÄƒÈ›ii unice.


Stare globalÄƒ versus teste
--------------------------

La scrierea testelor, presupunem cÄƒ fiecare test este o unitate izolatÄƒ È™i cÄƒ nicio stare externÄƒ nu intrÄƒ Ã®n el. È˜i nicio stare nu pÄƒrÄƒseÈ™te testele. DupÄƒ finalizarea testului, toatÄƒ starea asociatÄƒ cu testul ar trebui eliminatÄƒ automat de garbage collector. DatoritÄƒ acestui fapt, testele sunt izolate. Prin urmare, putem rula testele Ã®n orice ordine.

Cu toate acestea, dacÄƒ sunt prezente stÄƒri globale/singleton-uri, toate aceste presupuneri plÄƒcute se destramÄƒ. Starea poate intra È™i ieÈ™i din test. Brusc, ordinea testelor poate conta.

Pentru a putea testa singleton-urile, dezvoltatorii trebuie adesea sÄƒ le relaxeze proprietÄƒÈ›ile, de exemplu, permiÈ›Ã¢nd Ã®nlocuirea instanÈ›ei cu alta. Astfel de soluÈ›ii sunt, Ã®n cel mai bun caz, hack-uri care creeazÄƒ cod dificil de Ã®ntreÈ›inut È™i de Ã®nÈ›eles. Fiecare test sau metodÄƒ `tearDown()` care afecteazÄƒ orice stare globalÄƒ trebuie sÄƒ anuleze aceste modificÄƒri.

Starea globalÄƒ este cea mai mare durere de cap la testarea unitarÄƒ!

Cum sÄƒ reparaÈ›i situaÈ›ia? UÈ™or. Nu scrieÈ›i cod care utilizeazÄƒ singleton-uri, preferaÈ›i transmiterea dependenÈ›elor. AdicÄƒ injecÈ›ia de dependenÈ›Äƒ.


Constante globale
-----------------

Starea globalÄƒ nu se limiteazÄƒ doar la utilizarea singleton-urilor È™i a variabilelor statice, ci se poate referi È™i la constantele globale.

Constantele a cÄƒror valoare nu ne aduce nicio informaÈ›ie nouÄƒ (`M_PI`) sau utilÄƒ (`PREG_BACKTRACK_LIMIT_ERROR`) sunt Ã®n mod clar Ã®n regulÄƒ.
DimpotrivÄƒ, constantele care servesc ca o modalitate de a transmite *fÄƒrÄƒ fir* informaÈ›ii Ã®n interiorul codului nu sunt altceva decÃ¢t o dependenÈ›Äƒ ascunsÄƒ. Cum ar fi `LOG_FILE` Ã®n exemplul urmÄƒtor.
Utilizarea constantei `FILE_APPEND` este complet corectÄƒ.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ãn acest caz, ar trebui sÄƒ declarÄƒm un parametru Ã®n constructorul clasei `Foo`, pentru ca acesta sÄƒ devinÄƒ parte a API-ului:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Acum putem transmite informaÈ›ia despre calea cÄƒtre fiÈ™ierul de logare È™i o putem schimba uÈ™or dupÄƒ nevoie, ceea ce faciliteazÄƒ testarea È™i Ã®ntreÈ›inerea codului.


FuncÈ›ii globale È™i metode statice
---------------------------------

Dorim sÄƒ subliniem cÄƒ utilizarea Ã®n sine a metodelor statice È™i a funcÈ›iilor globale nu este problematicÄƒ. Am explicat Ã®n ce constÄƒ inadecvarea utilizÄƒrii `DB::insert()` È™i a metodelor similare, dar Ã®ntotdeauna a fost vorba doar de o chestiune de stare globalÄƒ, care este stocatÄƒ Ã®ntr-o variabilÄƒ staticÄƒ. Metoda `DB::insert()` necesitÄƒ existenÈ›a unei variabile statice, deoarece Ã®n ea este stocatÄƒ conexiunea la baza de date. FÄƒrÄƒ aceastÄƒ variabilÄƒ, ar fi imposibil sÄƒ se implementeze metoda.

Utilizarea metodelor statice È™i a funcÈ›iilor deterministe, precum `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` È™i multe altele, este Ã®n perfectÄƒ concordanÈ›Äƒ cu injecÈ›ia de dependenÈ›Äƒ. Aceste funcÈ›ii returneazÄƒ Ã®ntotdeauna aceleaÈ™i rezultate pentru aceiaÈ™i parametri de intrare È™i sunt deci previzibile. Nu utilizeazÄƒ nicio stare globalÄƒ.

ExistÄƒ Ã®nsÄƒ È™i funcÈ›ii Ã®n PHP care nu sunt deterministe. Printre acestea se numÄƒrÄƒ, de exemplu, funcÈ›ia `htmlspecialchars()`. Al treilea sÄƒu parametru `$encoding`, dacÄƒ nu este specificat, are ca valoare implicitÄƒ valoarea opÈ›iunii de configurare `ini_get('default_charset')`. De aceea se recomandÄƒ specificarea Ã®ntotdeauna a acestui parametru È™i prevenirea astfel a unui eventual comportament imprevizibil al funcÈ›iei. Nette face acest lucru Ã®n mod consecvent.

Unele funcÈ›ii, precum `strtolower()`, `strtoupper()` È™i altele similare, s-au comportat nedeterminist Ã®n trecutul recent È™i au fost dependente de setarea `setlocale()`. Acest lucru a cauzat multe complicaÈ›ii, cel mai adesea la lucrul cu limba turcÄƒ.
Aceasta distinge literele mici È™i mari `I` cu È™i fÄƒrÄƒ punct. Astfel, `strtolower('I')` returna caracterul `Ä±` È™i `strtoupper('i')` caracterul `Ä°`, ceea ce a dus la faptul cÄƒ aplicaÈ›iile au Ã®nceput sÄƒ provoace o serie de erori misterioase.
AceastÄƒ problemÄƒ a fost Ã®nsÄƒ eliminatÄƒ Ã®n PHP versiunea 8.2 È™i funcÈ›iile nu mai sunt dependente de locale.

Este un exemplu frumos despre cum starea globalÄƒ a chinuit mii de dezvoltatori din Ã®ntreaga lume. SoluÈ›ia a fost Ã®nlocuirea sa cu injecÈ›ia de dependenÈ›Äƒ.


CÃ¢nd este posibil sÄƒ se utilizeze starea globalÄƒ?
-------------------------------------------------

ExistÄƒ anumite situaÈ›ii specifice Ã®n care este posibil sÄƒ se utilizeze starea globalÄƒ. De exemplu, la depanarea codului, cÃ¢nd trebuie sÄƒ afiÈ™aÈ›i valoarea unei variabile sau sÄƒ mÄƒsuraÈ›i durata unei anumite pÄƒrÈ›i a programului. Ãn astfel de cazuri, care se referÄƒ la acÈ›iuni temporare ce vor fi ulterior eliminate din cod, este posibil sÄƒ se utilizeze legitim un dumper sau un cronometru disponibil global. Aceste instrumente nu fac parte din designul codului.

Un alt exemplu sunt funcÈ›iile pentru lucrul cu expresii regulate `preg_*`, care stocheazÄƒ intern expresiile regulate compilate Ã®ntr-un cache static Ã®n memorie. Astfel, cÃ¢nd apelaÈ›i aceeaÈ™i expresie regulatÄƒ de mai multe ori Ã®n diferite locuri ale codului, aceasta se compileazÄƒ o singurÄƒ datÄƒ. Cache-ul economiseÈ™te performanÈ›a È™i, Ã®n acelaÈ™i timp, este complet invizibil pentru utilizator, prin urmare o astfel de utilizare poate fi consideratÄƒ legitimÄƒ.


Rezumat
-------

Am discutat de ce are sens:

1) SÄƒ eliminaÈ›i toate variabilele statice din cod
2) SÄƒ declaraÈ›i dependenÈ›ele
3) È˜i sÄƒ utilizaÈ›i injecÈ›ia de dependenÈ›Äƒ

CÃ¢nd vÄƒ gÃ¢ndiÈ›i la designul codului, gÃ¢ndiÈ›i-vÄƒ cÄƒ fiecare `static $foo` reprezintÄƒ o problemÄƒ. Pentru ca codul dvs. sÄƒ fie un mediu care respectÄƒ DI, este necesar sÄƒ eliminaÈ›i complet starea globalÄƒ È™i sÄƒ o Ã®nlocuiÈ›i folosind injecÈ›ia de dependenÈ›Äƒ.

Ãn timpul acestui proces, este posibil sÄƒ descoperiÈ›i cÄƒ este necesar sÄƒ Ã®mpÄƒrÈ›iÈ›i clasa, deoarece are mai mult de o responsabilitate. Nu vÄƒ temeÈ›i de acest lucru; urmÄƒriÈ›i principiul responsabilitÄƒÈ›ii unice.

*AÈ™ dori sÄƒ Ã®i mulÈ›umesc lui MiÅ¡ko Hevery, ale cÄƒrui articole, precum [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], stau la baza acestui capitol.*
