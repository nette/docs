Globalno stanje in singletoni
*****************************

.[perex]
Opozorilo: naslednji konstrukti so simptomi slabe zasnove kode:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ali `static::$var`

Ali se v vaÅ¡i kodi pojavlja katera od teh konstrukcij? Potem imate priloÅ¾nost za izboljÅ¡ave. Morda mislite, da so to pogosti konstrukti, ki jih vidimo v vzorÄnih reÅ¡itvah razliÄnih knjiÅ¾nic in ogrodij.
Na Å¾alost so Å¡e vedno jasen pokazatelj slabe zasnove. Skupno jim je eno: uporaba globalnega stanja.

Zdaj zagotovo ne govorimo o neki akademski Äistosti. Uporaba globalnega stanja in singletonov ima uniÄujoÄe uÄinke na kakovost kode. Njeno obnaÅ¡anje postane nepredvidljivo, zmanjÅ¡uje produktivnost razvijalcev in sili vmesnike razredov, da laÅ¾ejo o svojih resniÄnih odvisnostih. To zmede programerje.

V tem poglavju bomo pokazali, kako je to mogoÄe.


Globalno medsebojno povezovanje .[#toc-global-interlinking]
-----------------------------------------------------------

Temeljna teÅ¾ava globalne drÅ¾ave je, da je globalno dostopna. To omogoÄa pisanje v podatkovno zbirko prek globalne (statiÄne) metode `DB::insert()`.
V idealnem svetu bi moral biti objekt sposoben komunicirati le z drugimi objekti, ki so mu bili [neposredno posredovani |passing-dependencies].
ÄŒe ustvarim dva objekta `A` in `B` in nikoli ne prenesem reference z `A` na `B`, potem niti `A`, niti `B` ne moreta dostopati do drugega objekta ali spreminjati njegovega stanja.
To je zelo zaÅ¾elena lastnost kode. To je podobno, kot Äe bi imeli baterijo in Å¾arnico; Å¾arnica ne bo svetila, dokler ju ne poveÅ¾ete z Å¾ico.

To ne velja za globalne (statiÄne) spremenljivke ali singletone. Objekt `A` bi lahko *brezÅ¾iÄno* dostopal do objekta `C` in ga spreminjal brez posredovanja reference, tako da bi poklical `C::changeSomething()`.
ÄŒe objekt `B` zagrabi tudi globalno spremenljivko `C`, potem lahko `A` in `B` medsebojno komunicirata prek `C`.

Uporaba globalnih spremenljivk v sistem uvede novo obliko *brezÅ¾iÄne* povezave, ki navzven ni vidna.
Ustvarja dimno zaveso, ki oteÅ¾uje razumevanje in uporabo kode.
Razvijalci morajo prebrati vsako vrstico izvorne kode, da resniÄno razumejo odvisnosti. Namesto da bi se le seznanili z vmesnikom razredov.
Poleg tega gre za popolnoma nepotrebno povezovanje.

.[note]
Kar zadeva obnaÅ¡anje, ni razlike med globalno in statiÄno spremenljivko. So enako Å¡kodljive.


StraÅ¡ljivo delovanje na daljavo .[#toc-the-spooky-action-at-a-distance]
-----------------------------------------------------------------------

"Spooky action at a distance" - tako je Albert Einstein leta 1935 poimenoval pojav v kvantni fiziki, ki ga je spravil ob Å¾ivce.
Gre za kvantno prepletenost, katere posebnost je, da ko izmerite informacijo o enem delcu, takoj vplivate na drug delec, tudi Äe sta med seboj oddaljena na milijone svetlobnih let.
kar navidezno krÅ¡i temeljni zakon vesolja, da niÄ ne more potovati hitreje od svetlobe.

V svetu programske opreme lahko "straÅ¡ljivo delovanje na daljavo" imenujemo situacijo, ko zaÅ¾enemo proces, za katerega mislimo, da je izoliran (ker mu nismo posredovali nobenih referenc), vendar se na oddaljenih lokacijah sistema zgodijo nepriÄakovane interakcije in spremembe stanja, o katerih objektu nismo povedali. To se lahko zgodi le prek globalnega stanja.

Predstavljajte si, da se pridruÅ¾ite skupini za razvoj projekta, ki ima veliko in zrelo bazo kode. VaÅ¡ novi vodja vas prosi, da izvedete novo funkcijo, in kot dober razvijalec zaÄnete s pisanjem testa. Ker pa ste novinec v projektu, naredite veliko raziskovalnih testov tipa "kaj se zgodi, Äe pokliÄem to metodo". In poskuÅ¡ate napisati naslednji test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // Å¡tevilko vaÅ¡e kartice.
	$cc->charge(100);
}
```

Po doloÄenem Äasu na svojem telefonu opazite obvestila iz banke, da je bilo ob vsakem zagonu na vaÅ¡o kreditno kartico ğŸ¤¦â€â™‚ï¸ zaraÄunanih 100 dolarjev.

Kako bi lahko test povzroÄil dejansko obremenitev? S kreditno kartico ni enostavno upravljati. Sodelovati morate s spletno storitvijo tretje osebe, poznati morate naslov URL te spletne storitve, prijaviti se morate in tako naprej.
Nobena od teh informacij ni vkljuÄena v test. Å e huje, ne veste niti, kje so te informacije prisotne, in zato ne veste, kako zasmehovati zunanje odvisnosti, da se ob vsakem zagonu ne bi ponovno zaraÄunalo 100 USD. In kako naj bi kot nov razvijalec vedeli, da bo to, kar boste naredili, privedlo do tega, da boste za 100 dolarjev revnejÅ¡i?

To je straÅ¡ljivo delovanje na daljavo!

Ne preostane vam drugega, kot da se prekopate skozi veliko izvorne kode in pri tem spraÅ¡ujete starejÅ¡e in izkuÅ¡enejÅ¡e kolege, dokler ne razumete, kako delujejo povezave v projektu.
To je posledica dejstva, da ob pogledu na vmesnik razreda `CreditCard` ne morete doloÄiti globalnega stanja, ki ga je treba inicializirati. Tudi pogled v izvorno kodo razreda vam ne bo povedal, katero metodo za inicializacijo je treba poklicati. V najboljÅ¡em primeru lahko poiÅ¡Äete globalno spremenljivko, do katere se dostopa, in na podlagi tega poskuÅ¡ate uganiti, kako jo inicializirati.

Razredi v takem projektu so patoloÅ¡ki laÅ¾nivci. PlaÄilna kartica se pretvarja, da jo lahko preprosto instancirate in pokliÄete metodo `charge()`. Vendar na skrivaj sodeluje z drugim razredom, `PaymentGateway`. Tudi njegov vmesnik pravi, da ga je mogoÄe inicializirati samostojno, v resnici pa iz neke konfiguracijske datoteke potegne poverilnice in tako naprej.
Razvijalcem, ki so napisali to kodo, je jasno, da `CreditCard` potrebuje `PaymentGateway`. Zato so kodo napisali na ta naÄin. Toda za vsakogar, ki je novinec v projektu, je to popolna uganka in ovira uÄenje.

Kako popraviti situacijo? Enostavno. **Pustite, da API razglasi odvisnosti.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Opazite, kako so odnosi v kodi nenadoma oÄitni. Z izjavo, da metoda `charge()` potrebuje `PaymentGateway`, vam ni treba nikogar spraÅ¡evati, kako je koda medsebojno odvisna. Veste, da morate ustvariti njen primerek, in ko to poskuÅ¡ate storiti, naletite na dejstvo, da morate zagotoviti parametre dostopa. Brez njih se koda sploh ne bi mogla zagnati.

In kar je najpomembneje, zdaj lahko zasmehujete plaÄilni prehod, tako da vam ne bo treba plaÄati 100 dolarjev vsakiÄ, ko boste zagnali test.

Globalno stanje povzroÄa, da lahko vaÅ¡i objekti skrivaj dostopajo do stvari, ki niso deklarirane v njihovih API-jih, in poslediÄno naredi vaÅ¡e API-je patoloÅ¡ke laÅ¾nivce.

Morda o tem Å¡e niste razmiÅ¡ljali na ta naÄin, toda kadarkoli uporabljate globalno stanje, ustvarjate skrivne brezÅ¾iÄne komunikacijske kanale. StraÅ¡ljivo delovanje na daljavo sili razvijalce, da preberejo vsako vrstico kode, da bi razumeli morebitne interakcije, zmanjÅ¡uje produktivnost razvijalcev in zmede nove Älane ekipe.
ÄŒe ste kodo ustvarili vi, poznate prave odvisnosti, vsi, ki pridejo za vami, pa so nevedni.

Ne piÅ¡ite kode, ki uporablja globalno stanje, temveÄ raje prenaÅ¡ajte odvisnosti. To je vbrizgavanje odvisnosti.


Krhkost globalne drÅ¾ave .[#toc-brittleness-of-the-global-state]
---------------------------------------------------------------

V kodi, ki uporablja globalno stanje in singletone, nikoli ni gotovo, kdaj in kdo je to stanje spremenil. To tveganje je prisotno Å¾e pri inicializaciji. Naslednja koda naj bi ustvarila povezavo s podatkovno bazo in inicializirala plaÄilni prehod, vendar vedno znova vrÅ¾e izjemo, iskanje vzroka pa je izredno zamudno:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Podrobno morate pregledati kodo, da ugotovite, da objekt `PaymentGateway` brezÅ¾iÄno dostopa do drugih objektov, od katerih nekateri zahtevajo povezavo s podatkovno bazo. Tako morate inicializirati podatkovno zbirko, preden `PaymentGateway`. Vendar vam to skriva dimna zavesa globalnega stanja. Koliko Äasa bi prihranili, Äe API vsakega razreda ne bi lagal in deklariral svojih odvisnosti?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Podobna teÅ¾ava se pojavi pri uporabi globalnega dostopa do povezave s podatkovno bazo:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Pri klicu metode `save()` ni gotovo, ali je bila povezava s podatkovno bazo Å¾e ustvarjena in kdo je odgovoren za njeno ustvarjanje. ÄŒe bi na primer Å¾eleli spremeniti povezavo s podatkovno bazo sproti, morda za namene testiranja, bi verjetno morali ustvariti dodatne metode, kot sta `DB::reconnect(...)` ali `DB::reconnectForTest()`.

Oglejmo si primer:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Kje se lahko prepriÄamo, da se testna podatkovna zbirka res uporablja, ko kliÄemo `$article->save()`? Kaj pa, Äe je metoda `Foo::doSomething()` spremenila globalno povezavo s podatkovno bazo? Da bi to ugotovili, bi morali pregledati izvorno kodo razreda `Foo` in verjetno Å¡e mnogih drugih razredov. Vendar bi takÅ¡en pristop zagotovil le kratkoroÄni odgovor, saj se lahko stanje v prihodnosti spremeni.

Kaj pa, Äe povezavo s podatkovno bazo prenesemo v statiÄno spremenljivko znotraj razreda `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

To ne spremeni niÄesar. Problem je globalno stanje in ni pomembno, v katerem razredu se skriva. V tem primeru, tako kot v prejÅ¡njem, nimamo pojma, v katero zbirko podatkov se zapiÅ¡e, ko se kliÄe metoda `$article->save()`. Kdorkoli na oddaljenem koncu aplikacije lahko kadarkoli spremeni podatkovno zbirko z uporabo metode `Article::setDb()`. Pod naÅ¡imi rokami.

Zaradi globalnega stanja je naÅ¡a aplikacija **izjemno obÄutljiva**.

Vendar obstaja preprost naÄin za reÅ¡evanje te teÅ¾ave. Preprosto zahtevajte, da API razglasi odvisnosti, da se zagotovi pravilno delovanje.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Ta pristop odpravlja skrb zaradi skritih in nepriÄakovanih sprememb povezav s podatkovno bazo. Zdaj smo prepriÄani, kje je shranjen Älanek, in nobena sprememba kode znotraj drugega nepovezanega razreda ne more veÄ spremeniti stanja. Koda ni veÄ krhka, temveÄ stabilna.

Ne piÅ¡ite kode, ki uporablja globalno stanje, temveÄ raje prenaÅ¡ajte odvisnosti. Tako je na voljo vbrizgavanje odvisnosti (dependency injection).


Singleton .[#toc-singleton]
---------------------------

Singleton je oblikovni vzorec, ki po [definiciji |https://en.wikipedia.org/wiki/Singleton_pattern] iz znane publikacije Gang of Four omejuje razred na en primerek in mu omogoÄa globalni dostop. Izvedba tega vzorca je obiÄajno podobna naslednji kodi:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// in druge metode, ki izvajajo funkcije razreda
}
```

Na Å¾alost singleton v aplikacijo vnese globalno stanje. Kot smo pokazali zgoraj, je globalno stanje nezaÅ¾eleno. Zato singleton velja za protivzorec.

V svoji kodi ne uporabljajte singletonov in jih nadomestite z drugimi mehanizmi. Singletonov resniÄno ne potrebujete. ÄŒe pa morate zagotoviti obstoj enega primerka razreda za celotno aplikacijo, to prepustite [vsebniku DI |container].
Tako ustvarite aplikacijski singleton ali storitev. S tem razred ne bo veÄ zagotavljal svoje edinstvenosti (tj. ne bo imel metode `getInstance()` in statiÄne spremenljivke) in bo izvajal le svoje funkcije. Tako bo prenehal krÅ¡iti naÄelo ene odgovornosti.


Globalno stanje v primerjavi s testi .[#toc-global-state-versus-tests]
----------------------------------------------------------------------

Pri pisanju testov predpostavljamo, da je vsak test izolirana enota in da vanj ne vstopa zunanje stanje. In nobeno stanje ne zapusti testov. Ko se test konÄa, mora zbiralnik smeti samodejno odstraniti vsako stanje, povezano s testom. S tem so testi izolirani. Zato lahko teste izvajamo v poljubnem vrstnem redu.

ÄŒe pa so prisotna globalna stanja/singletoni, se vse te lepe predpostavke poruÅ¡ijo. Stanje lahko vstopi v test in izstopi iz njega. Nenadoma je vrstni red testov lahko pomemben.

Da bi razvijalci sploh lahko testirali singletone, morajo pogosto omiliti njihove lastnosti, morda tako, da dovolijo zamenjavo primerka z drugim. TakÅ¡ne reÅ¡itve so v najboljÅ¡em primeru kretnje, ki ustvarjajo kodo, ki jo je teÅ¾ko vzdrÅ¾evati in razumeti. Vsak test ali metoda `tearDown()`, ki vpliva na katero koli globalno stanje, mora te spremembe razveljaviti.

Globalno stanje je najveÄji glavobol pri testiranju enot!

Kako popraviti situacijo? Enostavno. Ne piÅ¡ite kode, ki uporablja singletone, ampak raje prenaÅ¡ajte odvisnosti. To je vbrizgavanje odvisnosti.


Globalne konstante .[#toc-global-constants]
-------------------------------------------

Globalno stanje ni omejeno na uporabo singletonov in statiÄnih spremenljivk, temveÄ se lahko uporablja tudi za globalne konstante.

Konstante, katerih vrednost nam ne zagotavlja nobenih novih (`M_PI`) ali koristnih (`PREG_BACKTRACK_LIMIT_ERROR`) informacij, so nedvomno v redu.
Nasprotno pa konstante, ki sluÅ¾ijo kot naÄin za *brezÅ¾iÄno* posredovanje informacij znotraj kode, niso niÄ drugega kot skrita odvisnost. Kot je `LOG_FILE` v naslednjem primeru.
Uporaba konstante `FILE_APPEND` je popolnoma pravilna.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

V tem primeru moramo parameter deklarirati v konstruktorju razreda `Foo`, da postane del API-ja:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Zdaj lahko posredujemo informacije o poti do datoteke za beleÅ¾enje in jih po potrebi preprosto spremenimo, kar olajÅ¡a testiranje in vzdrÅ¾evanje kode.


Globalne funkcije in statiÄne metode .[#toc-global-functions-and-static-methods]
--------------------------------------------------------------------------------

Poudariti Å¾elimo, da uporaba statiÄnih metod in globalnih funkcij sama po sebi ni problematiÄna. RazloÅ¾ili smo neprimernost uporabe `DB::insert()` in podobnih metod, vedno pa je Å¡lo za globalno stanje, shranjeno v statiÄni spremenljivki. Metoda `DB::insert()` zahteva obstoj statiÄne spremenljivke, ker shranjuje povezavo s podatkovno bazo. Brez te spremenljivke metode ne bi bilo mogoÄe izvesti.

Uporaba deterministiÄnih statiÄnih metod in funkcij, kot so `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` in Å¡tevilne druge, je popolnoma skladna z vbrizgavanjem odvisnosti. Te funkcije iz istih vhodnih parametrov vedno vrnejo enake rezultate in so zato predvidljive. Ne uporabljajo nobenega globalnega stanja.

Vendar v PHP obstajajo funkcije, ki niso deterministiÄne. Med njimi je na primer funkcija `htmlspecialchars()`. Njen tretji parameter, `$encoding`, Äe ni doloÄen, je privzeta vrednost konfiguracijske moÅ¾nosti `ini_get('default_charset')`. Zato je priporoÄljivo, da ta parameter vedno navedete, da se izognete morebitnemu nepredvidljivemu obnaÅ¡anju funkcije. Nette to dosledno poÄne.

Nekatere funkcije, kot so `strtolower()`, `strtoupper()` in podobne, so imele v bliÅ¾nji preteklosti nedeterministiÄno obnaÅ¡anje in so bile odvisne od nastavitve `setlocale()`. To je povzroÄilo Å¡tevilne zaplete, najpogosteje pri delu s turÅ¡kim jezikom.
TurÅ¡ki jezik namreÄ razlikuje med velikimi in malimi Ärkami `I` s piko in brez nje. Tako je `strtolower('I')` vrnil znak `Ä±`, `strtoupper('i')` pa znak `Ä°`, zaradi Äesar so aplikacije povzroÄale Å¡tevilne skrivnostne napake.
Vendar je bila ta teÅ¾ava odpravljena v razliÄici PHP 8.2 in funkcije niso veÄ odvisne od lokalnega jezika.

To je lep primer, kako je globalno stanje prizadelo na tisoÄe razvijalcev po vsem svetu. ReÅ¡itev je bila zamenjava z vbrizgavanjem odvisnosti.


Kdaj je mogoÄe uporabiti globalno stanje? .[#toc-when-is-it-possible-to-use-global-state]
-----------------------------------------------------------------------------------------

V nekaterih posebnih primerih je mogoÄe uporabiti globalno stanje. Na primer pri razhroÅ¡Äevanju kode, ko morate izpisati vrednost spremenljivke ali izmeriti trajanje doloÄenega dela programa. V takih primerih, ki zadevajo zaÄasna dejanja, ki bodo pozneje odstranjena iz kode, je upraviÄena uporaba globalno razpoloÅ¾ljivega odlagalnika ali Å¡toparice. Ta orodja niso del zasnove kode.

Drug primer so funkcije za delo z regularnimi izrazi `preg_*`, ki interno shranjujejo sestavljene regularne izraze v statiÄni predpomnilnik v pomnilniku. Kadar isti regularni izraz veÄkrat pokliÄete v razliÄnih delih kode, se sestavi samo enkrat. Predpomnilnik prihrani zmogljivost, poleg tega pa je za uporabnika popolnoma neviden, zato lahko takÅ¡no uporabo Å¡tejemo za zakonito.


Povzetek .[#toc-summary]
------------------------

Pokazali smo, zakaj je smiselno

1) Odstranite vse statiÄne spremenljivke iz kode
2) Deklarirajte odvisnosti
3) In uporabite vbrizgavanje odvisnosti

Ko razmiÅ¡ljate o oblikovanju kode, imejte v mislih, da vsaka stran `static $foo` predstavlja teÅ¾avo. ÄŒe Å¾elite, da bo vaÅ¡a koda okolje, ki spoÅ¡tuje DI, nujno popolnoma izkoreniniti globalno stanje in ga nadomestiti z vbrizgavanjem odvisnosti.

Med tem postopkom boste morda ugotovili, da morate razred razdeliti, ker ima veÄ kot eno odgovornost. Ne skrbite zaradi tega; prizadevajte si za naÄelo ene odgovornosti.

*Zahvaljujem se MiÅ¡ku Heveryju, Äigar Älanki, kot je [Flaw: Brittle Global State & Singletons |http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], so podlaga za to poglavje.*
