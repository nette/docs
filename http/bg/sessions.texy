Сесии
*****

<div class=perex>

HTTP е протокол без състояние, но почти всяко приложение трябва да съхранява състояние между заявките, например съдържанието на количката за пазаруване. Именно за това служат сесиите. Ще покажем,

- как да използваме сесии
- как да предотвратим конфликти на имена
- как да настроим изтичане

</div>

При използване на сесии всеки потребител получава уникален идентификатор, наречен session ID, който се предава в бисквитка. Той служи като ключ към данните на сесията. За разлика от бисквитките, които се съхраняват от страна на браузъра, данните в сесията се съхраняват от страна на сървъра.

Сесията се настройва в [конфигурацията |configuration#Сесия], важен е особено изборът на времето за изтичане.

Управлението на сесията се осъществява от обекта [api:Nette\Http\Session], до който можете да стигнете, като го получите чрез [dependency injection |dependency-injection:passing-dependencies]. В презентерите е достатъчно само да извикате `$session = $this->getSession()`.

→ [Инсталация и изисквания |@home#Инсталация]


Стартиране на сесия
===================

Nette по подразбиране автоматично стартира сесията в момента, когато започнем да четем от нея или да записваме данни в нея. Ръчно сесията се стартира с `$session->start()`.

PHP изпраща при стартиране на сесията HTTP хедъри, влияещи на кеширането, виж [php:session_cache_limiter], и евентуално и бисквитка със session ID. Затова е необходимо винаги да стартирате сесията преди изпращането на какъвто и да е изход към браузъра, иначе ще бъде хвърлено изключение. Ако знаете, че по време на рендирането на страницата ще се използва сесия, стартирайте я ръчно преди това, например в презентера.

В режим на разработка сесията се стартира от Tracy, тъй като я използва за показване на ленти с пренасочвания и AJAX заявки в Tracy Bar.


Секции
======

В чист PHP хранилището на данни на сесията се реализира като масив, достъпен чрез глобалната променлива `$_SESSION`. Проблемът е, че приложенията обикновено се състоят от цяла редица взаимно независими части и ако всички имат на разположение само един масив, рано или късно ще възникне конфликт на имена.

Nette Framework решава проблема, като разделя цялото пространство на секции (обекти [api:Nette\Http\SessionSection]). Всяка единица след това използва своя собствена секция с уникално име и вече не може да възникне никакъв конфликт.

Секцията получаваме от сесията:

```php
$section = $session->getSection('уникално_име');
```

В презентера е достатъчно да използвате `getSession()` с параметър:

```php
// $this е Presenter
$section = $this->getSession('уникално_име');
```

Проверката за съществуване на секция може да се направи с метода `$session->hasSection('уникално_име')`.

Със самата секция след това се работи много лесно с помощта на методите `set()`, `get()` и `remove()`:

```php
// запис на променлива
$section->set('userName', 'franta');

// четене на променлива, връща null, ако не съществува
echo $section->get('userName');

// изтриване на променлива
$section->remove('userName');
```

За получаване на всички променливи от секцията може да се използва цикъл `foreach`:

```php
foreach ($section as $key => $val) {
	echo "$key = $val";
}
```


Настройка на изтичане
---------------------

За отделни секции или дори отделни променливи е възможно да се настрои изтичане. Можем така да оставим изтичането на влизането на потребителя след 20 минути, но същевременно да продължим да помним съдържанието на количката.

```php
// секцията изтича след 20 минути
$section->setExpiration('20 minutes');
```

За настройка на изтичането на отделни променливи служи третият параметър на метода `set()`:

```php
// променливата 'flash' изтича след 30 секунди
$section->set('flash', $message, '30 seconds');
```

.[note]
Не забравяйте, че времето за изтичане на цялата сесия (виж [конфигурация на сесията |configuration#Сесия]) трябва да бъде същото или по-голямо от времето, зададено за отделните секции или променливи.

Отмяната на предишно зададено изтичане се постига с метода `removeExpiration()`. Незабавното отменяне на цялата секция осигурява методът `remove()`.


Събития $onStart, $onBeforeWrite
--------------------------------

Обектът `Nette\Http\Session` има [събития |nette:glossary#Събития events] `$onStart` и `$onBeforeWrite`, така че можете да добавите callback-ове, които се извикват след стартиране на сесията или преди нейното записване на диска и последващо прекратяване.

```php
$session->onBeforeWrite[] = function () {
	// записваме данни в сесията
	$this->section->set('basket', $this->basket);
};
```


Управление на сесии
===================

Преглед на методите на класа `Nette\Http\Session` за управление на сесии:

<div class=wiki-methods-brief>


start(): void .[method]
-----------------------
Стартира сесията.


isStarted(): bool .[method]
---------------------------
Сесията стартирана ли е?


close(): void .[method]
-----------------------
Прекратява сесията. Сесията автоматично се прекратява в края на изпълнението на скрипта.


destroy(): void .[method]
-------------------------
Прекратява и изтрива сесията.


exists(): bool .[method]
------------------------
HTTP заявката съдържа ли бисквитка със session ID?


regenerateId(): void .[method]
------------------------------
Генерира нов случаен session ID. Данните остават запазени.


getId(): string .[method]
-------------------------
Връща session ID.

</div>


Конфигурация
------------

Сесията се настройва в [конфигурацията |configuration#Сесия]. Ако пишете приложение, което не използва DI контейнер, за конфигурация служат тези методи. Трябва да бъдат извикани преди стартирането на сесията.

<div class=wiki-methods-brief>


setName(string $name): static .[method]
---------------------------------------
Задава името на бисквитката, в която се пренася session ID. Стандартното име е `PHPSESSID`. Полезно е в случай, че в рамките на един сайт поддържате няколко различни приложения.


getName(): string .[method]
---------------------------
Връща името на бисквитката, в която се пренася session ID.


setOptions(array $options): static .[method]
--------------------------------------------
Конфигурира сесията. Могат да се настройват всички PHP [session директиви |https://www.php.net/manual/en/session.configuration.php] (във формат camelCase, напр. вместо `session.save_path` записваме `savePath`) и също [readAndClose |https://www.php.net/manual/en/function.session-start.php#refsect1-function.session-start-parameters].


setExpiration(?string $time): static .[method]
----------------------------------------------
Задава времето на неактивност, след което сесията изтича.


setCookieParameters(string $path, ?string $domain=null, ?bool $secure=null, ?string $samesite=null): static .[method]
---------------------------------------------------------------------------------------------------------------------
Настройка на параметрите за бисквитката. Стойностите по подразбиране на параметрите можете да промените в [конфигурацията |configuration#Бисквитка за сесия].


setSavePath(string $path): static .[method]
-------------------------------------------
Задава директорията, където се съхраняват файловете със сесиите.


setHandler(\SessionHandlerInterface $handler): static .[method]
---------------------------------------------------------------
Настройка на собствен handler, виж [документацията на PHP|https://www.php.net/manual/en/class.sessionhandlerinterface.php].

</div>


Сигурността преди всичко
========================

Сървърът предполага, че комуникира постоянно със същия потребител, докато заявките са придружени от същия session ID. Задачата на механизмите за сигурност е да гарантират, че това наистина е така и не е възможно идентификаторът да бъде откраднат или подменен.

Nette Framework затова правилно конфигурира PHP директивите, така че session ID да се пренася само в бисквитка, да го направи недостъпен за JavaScript и да игнорира евентуални идентификатори в URL. Освен това в критични моменти, като например влизане на потребителя, генерира нов session ID.

.[note]
За конфигурация на PHP се използва функцията ini_set, която за съжаление някои хостинги забраняват. Ако това е случаят и с вашия хостинг, опитайте да се договорите с него да ви разреши функцията или поне да конфигурира сървъра.
