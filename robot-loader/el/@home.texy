RobotLoader: Αυτόματη φόρτωση κλάσης
************************************
<div class=perex>


Το RobotLoader είναι ένα εργαλείο που σας δίνει την άνεση της αυτοματοποιημένης φόρτωσης κλάσεων για ολόκληρη την εφαρμογή σας, συμπεριλαμβανομένων των βιβλιοθηκών τρίτων κατασκευαστών.

- απαλλαγείτε από όλα `require`
- φορτώνονται μόνο τα απαραίτητα σενάρια
- δεν απαιτεί αυστηρές συμβάσεις ονοματοδοσίας καταλόγων ή αρχείων

</div>

Μπορούμε λοιπόν να ξεχάσουμε αυτά τα περίφημα μπλοκ κώδικα:

```php
require_once 'Utils/Page.php';
require_once 'Utils/Style.php';
require_once 'Utils/Paginator.php';
// ...
```


Εγκατάσταση .[#toc-installation]
--------------------------------

Κατεβάστε και εγκαταστήστε το πακέτο χρησιμοποιώντας το [Composer |best-practices:composer]:

```shell
composer require nette/robot-loader
```


Χρήση .[#toc-usage]
-------------------

Όπως το ρομπότ της Google ανιχνεύει και ευρετηριάζει ιστότοπους, το [RobotLoader |api:Nette\Loaders\RobotLoader] ανιχνεύει όλα τα σενάρια PHP και καταγράφει ποιες κλάσεις και διεπαφές βρέθηκαν σε αυτά. Αυτές οι εγγραφές αποθηκεύονται στη συνέχεια στην κρυφή μνήμη και χρησιμοποιούνται κατά τη διάρκεια όλων των επόμενων αιτήσεων. Απλά πρέπει να καθορίσετε ποιοι κατάλογοι θα ευρετηριαστούν και πού θα αποθηκευτεί η κρυφή μνήμη:

```php
$loader = new Nette\Loaders\RobotLoader;

// κατάλογοι που θα ευρετηριαστεί από το RobotLoader (συμπεριλαμβανομένων των υποκαταλόγων)
$loader->addDirectory(__DIR__ . '/app');
$loader->addDirectory(__DIR__ . '/libs');

// χρήση του καταλόγου 'temp' για την κρυφή μνήμη
$loader->setTempDirectory(__DIR__ . '/temp');
$loader->register(); // Εκτέλεση του RobotLoader
```

Και αυτό είναι όλο. Από εδώ και στο εξής, δεν χρειάζεται να χρησιμοποιείτε το `require`. Υπέροχα, έτσι δεν είναι;

Όταν το RobotLoader συναντά διπλότυπο όνομα κλάσης κατά τη διάρκεια της ευρετηρίασης, πετάει μια εξαίρεση και σας ενημερώνει σχετικά. Ο RobotLoader ενημερώνει επίσης αυτόματα την κρυφή μνήμη όταν πρέπει να φορτώσει μια κλάση που δεν γνωρίζει. Συνιστούμε να το απενεργοποιήσετε αυτό στους διακομιστές παραγωγής, δείτε την ενότητα [Caching |#Caching].

Αν θέλετε ο RobotLoader να παραλείψει κάποιους καταλόγους, χρησιμοποιήστε το `$loader->excludeDirectory('temp')` (μπορεί να κληθεί πολλές φορές ή μπορείτε να περάσετε πολλούς καταλόγους).

Από προεπιλογή, ο RobotLoader αναφέρει σφάλματα σε αρχεία PHP με την εμφάνιση εξαιρέσεων `ParseError`. Μπορεί να απενεργοποιηθεί μέσω του `$loader->reportParseErrors(false)`.


Εφαρμογή Nette .[#toc-nette-application]
----------------------------------------

Μέσα στην εφαρμογή Nette, όπου το `$configurator` χρησιμοποιείται στο `Bootstrap.php`, μπορείτε να ρυθμίσετε το RobotLoader με αυτόν τον τρόπο:

```php
$configurator = new Nette\Bootstrap\Configurator;
// ...
$configurator->setTempDirectory(__DIR__ . '/../temp');
$configurator->createRobotLoader()
	->addDirectory(__DIR__)
	->addDirectory(__DIR__ . '/../libs')
	->register();
```


PHP Files Analyzer .[#toc-php-files-analyzer]
---------------------------------------------

Το RobotLoader μπορεί επίσης να χρησιμοποιηθεί καθαρά για την εύρεση κλάσεων, διεπαφών και χαρακτηριστικών σε αρχεία PHP **χωρίς** να χρησιμοποιεί τη δυνατότητα αυτόματης φόρτωσης:

```php
$loader = new Nette\Loaders\RobotLoader;
$loader->addDirectory(__DIR__ . '/app');

// Σαρώνει καταλόγους για κλάσεις / διεπαφές / γνωρίσματα
$loader->rebuild();

// Επιστρέφει πίνακα με ζεύγη κλάσεων => ονόματα αρχείων
$res = $loader->getIndexedClasses();
```

Ακόμα και με μια τέτοια χρήση, μπορείτε να χρησιμοποιήσετε την κρυφή μνήμη. Ως αποτέλεσμα, τα μη τροποποιημένα αρχεία δεν θα αναλύονται επανειλημμένα κατά την εκ νέου σάρωση:

```php
$loader = new Nette\Loaders\RobotLoader;
$loader->addDirectory(__DIR__ . '/app');
$loader->setTempDirectory(__DIR__ . '/temp');

// Σαρώνει καταλόγους χρησιμοποιώντας μια κρυφή μνήμη
$loader->refresh();

// Επιστρέφει πίνακα ζευγών κλάσης => όνομα αρχείου
$res = $loader->getIndexedClasses();
```


Caching .[#toc-caching]
-----------------------

Το RobotLoader είναι πολύ γρήγορο επειδή χρησιμοποιεί έξυπνα την κρυφή μνήμη.

Όταν αναπτύσσετε με αυτό, δεν έχετε σχεδόν καμία ιδέα ότι εκτελείται στο παρασκήνιο. Ενημερώνει συνεχώς την κρυφή μνήμη επειδή γνωρίζει ότι κλάσεις και αρχεία μπορούν να δημιουργηθούν, να διαγραφούν, να μετονομαστούν κ.λπ. Και δεν σαρώνει επανειλημμένα μη τροποποιημένα αρχεία.

Όταν χρησιμοποιείται σε έναν διακομιστή παραγωγής, από την άλλη πλευρά, συνιστούμε να απενεργοποιήσετε την ενημέρωση της κρυφής μνήμης χρησιμοποιώντας το `$loader->setAutoRefresh(false)` (αυτό γίνεται αυτόματα στην εφαρμογή Nette), επειδή τα αρχεία δεν αλλάζουν. Ταυτόχρονα, είναι απαραίτητο να **καθαρίσετε την προσωρινή μνήμη cache** όταν ανεβάζετε μια νέα έκδοση στη φιλοξενία.

Φυσικά, η αρχική σάρωση των αρχείων, όταν η προσωρινή μνήμη δεν υπάρχει ήδη, μπορεί να διαρκέσει μερικά δευτερόλεπτα για μεγαλύτερες εφαρμογές. Το RobotLoader διαθέτει ενσωματωμένη πρόληψη κατά του "αφηνιασμού της κρυφής μνήμης":https://en.wikipedia.org/wiki/Cache_stampede.
Πρόκειται για μια κατάσταση κατά την οποία ο διακομιστής παραγωγής λαμβάνει μεγάλο αριθμό ταυτόχρονων αιτήσεων και επειδή η προσωρινή μνήμη cache του RobotLoader δεν υπάρχει ακόμη, θα ξεκινούσαν όλες να σαρώνουν τα αρχεία. Πράγμα που αυξάνει τη χρήση της CPU και του συστήματος αρχείων.
Ευτυχώς, το RobotLoader λειτουργεί με τέτοιο τρόπο ώστε για πολλαπλές ταυτόχρονες αιτήσεις, μόνο το πρώτο νήμα ευρετηριάζει τα αρχεία, δημιουργεί μια κρυφή μνήμη, οι υπόλοιποι περιμένουν και στη συνέχεια χρησιμοποιούν την κρυφή μνήμη.


PSR-4 .[#toc-psr-4]
-------------------

Σήμερα, το Composer μπορεί να χρησιμοποιηθεί για [αυτόματη φόρτωση |best-practices:composer#autoloading] σύμφωνα με το PSR-4. Με απλά λόγια, πρόκειται για ένα σύστημα όπου τα namespaces και τα ονόματα των κλάσεων αντιστοιχούν στη δομή των καταλόγων και των ονομάτων των αρχείων, δηλαδή το `App\Router\RouterFactory` βρίσκεται στο αρχείο `/path/to/App/Router/RouterFactory.php`.

Το RobotLoader δεν συνδέεται με καμία σταθερή δομή, επομένως, είναι χρήσιμο σε περιπτώσεις όπου δεν σας βολεύει να έχετε τη δομή καταλόγου σχεδιασμένη ως namespaces στην PHP, ή όταν αναπτύσσετε μια εφαρμογή που ιστορικά δεν έχει χρησιμοποιήσει τέτοιες συμβάσεις. Είναι επίσης δυνατό να χρησιμοποιήσετε και τους δύο φορτωτές μαζί.


{{leftbar: nette:@menu-topics}}
