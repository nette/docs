Model
**************

Na začátku jsme modelovou vrstvu přeskočili, abychom se rychle dostali k potřebným datům. To se ale v praxi téměř nedělá. Na ukázku to stačilo, ale u větších projektů bychom brzy zaplakali ;-). Zrefaktorujeme si tedy aplikaci a vytvoříme si modelovou vrstvu. Tedy tu vrstvu, která nás v presenteru oddělí od přímé komunikace s databází a zaštítí to pod pěkné API.


[* quick-manager.png *]


V adresáři `app/model/` vytvoříme naši modelovou třídu, která se nám bude starat o články, a pojmenujeme ji `ArticlesManager.php`.


/---php
<?php

namespace App\Model;

use Nette;

/**
 * Article management.
 */
class ArticleManager extends Nette\Object
{


}

\--

Zároveň ji zaregistrujeme v `app/config/config.neon` v sekci services. Takto registrovaná třída se nazývá **služba**. Nepotřebujeme ji pojmenovat, tak na začátek přidáme pouze odrážku. Nezapomeňme na namespace, ve kterém je třída definována.


/--neon
services:
	- App\Forms\SignFormFactory
	router: App\RouterFactory::createRouter
	- App\Model\ArticleManager
\--

Tím Nette a jeho "DI Containeru":dependency-injection sdělujeme, že pokud se někdo ptal na tuhle třídu, tak víš, kde ji hledat, dej ji vše co potřebuje k životu a připrav nám ji pro použití v dalších třídách.



Přepneme se do HomepagePresenter.php, který upravíme tak, že se zbavíme závislosti na `Nette\Database\Context` a nahradíme za novou závislost na naší nové třídě.


/--php
<?php

namespace App\Presenters;

use Nette,
	App\Model;

/**
 * Homepage presenter.
 */
class HomepagePresenter extends BasePresenter
{
	/** @var Model\ArticleManager */
	private $articleManager;

	public function __construct(Model\ArticleManager $articleManager)
	{
		$this->articleManager = $articleManager;
	}


	public function renderDefault()
	{
		$this->template->posts = $this->articleManager->findAll()->limit(5);
	}

}


\--
.[tip]
V sekci `use` máme `App/Model`, tak si můžeme zápis v PHP kódu zkrátit na `Model\ArticleManager` (nebojte, i v komentářových anotacích to funguje a vaše chytré IDE by si s tím mělo poradit).



V konstruktoru si požádáme o ArticleManager. Ten nám předá nám už známý DI Container a tento ArticleManager si přiřadíme do private property. V metodě `renderDefault` zavoláme metodu `findAll` (která v tuto chvíli neexistuje) a nad výsledkem, co se nám vrátí, zavoláme ještě metodu `limit(5);`


Doplníme si tedy do našeho managera metodu `findAll`:


app/model/ArticleManager.php

/--php
//...
public function findAll()
{
	return $this->database->table('posts')
		->order('created_at DESC');
}
//...
\--

Do této metody jsme přesunuli kus kódu, co se dotazoval databáze na články. Zde tedy používáme property `database`, kterou ale nemáme nikde definovanou. Tak si ji definujeme a její obsah naplníme tím, o co si vyžádáme v konstruktoru.

/--php
//...
/**
 * @var Nette\Database\Context
 */
private $database;


public function __construct(Nette\Database\Context $database)
{
	$this->database = $database;
}
//...
\--

Celý kód pak vypadá následovně:

/--php
<?php

namespace App\Model;

use Nette;

/**
 * Article management.
 */
class ArticleManager extends Nette\Object
{

	/**
	 * @var Nette\Database\Context
	 */
	private $database;


	public function __construct(Nette\Database\Context $database)
	{
		$this->database = $database;
	}


	public function findAll()
	{
		return $this->database->table('posts')
			->order('created_at DESC');

	}

}

\--



Třída `ArticleManager` si v konstruktoru řekne o předání `Nette\Database\Context` a jelikož tato třída je v DI containeru zaregistrovaná, vytvoří její instancí a předá. DI za nás takto vytvoří instanci ArticleManagera a předá ho v konstruktoru HomepagePresenter, který si o něj požádal. Taková matroška :) Všichni si jen říkají, co chtějí, a nezajímají se o to, kde se to vytváří. O to se postará Nette DI Container.
