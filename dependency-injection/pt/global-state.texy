Estado Global e Singletons
**************************

.[perex]
Aviso: As seguintes constru√ß√µes s√£o um sinal de c√≥digo mal projetado:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ou `static::$var`

Alguma dessas constru√ß√µes ocorre em seu c√≥digo? Ent√£o voc√™ tem a oportunidade de melhor√°-lo. Voc√™ pode pensar que s√£o constru√ß√µes comuns que voc√™ v√™ at√© mesmo em solu√ß√µes de exemplo de v√°rias bibliotecas e frameworks. Se for esse o caso, ent√£o o design do c√≥digo deles n√£o √© bom.

Agora, definitivamente n√£o estamos falando de alguma pureza acad√™mica. Todas essas constru√ß√µes t√™m uma coisa em comum: elas usam estado global. E isso tem um impacto destrutivo na qualidade do c√≥digo. As classes mentem sobre suas depend√™ncias. O c√≥digo se torna imprevis√≠vel. Confunde os programadores e reduz sua efici√™ncia.

Neste cap√≠tulo, explicaremos por que isso acontece e como evitar o estado global.


Acoplamento Global
------------------

Em um mundo ideal, um objeto s√≥ deveria ser capaz de se comunicar com objetos que lhe foram [passados diretamente |passing-dependencies]. Se eu criar dois objetos `A` e `B` e nunca passar uma refer√™ncia entre eles, ent√£o nem `A` nem `B` podem acessar o outro objeto ou alterar seu estado. Esta √© uma propriedade muito desej√°vel do c√≥digo. √â semelhante a ter uma bateria e uma l√¢mpada; a l√¢mpada n√£o acender√° at√© que voc√™ a conecte √† bateria com um fio.

Mas isso n√£o se aplica a vari√°veis globais (est√°ticas) ou singletons. O objeto `A` poderia acessar *sem fio* o objeto `C` e modific√°-lo sem qualquer passagem de refer√™ncia, chamando `C::changeSomething()`. Se o objeto `B` tamb√©m pegar o `C` global, ent√£o `A` e `B` podem se influenciar mutuamente atrav√©s de `C`.

O uso de vari√°veis globais introduz no sistema uma nova forma de acoplamento *sem fio*, que n√£o √© vis√≠vel de fora. Cria uma cortina de fuma√ßa complicando a compreens√£o e o uso do c√≥digo. Para que os desenvolvedores realmente entendam as depend√™ncias, eles precisam ler cada linha do c√≥digo-fonte. Em vez de apenas se familiarizarem com as interfaces das classes. Al√©m disso, √© um acoplamento completamente desnecess√°rio. O estado global √© usado porque √© facilmente acess√≠vel de qualquer lugar e permite, por exemplo, escrever no banco de dados atrav√©s do m√©todo global (est√°tico) `DB::insert()`. Mas, como mostraremos, a vantagem que isso traz √© insignificante, enquanto as complica√ß√µes que causa s√£o fatais.

.[note]
Do ponto de vista do comportamento, n√£o h√° diferen√ßa entre uma vari√°vel global e est√°tica. Elas s√£o igualmente prejudiciais.


A√ß√£o fantasmag√≥rica √† dist√¢ncia
-------------------------------

"A√ß√£o fantasmag√≥rica √† dist√¢ncia" - foi assim que Albert Einstein famosamente chamou, em 1935, um fen√¥meno na f√≠sica qu√¢ntica que lhe causava arrepios.
Trata-se do emaranhamento qu√¢ntico, cuja peculiaridade √© que, quando voc√™ mede a informa√ß√£o sobre uma part√≠cula, influencia instantaneamente a outra part√≠cula, mesmo que estejam a milh√µes de anos-luz de dist√¢ncia.
Isso aparentemente viola a lei fundamental do universo de que nada pode se propagar mais r√°pido que a luz.

No mundo do software, podemos chamar de "a√ß√£o fantasmag√≥rica √† dist√¢ncia" a situa√ß√£o em que iniciamos um processo que acreditamos ser isolado (porque n√£o passamos nenhuma refer√™ncia a ele), mas em locais remotos do sistema ocorrem intera√ß√µes inesperadas e mudan√ßas de estado das quais n√£o t√≠nhamos conhecimento. Isso s√≥ pode acontecer atrav√©s do estado global.

Imagine que voc√™ se junta a uma equipe de desenvolvedores de um projeto que tem uma base de c√≥digo extensa e madura. Seu novo l√≠der pede que voc√™ implemente uma nova funcionalidade e voc√™, como um bom desenvolvedor, come√ßa escrevendo um teste. Mas como voc√™ √© novo no projeto, faz muitos testes explorat√≥rios do tipo "o que acontece se eu chamar este m√©todo". E tenta escrever o seguinte teste:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // n√∫mero do seu cart√£o
	$cc->charge(100);
}
```

Voc√™ executa o c√≥digo, talvez v√°rias vezes, e depois de um tempo percebe notifica√ß√µes do banco no seu celular informando que a cada execu√ß√£o foram debitados 100 d√≥lares do seu cart√£o de cr√©dito ü§¶‚Äç‚ôÇÔ∏è

Como diabos o teste p√¥de causar um d√©bito real de dinheiro? Operar com um cart√£o de cr√©dito n√£o √© f√°cil. Voc√™ precisa se comunicar com um servi√ßo web de terceiros, precisa saber a URL desse servi√ßo web, precisa fazer login e assim por diante.
Nenhuma dessas informa√ß√µes est√° contida no teste. Pior ainda, voc√™ nem sabe onde essas informa√ß√µes est√£o presentes e, portanto, nem como mockar as depend√™ncias externas para que cada execu√ß√£o n√£o leve a um novo d√©bito de 100 d√≥lares. E como voc√™, como novo desenvolvedor, deveria saber que o que estava prestes a fazer resultaria em ficar 100 d√≥lares mais pobre?

Isso √© a√ß√£o fantasmag√≥rica √† dist√¢ncia!

Voc√™ n√£o tem escolha a n√£o ser vasculhar longamente um monte de c√≥digo-fonte, perguntar aos colegas mais velhos e experientes, at√© entender como as liga√ß√µes no projeto funcionam.
Isso ocorre porque, ao olhar para a interface da classe `CreditCard`, n√£o √© poss√≠vel identificar o estado global que precisa ser inicializado. Mesmo olhar para o c√≥digo-fonte da classe n√£o revela qual m√©todo de inicializa√ß√£o voc√™ deve chamar. Na melhor das hip√≥teses, voc√™ pode encontrar uma vari√°vel global que est√° sendo acessada e, a partir dela, tentar adivinhar como inicializ√°-la.

As classes em tal projeto s√£o mentirosas patol√≥gicas. O cart√£o de cr√©dito finge que basta instanci√°-lo e chamar o m√©todo `charge()`. Secretamente, por√©m, ele colabora com outra classe `PaymentGateway`, que representa o gateway de pagamento. Sua interface tamb√©m diz que pode ser inicializada separadamente, mas na realidade ela extrai credenciais de algum arquivo de configura√ß√£o e assim por diante.
Para os desenvolvedores que escreveram este c√≥digo, est√° claro que `CreditCard` precisa de `PaymentGateway`. Eles escreveram o c√≥digo desta forma. Mas para qualquer pessoa nova no projeto, √© um mist√©rio absoluto e impede o aprendizado.

Como consertar a situa√ß√£o? Facilmente. **Deixe a API declarar as depend√™ncias.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Observe como as interconex√µes dentro do c√≥digo se tornam repentinamente √≥bvias. Como o m√©todo `charge()` declara que precisa de `PaymentGateway`, voc√™ n√£o precisa perguntar a ningu√©m como o c√≥digo est√° interconectado. Voc√™ sabe que precisa criar sua inst√¢ncia e, ao tentar faz√™-lo, descobrir√° que precisa fornecer par√¢metros de acesso. Sem eles, o c√≥digo nem sequer seria executado.

E, o mais importante, agora voc√™ pode mockar o gateway de pagamento, para n√£o ser cobrado 100 d√≥lares toda vez que executar o teste.

O estado global faz com que seus objetos possam acessar secretamente coisas que n√£o s√£o declaradas em sua API e, como resultado, tornam suas APIs mentirosas patol√≥gicas.

Talvez voc√™ n√£o tenha pensado nisso antes, mas sempre que usa estado global, est√° criando canais de comunica√ß√£o secretos sem fio. A a√ß√£o fantasmag√≥rica √† dist√¢ncia for√ßa os desenvolvedores a ler cada linha de c√≥digo para entender as intera√ß√µes potenciais, reduz a produtividade dos desenvolvedores e confunde os novos membros da equipe.
Se voc√™ foi quem criou o c√≥digo, conhece as depend√™ncias reais, mas qualquer pessoa que vier depois de voc√™ ficar√° perdida.

N√£o escreva c√≥digo que utilize estado global, prefira passar depend√™ncias. Ou seja, inje√ß√£o de depend√™ncia.


Fragilidade do estado global
----------------------------

No c√≥digo que usa estado global e singletons, nunca √© certo quando e quem alterou esse estado. Esse risco surge j√° na inicializa√ß√£o. O c√≥digo a seguir deve criar uma conex√£o com o banco de dados e inicializar o gateway de pagamento, mas lan√ßa constantemente uma exce√ß√£o e encontrar a causa √© extremamente demorado:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Voc√™ precisa percorrer detalhadamente o c√≥digo para descobrir que o objeto `PaymentGateway` acessa sem fio outros objetos, alguns dos quais requerem uma conex√£o com o banco de dados. Portanto, √© necess√°rio inicializar o banco de dados antes de `PaymentGateway`. No entanto, a cortina de fuma√ßa do estado global esconde isso de voc√™. Quanto tempo voc√™ economizaria se a API das classes individuais n√£o mentisse e declarasse suas depend√™ncias?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Um problema semelhante surge tamb√©m ao usar acesso global √† conex√£o do banco de dados:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Ao chamar o m√©todo `save()`, n√£o √© certo se a conex√£o com o banco de dados j√° foi criada e quem √© respons√°vel por sua cria√ß√£o. Se quisermos, por exemplo, alterar a conex√£o com o banco de dados em tempo de execu√ß√£o, talvez para testes, provavelmente ter√≠amos que criar outros m√©todos como `DB::reconnect(...)` ou `DB::reconnectForTest()`.

Considere o exemplo:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Onde temos certeza de que ao chamar `$article->save()` o banco de dados de teste est√° realmente sendo usado? E se o m√©todo `Foo::doSomething()` alterou a conex√£o global do banco de dados? Para descobrir, ter√≠amos que examinar o c√≥digo-fonte da classe `Foo` e provavelmente de muitas outras classes. Essa abordagem, no entanto, traria apenas uma resposta de curto prazo, pois a situa√ß√£o pode mudar no futuro.

E se movermos a conex√£o com o banco de dados para uma vari√°vel est√°tica dentro da classe `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Isso n√£o mudou nada. O problema √© o estado global e √© completamente irrelevante em qual classe ele est√° escondido. Neste caso, assim como no anterior, ao chamar o m√©todo `$article->save()`, n√£o temos nenhuma pista sobre em qual banco de dados ele ser√° escrito. Qualquer pessoa do outro lado da aplica√ß√£o poderia ter alterado o banco de dados a qualquer momento usando `Article::setDb()`. Sob nossos narizes.

O estado global torna nossa aplica√ß√£o **extremamente fr√°gil**.

No entanto, existe uma maneira simples de lidar com esse problema. Basta deixar a API declarar as depend√™ncias, garantindo assim a funcionalidade correta.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Gra√ßas a essa abordagem, elimina-se a preocupa√ß√£o com altera√ß√µes ocultas e inesperadas na conex√£o do banco de dados. Agora temos certeza de onde o artigo est√° sendo salvo e nenhuma modifica√ß√£o no c√≥digo dentro de outra classe n√£o relacionada pode mais alterar a situa√ß√£o. O c√≥digo n√£o √© mais fr√°gil, mas est√°vel.

N√£o escreva c√≥digo que utilize estado global, prefira passar depend√™ncias. Ou seja, inje√ß√£o de depend√™ncia.


Singleton
---------

Singleton √© um padr√£o de projeto que, de acordo com a "defini√ß√£o":https://en.wikipedia.org/wiki/Singleton_pattern da conhecida publica√ß√£o Gang of Four, restringe uma classe a uma √∫nica inst√¢ncia e oferece acesso global a ela. A implementa√ß√£o desse padr√£o geralmente se assemelha ao seguinte c√≥digo:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// e outros m√©todos que cumprem as fun√ß√µes da classe dada
}
```

Infelizmente, o singleton introduz estado global na aplica√ß√£o. E como mostramos acima, o estado global √© indesej√°vel. Portanto, o singleton √© considerado um antipadr√£o.

N√£o use singletons em seu c√≥digo e substitua-os por outros mecanismos. Voc√™ realmente n√£o precisa de singletons. No entanto, se precisar garantir a exist√™ncia de uma √∫nica inst√¢ncia de uma classe para toda a aplica√ß√£o, deixe isso para o [cont√™iner DI |container].
Crie assim um singleton de aplica√ß√£o, ou seja, um servi√ßo. Com isso, a classe deixa de se preocupar em garantir sua pr√≥pria unicidade (ou seja, n√£o ter√° o m√©todo `getInstance()` e a vari√°vel est√°tica) e cumprir√° apenas suas fun√ß√µes. Assim, deixar√° de violar o princ√≠pio da responsabilidade √∫nica.


Estado global versus testes
---------------------------

Ao escrever testes, assumimos que cada teste √© uma unidade isolada e que nenhum estado externo entra nele. E nenhum estado sai dos testes. Ap√≥s a conclus√£o do teste, todo o estado relacionado ao teste deve ser removido automaticamente pelo coletor de lixo. Gra√ßas a isso, os testes s√£o isolados. Portanto, podemos executar os testes em qualquer ordem.

No entanto, se houver estados globais/singletons, todas essas suposi√ß√µes agrad√°veis desmoronam. O estado pode entrar e sair do teste. De repente, a ordem dos testes pode importar.

Para poder testar singletons, os desenvolvedores muitas vezes precisam afrouxar suas propriedades, talvez permitindo que a inst√¢ncia seja substitu√≠da por outra. Tais solu√ß√µes s√£o, na melhor das hip√≥teses, um hack que cria c√≥digo dif√≠cil de manter e entender. Cada teste ou m√©todo `tearDown()` que afeta qualquer estado global deve reverter essas altera√ß√µes.

O estado global √© a maior dor de cabe√ßa nos testes unit√°rios!

Como consertar a situa√ß√£o? Facilmente. N√£o escreva c√≥digo que utilize singletons, prefira passar depend√™ncias. Ou seja, inje√ß√£o de depend√™ncia.


Constantes Globais
------------------

O estado global n√£o se limita apenas ao uso de singletons e vari√°veis est√°ticas, mas tamb√©m pode se referir a constantes globais.

Constantes cujo valor n√£o nos traz nenhuma informa√ß√£o nova (`M_PI`) ou √∫til (`PREG_BACKTRACK_LIMIT_ERROR`) s√£o claramente aceit√°veis.
Por outro lado, constantes que servem como uma forma de passar informa√ß√µes *sem fio* para dentro do c√≥digo n√£o s√£o nada mais do que uma depend√™ncia oculta. Como `LOG_FILE` no exemplo a seguir.
O uso da constante `FILE_APPEND` √© totalmente correto.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Neste caso, dever√≠amos declarar um par√¢metro no construtor da classe `Foo` para que ele se torne parte da API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Agora podemos passar a informa√ß√£o sobre o caminho do arquivo de log e alter√°-la facilmente conforme necess√°rio, o que facilita o teste e a manuten√ß√£o do c√≥digo.


Fun√ß√µes Globais e M√©todos Est√°ticos
-----------------------------------

Queremos enfatizar que o uso de m√©todos est√°ticos e fun√ß√µes globais em si n√£o √© problem√°tico. Explicamos por que o uso de `DB::insert()` e m√©todos semelhantes √© inadequado, mas sempre foi apenas uma quest√£o de estado global armazenado em alguma vari√°vel est√°tica. O m√©todo `DB::insert()` requer a exist√™ncia de uma vari√°vel est√°tica porque a conex√£o com o banco de dados est√° armazenada nela. Sem essa vari√°vel, seria imposs√≠vel implementar o m√©todo.

O uso de m√©todos est√°ticos e fun√ß√µes determin√≠sticas, como `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` e muitas outras, est√° em total conformidade com a inje√ß√£o de depend√™ncia. Essas fun√ß√µes sempre retornam os mesmos resultados para os mesmos par√¢metros de entrada e s√£o, portanto, previs√≠veis. Elas n√£o usam nenhum estado global.

No entanto, existem fun√ß√µes no PHP que n√£o s√£o determin√≠sticas. Entre elas est√°, por exemplo, a fun√ß√£o `htmlspecialchars()`. Seu terceiro par√¢metro `$encoding`, se n√£o for especificado, tem como valor padr√£o o valor da op√ß√£o de configura√ß√£o `ini_get('default_charset')`. Portanto, recomenda-se sempre especificar este par√¢metro para evitar poss√≠veis comportamentos imprevis√≠veis da fun√ß√£o. Nette faz isso consistentemente.

Algumas fun√ß√µes, como `strtolower()`, `strtoupper()` e semelhantes, comportaram-se de forma n√£o determin√≠stica no passado recente e dependiam da configura√ß√£o `setlocale()`. Isso causou muitas complica√ß√µes, mais frequentemente ao trabalhar com a l√≠ngua turca.
Isso porque o turco distingue entre letras `I` mai√∫sculas e min√∫sculas com e sem ponto. Assim, `strtolower('I')` retornava o caractere `ƒ±` e `strtoupper('i')` o caractere `ƒ∞`, o que levou as aplica√ß√µes a causar uma s√©rie de erros misteriosos.
No entanto, esse problema foi corrigido na vers√£o 8.2 do PHP e as fun√ß√µes n√£o dependem mais do locale.

Este √© um bom exemplo de como o estado global atormentou milhares de desenvolvedores em todo o mundo. A solu√ß√£o foi substitu√≠-lo por inje√ß√£o de depend√™ncia.


Quando √© poss√≠vel usar estado global?
-------------------------------------

Existem certas situa√ß√µes espec√≠ficas em que √© poss√≠vel utilizar o estado global. Por exemplo, ao depurar c√≥digo, quando voc√™ precisa imprimir o valor de uma vari√°vel ou medir a dura√ß√£o de uma determinada parte do programa. Nesses casos, que dizem respeito a a√ß√µes tempor√°rias que ser√£o posteriormente removidas do c√≥digo, √© leg√≠timo usar um dumper ou cron√¥metro globalmente dispon√≠vel. Essas ferramentas n√£o fazem parte do design do c√≥digo.

Outro exemplo s√£o as fun√ß√µes para trabalhar com express√µes regulares `preg_*`, que internamente armazenam express√µes regulares compiladas em um cache est√°tico na mem√≥ria. Assim, quando voc√™ chama a mesma express√£o regular v√°rias vezes em diferentes partes do c√≥digo, ela √© compilada apenas uma vez. O cache economiza desempenho e, ao mesmo tempo, √© completamente invis√≠vel para o usu√°rio, portanto, tal uso pode ser considerado leg√≠timo.


Resumo
------

Discutimos por que faz sentido:

1) Remover todas as vari√°veis est√°ticas do c√≥digo
2) Declarar depend√™ncias
3) E usar inje√ß√£o de depend√™ncia

Ao pensar no design do c√≥digo, lembre-se de que cada `static $foo` representa um problema. Para que seu c√≥digo seja um ambiente que respeite DI, √© essencial erradicar completamente o estado global e substitu√≠-lo por inje√ß√£o de depend√™ncia.

Durante esse processo, voc√™ pode descobrir que √© necess√°rio dividir a classe porque ela tem mais de uma responsabilidade. N√£o tenha medo disso; busque o princ√≠pio da responsabilidade √∫nica.

*Gostaria de agradecer a Mi≈°ko Hevery, cujos artigos, como [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], s√£o a base deste cap√≠tulo.*
