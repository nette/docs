Single Post Page
****************

.[perex]
Let’s add another page to our blog, which will display content of one particular blog post.


We need to create another render method, that will fetch one concrete blog post, and pass it to template. It is not nice to have this view in `HomepagePresenter`, because it’s about blog post, not homepage. Let’s create a new class `PostPresenter` and place it to `app/presenters/PostPresenter.php`. It will need database connection, so put there the *database injection* code.

The `PostPresenter` should look like this:

/--php
class PostPresenter extends BasePresenter
{
	/** @var Nette\Database\Connection */
	private $database;

	public function __construct(Nette\Database\Connection $database)
	{
		$this->database = $database;
	}

	public function renderShow($postId)
	{
		$this->template->post = $this->database->table('posts')->get($postId);
	}
}
\--

The `renderShow` method requires one argument - the ID of the post to be displayed. It then loads the post from database and passes the result to template.

In the `app/templates/Homepage/default.latte` template, we’ve already created a link to the `Post:show` action, which template doesn’t exist yet. You can try to open a post in your browser using the link of the page on the homepage. [Tracy | /debugging] will show an error, because the `app/templates/Post/show.latte` template has not yet been created. So let’s add that one as well:

/--html
{block #content}

<p><a n:href="Homepage:default">← back to posts list</a></p>

<div class="date">{$post->created_at|date:'F j, Y'}</div>

<h1 n:block="title">{$post->title}</h1>

<div class="post">{$post->content}</div>
\--

Let’s have a look at individual parts.

First line starts the definition of a *named block* called "content", which will be displayed in a *layout template*, that we were talking about earlier.

Second line provides a back link to the list of blog posts, so that the user can navigate smoothly back and forth on our blog. It is specified in `n:href`, therefore Nette will take care of generating the URL. And it points to `default` action of the `Homepage` presenter (you could have written `n:href="Homepage:"`).

The third line formats the publication timestamp, as we already know.

The fourth line displays the *title* of the blog post into a header `<h1>`. There is one part which you may not be familiar with, and that is `n:block="title"`. Can you guess what it does? If you’ve read carefully the previous parts, there was a mention about `n: attributes`. This is a another one. It is an equivalent to:

/--html
{block #title}<h1>{$post->title}</h1>{/block}
\--

In human words, it *re-defines* a block called `title`. The block has been defined in *layout template* (`/app/templates/@layout.latte:8`) and like with OOP overriding, it gets overridden here. Therefore, the page’s `<title>` will contain the title of displayed post. We’ve overridden the title of the page and all we needed was `n:block="title"`. Great, huh?

Fifth and the last line of detail template displays full content of your post.



Checking post ID
================

What happens if someone alters the URL and inserts `postId` which does not exist? We shall provide the user with a nice error "page not found". Let’s update the render method:

/--php
	public function renderShow($postId)
	{
		$post = $this->database->table('posts')->get($postId);
		if (!$post) {
			$this->error('Post not found');
		}

		$this->template->post = $post;
	}
\--

If the post cannot be found, calling `$this->error(...)` will show a 404 page with a nice and understandable message. Note, that in your development environment (on your laptop), you won’t see the error page, but instead Tracy will show the exception will full details. This is pretty convenient for development. You can check both modes, just change value passed to `setDebugMode` in `bootstrap.php`.


Summary
=======

We have a database with blog posts and a web app with two views - first to show summary of all recent posts and second one to display one concrete post.
