<div class=perex>

Latte is a template engine for PHP which eases your work and ensures the output is protected against vulnerabilities, such as XSS.

- **Latte is fast:** it compiles templates to plain optimized PHP code.
- **Latte is secure:** it is the first PHP engine introducing [#context-aware escaping] and [#link checking].
- **Latte speaks your language:** it has intuitive syntax and helps you to build better websites easily.

</div>


Although PHP is originally a templating language, it is not particularly suited for writing templates. Let's have a look at an example of a PHP template that prints an array `$items` as a list:

```php
<?php if ($items): ?>
	<?php $counter = 1 ?>
	<ul>
	<?php foreach ($items as $item): ?>
		<li id="item-<?php echo $counter++ ?>"><?php
		echo htmlSpecialChars(mb_convert_case($item, MB_CASE_TITLE)) ?>
		</li>
	<?php endforeach ?>
	</ul>
<?php endif?>
```

The code is rather confusing. Moreover, we must not forget to call `htmlSpecialChars` function. That's why there are so many different template engines for PHP. One of the best template engines is part of Nette Framework and it is called **Latte**. You'll love it!

The same template as the one above can be written easily in Latte:

```html
<ul n:if="$items">
{foreach $items as $item}
	<li id="item-{$iterator->counter}">{$item|capitalize}</li>
{/foreach}
</ul>
```

As you can see there are two types of directives:

- **[tags |#tags]** in braces, for example `{foreach …}`
- **[n:attributes |#n:attributes]**, for example `n:if="…"`


Installation and Usage
======================

The best way how to install Latte is to [download a latest package](https://github.com/nette/latte/releases) or use a Composer:

```shell
composer require latte/latte
```

The Latte 2.5 requires PHP version 7.1 and supports PHP up to 7.4. The Latte 2.4 requires PHP version 5.4 and supports PHP up to 7.4 too.


How to render a template? Just run this code:

```php
$latte = new Latte\Engine;

$latte->setTempDirectory('/path/to/tempdir');

$params = [
	'items' => ['one', 'two', 'three'],
];

// render to output
$latte->render('template.latte', $params);
// or render to string
$html = $latte->renderToString('template.latte', $params);
```

Latte automatically regenerates the cache every time you change the template, which can be turned off in the production environment to save a little performance:

```php
$latte->setAutoRefresh(false);
```

You can also use an object instead of the `$params` array, which has some advantages. You get [autosuggestion in IDE |#Typed templates]
and way for registration of [#filters] and [#functions]:

```php
class MyTemplate
{
	public $items = ['one', 'two', 'three'];
}

$params = new MyTemplate;
$latte->render('template.latte', $params);
```


Integration and plugins
=======================

Write templates in an editor or IDE that has support for Latte. It will be much more pleasant.

- NetBeans IDE has built-in support
- PhpStorm: install the Latte plugin in `Settings > Plugins > Marketplace`
- VS Code: search markerplace for "Nette Latte + Neon" plugin
- Sublime Text 3: in Package Control find and install `Nette` package and select Latte in `View > Syntax`
- to highlight code on the web use [Prism.js |https://prismjs.com/#supported-languages]
- in old editors use Smarty highlighting for .latte files

The plugin for PhpStorm is very advanced and can perfectly suggest PHP code. To work optimally, use [#typed templates].



Tags
====

You can find detailed [description of all the built-in tags |tags]. Furthermore, you can make your [own tags |#User-defined tags].

Each pair tag, such as `{if} … {/if}`, operating upon single HTML element can be written in [n:attribute |#n:attribute] notation. So, it is possible to write the `{foreach}` tag in the same manner:

```html
<ul n:if="$items">
	<li n:foreach="$items as $item">{$item|capitalize}</li>
</ul>
```

With n:attributes you can do much more interesting tricks as you will see in a moment.

`{$item|capitalize}` tag which prints the `$item` variable contains so called [filter |#filters], in this case the `capitalize` filter which makes the first letter of each word uppercase.

A very important feature of Latte is that it **escapes variables by default**. [Escaping |doc:glossary#escaping] is needed when printing a variable because we have to convert all the characters which have a special meaning in HTML to other sequences. In case we forget it can lead to a serious security hole called [Cross-Site Scripting (XSS) |doc:vulnerability-protection#cross-site-scripting-xss].

Because of different escaping functions that are needed in different documents and different parts of a page, Latte features a unique technology of [#Context-Aware Escaping] which recognizes the context in which the tag is placed and **chooses the right escaping mode.** You don't have to worry that your coder forgets about it causing you goosebumps because of a security hole. Which is great!

.[note]
If the `$item` variable stores an HTML code and you want to print it without any alteration you just add the modifier noescape: `{$item|noescape}`. Forgetting the modifier mark won't cause any security holes in the spirit of „less code, more security“ principle.

You can still use PHP inside the tags normally, including comments as well. But Latte also extends the PHP syntax with three pleasant features:

1) we can omit quotes around the strings consisting of letters, numbers, and dashes
2) short condition notation `$a ? 'b'` which is the same as `$a ? 'b' : null` in PHP
3) you can use optional chaining like `$var?->call()?->elem[1]?->item`

For example:

```html
{$cond ? hello}  // prints 'hello' if $cond equals true

{$order->item?->name} // means isset($order->item) ? $order->item->name : null
```

Latte also has a `{* comment tag *}` which doesn't get printed to the output.


n:attributes
============

We showed that n:attributes are supposed to be written directly into HTML tags as their special attributes. We also said that every pair tag (e.g. `{if} … {/if}`) can be written in n:attribute notation. The functionality then corresponds to the HTML element in which it is written:

```html
{var $items = ['I', '♥', 'Nette Framework']}

<p n:foreach="$items as $item">{$item}</p>
```

Prints:

```html
<p>I</p>
<p>♥</p>
<p>Nette Framework</p>
```

By using `inner-` prefix we can alter the behavior so that the functionality applies only to the body of the element:

```html
<div n:inner-foreach="$items as $item">
	<p>{$item}</p>
	<hr>
</div>
```

Prints:

```html
<div>
	<p>I</p>
	<hr>
	<p>♥</p>
	<hr>
	<p>Nette Framework</p>
	<hr>
</div>
```

Or by using `tag-` prefix the functionality is applied on the HTML tags only:

```html
<p><a href="{$url}" n:tag-if="$url">Title</a></p>
```

Depending on the value of `$url` variable this will print:

```html
// when $url is empty
<p>Title</p>

// when $url equals 'https://nette.org'
<p><a href="https://nette.org">Title</a></p>
```

However, n:attributes are not only a shortcut for pair tags, there are some pure n:attributes as well, for example the coder's best friend [n:class|tags#n:class].


Filters
=======

See the summary of [standard filters|filters].

Latte allows calling filters by using the pipe sign notation called modifier (preceding space is allowed):

```html
<h1>{$heading|upper}</h1>
```

Filters can be chained, in that case they apply in order from left to right:

```html
<h1>{$heading|lower|capitalize}</h1>
```

Parameters are put after the filter name separated by colon or comma:

```html
<h1>{$heading|truncate:20,''}</h1>
```

Filters can be applied on expression:

```html
{var $name = ($title|upper) . ($subtitle|lower)}</h1>
```


Custom filters
--------------
Custom filters can be registered this way:

```php
$latte = new Latte\Engine;
$latte->addFilter('shortify', function (string $s): string {
	return mb_substr($s, 0, 10); // shortens the text to 10 characters
});
```

In this case it would be better for the filter to get an additional parameter:

```php
$latte->addFilter('shortify', function (string $s, int $len = 10): string {
	return mb_substr($s, 0, $len);
});
```

We use it in a template like this:

```html
<p>{$text|shortify}</p>
<p>{$text|shortify:100}</p>
```

The second way to define a filter is a template class. It is important to specify the annotation `@filter`:

```php
class MyTemplate
{
	/** @filter */
	public function shortify(string $s, int $len = 10): string
	{
		return mb_substr($s, 0, $len);
	}
}

$params = new MyTemplate;
...
$latte->render('template.latte', $params);
```


Universal filter
----------------

Manual registration of multiple filter can be replaced with a single universal registration:

```php
$latte->addFilter(null, 'Filters::common');
```

Filters:common gets name of filter as first parameter.

```php
class Filters
{
	public static function common($filter, $value)
	{
		if (method_exists(__CLASS__, $filter)) {
			$args = func_get_args();
			array_shift($args);
			return call_user_func_array([__CLASS__, $filter], $args);
		}
	}

	public static function shortify($s, $len = 10)
	{
		return mb_substr($s, 0, $len);
	}
}
```



Functions
=========

In Latte you can use all PHP functions and at the same time define your own:

```php
$latte = new Latte\Engine;
$latte->addFunction('random', function (...$args) {
	return array_rand($args);
});
```

The usage is then the same as when calling the PHP function:

```html
{random(apple, orange, lemon)} // prints for example: apple
```

The second way to define a function is a template class. It is important to specify the annotation `@function`:

```php
class MyTemplate
{
	/** @function */
	public function random(...$args)
	{
		return array_rand($args);
	}
}

$params = new MyTemplate;
...
$latte->render('template.latte', $params);
```


Typed templates
===============

*since Latte 2.7*

Type system is main thing for the development of robust applications. Latte brings type support to templates. To knowing what data or object type each variable is allows

- IDE to correctly autocomplete (see [#Integration and plugins])
- static analysis to detect errors

Two points that significantly improve the quality and convenience of development.

How to start using types? Create a template class, eg `CatalogTemplate`, representing the passed parameters:

```php
class CatalogTemplate
{
	/** @var array */
	public $langs;

	/** @var ProductEntity[] */
	public $products;
}

$params = new CatalogTemplate;
$params->langs = $settings->getLanguages();
$params->products = $entityManager->getRepository('Product')->findAll();
$latte->render('template.latte', $params);
```

Then insert the [`{templateType}` |tags#Types] tag with the full class name (including the namespace) at the beginning of the template:

```html
{templateType MyApp\CatalogTemplate}
```

We have defined that there will be variables `$langs` and `$products` in the template including the corresponding types. Now the IDE can correctly autocomplete.

You can specify the types of local variables using tags [`{var}` |tags#Variable declaration], [`{varType}` |tags#Types], [`{define}` |tags#Blocks]:

```html
{var string $name = $article->getTitle()}
{varType Nette\Security\User $user}
```

How to save work? How to write a template class or `{varType}` tags as easily as possible? Get them generated.
That is precisely what pair of tags [`{templatePrint}` |tags#Types] and [`{varPrint}` |tags#Types] do.
If you place one of these tags in a template, the code of class or template is displayed instead of the normal rendering. Then simply select and copy the code into your project.



Sandbox mode
============

*since Latte 2.8*

Latte has an armored stronghold directly under the hood. It is called sandbox mode and it is an important feature that protects applications that use templates from untrusted sources. For example, when they are edited by the users themselves.

Sandbox mode makes sure that the sand does not get out of the box. Thus, it provides limited access to macros, filters, functions, methods, etc.
How does it work? We simply define what we want to allow in the template. In the beginning, everything is forbidden and we gradually grant permissions:

The following code allows the the template to use the `{block}`, `{if}`, `{else}` and `{=}` tags (the latter is a tag for [printing a variable or expression |tags#Variable printing]) and all filters:

```php
$policy = new Latte\Sandbox\SecurityPolicy;
$policy->allowMacros(['block', 'if', 'else', '=']);
$policy->allowFilters($policy::ALL);

$latte->setPolicy($policy);
```

We can also allow access to global functions, methods or properties of objects:

```php
$policy->allowFunctions(['trim', 'strlen']);
$policy->allowMethods(Nette\Security\User::class, ['isLoggedIn', 'isAllowed']);
$policy->allowProperties(Nette\Database\Row::class, $policy::ALL);
```

Isn't that amazing? You can control everything at a very low level. If the template tries to call an unauthorized function or access an unauthorized method or property, it throws exception `Latte\SecurityViolationException`.

Creating policies from scratch, when everything is forbidden, may not be convenient, so you can start from a safe foundation:

```php
$policy = Latte\Sandbox\SecurityPolicy::createSafePolicy();
```

This means that all standard macros are allowed except for `contentType`, `debugbreak`, `dump`, `extends`, `import`, `include`, `includeblock`, `layout`, `php`, `sandbox` are allowed , `snippet`, `snippetArea`, `templatePrint`, `varPrint`, `widget`.
All standard filters are allowed as well except for `datastream`, `noescape` and `nocheck`. Finally, access to the methods and properties of object `$iterator` is allowed too.

The rules apply to the template that we insert with the new [`{sandbox}` |tags#File including] tag. Which is a something like `{include}`, but it turns on sandbox mode and also doesn't pass any external variables:

```html
{sandbox 'untrusted.latte'}
```

Thus, the layout and individual pages can use all macros and variables as before, restrictions will be applied only to the template `untrusted.latte`.

Some violations, such as the use of a forbidden tag or filter, are detected at compile time. Others, such as calling unallowed methods of an object, at runtime.
The template can also contain any other bugs. In order to prevent an exception from throwing from the sandboxed template, which disrupts the entire rendering, you can define your own exception handler, which, for example, just logs it:

```php
$latte->setExceptionHandler(function (Throwable $e, Latte\Runtime\Template $template) use ($logger) {
	$logger->log($e);
});
```

If we want to turn on sandbox mode directly for all templates, it's easy:

```php
$latte->setSandboxMode();
```


Performance
===========

Latte is extremely fast. It compiles the templates to native PHP code and stores them in a cache on the disk. So they are as fast as if they would have been written in pure PHP.

The template is automatically recompiled each time we change the source file. While developing you just need to edit the templates in Latte and changes are visible in your browser instantly.


Debugging
=========

With each error or typo, you will be informed by [Tracy|tracy:] with all the luxury. The template source code is displayed and the red line marks the error showing error message as well. With just a single click you can open the template in your favorite editor and fix the error at once. Easy peasy!

If you are using an IDE with code stepping you can go through the generated PHP code of the template.



Usability
=========

Latte syntax wasn't invented by engineers but came up from web designer's practical requests. We were looking for the friendliest syntax with which you can write even the most problematic constructions comfortably enough. You will be surprised how much help Latte can be.

You can find tags for advanced [layout|tags#template-expanding-inheritance] managing, for **template inheritance**, nested blocks and so on. Syntax comes from PHP itself so you don't have to learn anything new and you can leverage your know-how.



Context-Aware Escaping
======================

Although the [Cross-Site Scripting (XSS) |doc:vulnerability-protection#cross-site-scripting-xss] is one of the trivial ways of exploiting a web page it is the most common vulnerability but very serious. It can lead to identity theft and so on. The best defense is consistent [escaping |doc:glossary#escaping] of printed data, ie. converting the characters which have a special meaning in the given context.

If the coder omits the escaping a security hole is made. That's why template engines implement automated escaping. The problem is that the web page has different contexts and each has different rules for escaping printed data. A security hole then shows up if the wrong escaping functions are used.

But Latte is sophisticated. It features unique technology of *Context-Aware Escaping* which recognizes the context in which the tag is placed and chooses the right escaping mode. What does that mean?

Latte doesn't need any manual work. **All is done automatically, consistently and correctly.** You don't have to worry about security holes.

Lets see how it works:

```html
<p onclick="alert({$movie})">{$movie}</p>

<script>var movie = {$movie};</script>
```

If `$movie` variable stores `'Amarcord & 8 1/2'` string it generates the following output. Notice different escaping used in HTML and JavaScript and also in `onclick` attribute:


```html
<p onclick="alert(&quot;Amarcord &amp; 8 1\/2&quot;)">Amarcord &amp; 8 1/2</p>

<script>var movie = "Amarcord & 8 1\/2";</script>
```

Thanks to Context-Aware Escaping the template is simple and your application perfectly secured against Cross-Site Scripting. You can use PHP variables natively inside the JavaScript!


JavaScript
----------

Strings in JavaScript are escaped including quotes. If you want to put the variable into another string, simply concatenate them:

```html
<script>
	alert('Hello ' + {$name} + '!');  # good
	alert('Hello {$name} !');  # bad!
</script>
```


Link checking
=============

Latte automatically checks whether the variable used in the `src` or `href` attributes contains a web URL (ie protocol HTTP) and prevents the writing of links that may pose a security risk.

```html
{var $link = 'javascript:attack()'}

<a href="{$link}">click here</a>
```

Writes:

```html
<a href="">click here</a>
```

The check can be turned off using a filter [noCheck|filters#noCheck].


A pretty output
===============

Sticklers will enjoy the look of the HTML output which Latte generates. All tags are indented as they are supposed to. The code looks like it has been processed with some kind of *HTML code beautifier* :-)


User-defined tags
=================

Latte provides API for making your own tags. It isn't difficult at all. Tags are added in sets (a set can consist of a single tag).

```php
$latte = new Latte\Engine;

// lets create a set
$set = new Latte\Macros\MacroSet($latte->getCompiler());

// add new pair tag {try} ... {/try}
$set->addMacro(
	'try', // tag name
	'try {',  // PHP code replacing the opening brace
	'} catch (\Exception $e) {}' // code replacing the closing brace
);
```

If we omit the last parameter of `addMacro()` method, we denote the tag is not paired.

PHP code in the second and third parameter can contain tags:

- `%node.word` - inserts the first tag argument
- `%node.array` - inserts the tag arguments formatted as a PHP array
- `%node.args` - inserts the tag arguments formatted as PHP code
- `%escape(...)` - replaced by the current escape function
- `%modify(...)` - replaced by a sequence of modifiers

For example:

```php
$set->addMacro('if', 'if (%node.args):', 'endif');
```

If the tag logic is more complex we can use callbacks or lambda functions instead of strings. In the first parameter, they will get [MacroNode |api:Latte\MacroNode] object which represents the current node, the second parameter is [PhpWriter |api:Latte\PhpWriter] object which helps with generating the output code.

```php
$set->addMacro('if', function ($node, $writer) {
	return $writer->write('if (%node.args):');
}, 'endif');
```



Template from string
====================

You can load template from strings using `Latte\Loaders\StringLoader`:

```php
$latte->setLoader(new Latte\Loaders\StringLoader([
	'main' => '{if true} {$var} {/if}',
]));

$latte->render('main', $params);
```


{{composer: latte/latte}}
{{title: Guide}}
