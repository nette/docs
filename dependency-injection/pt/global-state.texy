Estado global e Singletons
**************************

.[perex]
Advert√™ncia: as seguintes constru√ß√µes s√£o sintomas de mau desenho de c√≥digo:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ou `static::$var`

Alguma dessas constru√ß√µes ocorre em seu c√≥digo? Ent√£o voc√™ tem uma oportunidade de melhorar. Voc√™ pode estar pensando que estas s√£o constru√ß√µes comuns que vemos em exemplos de solu√ß√µes de v√°rias bibliotecas e estruturas.
Infelizmente, elas ainda s√£o um claro indicador de mau projeto. Elas t√™m uma coisa em comum: o uso do estado global.

Agora, certamente n√£o estamos falando de algum tipo de pureza acad√™mica. O uso do estado global e singletons tem efeitos destrutivos sobre a qualidade do c√≥digo. Seu comportamento se torna imprevis√≠vel, reduz a produtividade do desenvolvedor e for√ßa as interfaces de classe a mentir sobre suas verdadeiras depend√™ncias. O que confunde os programadores.

Neste cap√≠tulo, mostraremos como isto √© poss√≠vel.


Interliga√ß√£o global .[#toc-global-interlinking]
-----------------------------------------------

O problema fundamental com o estado global √© que ele √© acess√≠vel globalmente. Isto torna poss√≠vel escrever para o banco de dados atrav√©s do m√©todo global (est√°tico) `DB::insert()`.
Em um mundo ideal, um objeto s√≥ deve ser capaz de se comunicar com outros objetos que lhe tenham sido [diretamente passados |passing-dependencies].
Se eu criar dois objetos `A` e `B` e nunca passar uma refer√™ncia de `A` para `B`, ent√£o nem `A`, nem `B` podem acessar o outro objeto ou mudar seu estado.
Esta √© uma caracter√≠stica muito desej√°vel do c√≥digo. √â semelhante a ter uma bateria e uma l√¢mpada; a l√¢mpada n√£o acender√° at√© que voc√™ as ligue juntas.

Isto n√£o √© verdade para vari√°veis globais (est√°ticas) ou singletons. O objeto `A` poderia *sem fio* acessar o objeto `C` e modific√°-lo sem passar por nenhuma refer√™ncia, ligando para `C::changeSomething()`.
Se o objeto `B` tamb√©m pegar o global `C`, ent√£o `A` e `B` podem interagir entre si atrav√©s de `C`.

O uso de vari√°veis globais introduz uma nova forma de acoplamento *sem fio* no sistema que n√£o √© vis√≠vel do exterior.
Ele cria uma cortina de fuma√ßa complicando a compreens√£o e o uso do c√≥digo.
Os desenvolvedores devem ler cada linha de c√≥digo fonte para compreender verdadeiramente as depend√™ncias. Ao inv√©s de apenas se familiarizarem com a interface das classes.
Al√©m disso, √© um acoplamento completamente desnecess√°rio.

.[note]
Em termos de comportamento, n√£o h√° diferen√ßa entre uma vari√°vel global e uma vari√°vel est√°tica. Elas s√£o igualmente prejudiciais.


A a√ß√£o assustadora √† dist√¢ncia .[#toc-the-spooky-action-at-a-distance]
----------------------------------------------------------------------

"A√ß√£o assustadora √† dist√¢ncia" - √© o que Albert Einstein chamou famoso fen√¥meno na f√≠sica qu√¢ntica que lhe deu arrepios em 1935.
√â um emaranhado qu√¢ntico, cuja peculiaridade √© que quando voc√™ mede informa√ß√µes sobre uma part√≠cula, voc√™ afeta imediatamente outra part√≠cula, mesmo que elas estejam a milh√µes de anos-luz de dist√¢ncia.
o que aparentemente viola a lei fundamental do universo de que nada pode viajar mais r√°pido do que a luz.

No mundo do software, podemos chamar uma "a√ß√£o assustadora √† dist√¢ncia" de uma situa√ß√£o em que executamos um processo que pensamos estar isolado (porque n√£o passamos nenhuma refer√™ncia), mas intera√ß√µes e mudan√ßas de estado inesperadas acontecem em locais distantes do sistema, das quais n√£o falamos ao objeto. Isto s√≥ pode acontecer atrav√©s do estado global.

Imagine se juntar a uma equipe de desenvolvimento de projetos que tenha uma base de c√≥digo grande e madura. Sua nova lideran√ßa lhe pede para implementar uma nova funcionalidade e, como um bom desenvolvedor, voc√™ come√ßa escrevendo um teste. Mas como voc√™ √© novo no projeto, voc√™ faz um monte de testes explorat√≥rios do tipo "o que acontece se eu chamar este m√©todo". E voc√™ tenta escrever o seguinte teste:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // o n√∫mero de seu cart√£o
	$cc->charge(100);
}
```

Voc√™ executa o c√≥digo, talvez v√°rias vezes, e depois de um tempo voc√™ nota em seu telefone notifica√ß√µes do banco de que cada vez que voc√™ o executa, $100 foram cobrados em seu cart√£o de cr√©dito ü§¶‚ôÇÔ∏è

Como diabos o teste poderia causar uma carga real? N√£o √© f√°cil de operar com cart√£o de cr√©dito. Voc√™ tem que interagir com um servi√ßo web de terceiros, voc√™ tem que conhecer o URL desse servi√ßo web, voc√™ tem que fazer o login, e assim por diante.
Nenhuma destas informa√ß√µes est√° inclu√≠da no teste. Pior ainda, voc√™ nem sabe onde estas informa√ß√µes est√£o presentes e, portanto, como zombar das depend√™ncias externas para que cada execu√ß√£o n√£o resulte na cobran√ßa de US$ 100 novamente. E como um novo desenvolvedor, como voc√™ deveria saber que o que voc√™ estava prestes a fazer o levaria a ser $100 mais pobre?

Isso √© uma a√ß√£o assustadora √† dist√¢ncia!

Voc√™ n√£o tem escolha a n√£o ser cavar muito c√≥digo fonte, perguntando aos colegas mais velhos e mais experientes, at√© entender como funcionam as conex√µes no projeto.
Isto se deve ao fato de que, ao olhar para a interface da classe `CreditCard`, voc√™ n√£o pode determinar o estado global que precisa ser inicializado. Mesmo olhando para o c√≥digo-fonte da classe, voc√™ n√£o dir√° qual m√©todo de inicializa√ß√£o deve ser chamado. Na melhor das hip√≥teses, voc√™ pode encontrar a vari√°vel global a ser acessada e tentar adivinhar como inicializ√°-la a partir disso.

As aulas em tal projeto s√£o mentirosos patol√≥gicos. O cart√£o de pagamento finge que voc√™ pode simplesmente instanci√°-lo e ligar para o m√©todo `charge()`. No entanto, ele interage secretamente com outra classe, `PaymentGateway`. Mesmo sua interface diz que pode ser inicializada independentemente, mas na realidade, ela retira credenciais de algum arquivo de configura√ß√£o e assim por diante.
√â claro para os desenvolvedores que escreveram este c√≥digo que `CreditCard` precisa `PaymentGateway`. Eles escreveram o c√≥digo desta forma. Mas para qualquer novato no projeto, isto √© um mist√©rio completo e dificulta o aprendizado.

Como consertar a situa√ß√£o? F√°cil. **Deixe a API declarar as depend√™ncias.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Observe como as rela√ß√µes dentro do c√≥digo s√£o subitamente √≥bvias. Ao declarar que o m√©todo `charge()` precisa `PaymentGateway`, voc√™ n√£o precisa perguntar a ningu√©m como o c√≥digo √© interdependente. Voc√™ sabe que tem que criar uma inst√¢ncia dele, e quando voc√™ tenta fazer isso, voc√™ se depara com o fato de que tem que fornecer par√¢metros de acesso. Sem eles, o c√≥digo n√£o funcionaria.

E o mais importante, agora voc√™ pode zombar da porta de pagamento para que n√£o lhe sejam cobrados 100 d√≥lares cada vez que fizer um teste.

O estado global faz com que seus objetos possam acessar secretamente coisas que n√£o est√£o declaradas em seus APIs e, como resultado, torna seus APIs mentirosos patol√≥gicos.

Voc√™ pode n√£o ter pensado nisso antes, mas sempre que voc√™ usa o estado global, voc√™ est√° criando canais secretos de comunica√ß√£o sem fio. A a√ß√£o remota assustadora for√ßa os desenvolvedores a ler cada linha de c√≥digo para entender as poss√≠veis intera√ß√µes, reduz a produtividade dos desenvolvedores e confunde os novos membros da equipe.
Se foi voc√™ quem criou o c√≥digo, voc√™ conhece as depend√™ncias reais, mas qualquer um que venha atr√°s de voc√™ n√£o tem a menor id√©ia.

N√£o escreva c√≥digo que use o estado global, prefira passar depend√™ncias. Ou seja, inje√ß√£o de depend√™ncia.


Brittleness do Estado Global .[#toc-brittleness-of-the-global-state]
--------------------------------------------------------------------

Em c√≥digo que usa estado global e singletons, nunca √© certo quando e por quem esse estado mudou. Este risco j√° est√° presente na inicializa√ß√£o. O c√≥digo a seguir deve criar uma conex√£o de banco de dados e inicializar o gateway de pagamento, mas ele continua lan√ßando uma exce√ß√£o e encontrar a causa √© extremamente enfadonho:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Voc√™ tem que percorrer o c√≥digo em detalhes para descobrir que o objeto `PaymentGateway` acessa outros objetos sem fio, alguns dos quais requerem uma conex√£o de banco de dados. Portanto, voc√™ deve inicializar o banco de dados antes de `PaymentGateway`. No entanto, a cortina de fuma√ßa do estado global esconde isso de voc√™. Quanto tempo voc√™ economizaria se a API de cada classe n√£o mentisse e declarasse suas depend√™ncias?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Um problema semelhante surge quando se utiliza o acesso global a uma conex√£o de banco de dados:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Ao chamar o m√©todo `save()`, n√£o √© certo se j√° foi criada uma conex√£o de banco de dados e quem √© o respons√°vel por cri√°-la. Por exemplo, se quis√©ssemos mudar a conex√£o de banco de dados na hora, talvez para fins de teste, provavelmente ter√≠amos que criar m√©todos adicionais, como `DB::reconnect(...)` ou `DB::reconnectForTest()`.

Considere um exemplo:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Onde podemos ter certeza de que o banco de dados de testes est√° realmente sendo usado quando se liga para `$article->save()`? E se o m√©todo `Foo::doSomething()` mudou a conex√£o global do banco de dados? Para descobrir, ter√≠amos que examinar o c√≥digo fonte da classe `Foo` e provavelmente muitas outras classes. Entretanto, esta abordagem forneceria apenas uma resposta a curto prazo, pois a situa√ß√£o pode mudar no futuro.

E se movermos a conex√£o de banco de dados para uma vari√°vel est√°tica dentro da classe `Article`?

```php
class Article
{
	private static $db;

	public static function setDb(Db $db)
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Isto n√£o muda absolutamente nada. O problema √© um estado global e n√£o importa em qual classe ele se esconde. Neste caso, como no anterior, n√£o temos nenhuma pista de qual banco de dados est√° sendo escrito quando o m√©todo `$article->save()` √© chamado. Qualquer pessoa no extremo distante da aplica√ß√£o poderia alterar o banco de dados a qualquer momento usando `Article::setDb()`. Sob nossas m√£os.

O estado global torna nossa aplica√ß√£o **extremamente fr√°gil**.

Entretanto, h√° uma maneira simples de lidar com este problema. Basta que o API declare as depend√™ncias para garantir a funcionalidade adequada.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Esta abordagem elimina a preocupa√ß√£o de mudan√ßas ocultas e inesperadas nas conex√µes de banco de dados. Agora temos certeza de onde o artigo √© armazenado e nenhuma modifica√ß√£o de c√≥digo dentro de outra classe n√£o relacionada pode mais alterar a situa√ß√£o. O c√≥digo n√£o √© mais fr√°gil, mas est√°vel.

N√£o escreva c√≥digo que utilize o estado global, prefira passar depend√™ncias. Portanto, inje√ß√£o de depend√™ncia.


Singleton .[#toc-singleton]
---------------------------

Singleton √© um padr√£o de design que, por [defini√ß√£o |https://en.wikipedia.org/wiki/Singleton_pattern] da famosa publica√ß√£o Gang of Four, restringe uma classe a uma √∫nica inst√¢ncia e oferece acesso global a ela. A implementa√ß√£o deste padr√£o geralmente se assemelha ao seguinte c√≥digo:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// e outros m√©todos que desempenham as fun√ß√µes da classe
}
```

Infelizmente, o singleton introduz o estado global na aplica√ß√£o. E como demonstramos acima, o estado global √© indesej√°vel. √â por isso que o singleton √© considerado um antipadr√£o.

N√£o use singletons em seu c√≥digo e substitua-os por outros mecanismos. Voc√™ realmente n√£o precisa de singletons. Entretanto, se voc√™ precisar garantir a exist√™ncia de uma √∫nica inst√¢ncia de uma classe para toda a aplica√ß√£o, deixe-a para o [container DI |container].
Assim, crie um singleton de aplica√ß√£o, ou servi√ßo. Isto impedir√° a classe de fornecer sua pr√≥pria singularidade (ou seja, ela n√£o ter√° um m√©todo `getInstance()` e uma vari√°vel est√°tica) e s√≥ desempenhar√° suas fun√ß√µes. Assim, deixar√° de violar o princ√≠pio da responsabilidade √∫nica.


Testes de estado global versus testes .[#toc-global-state-versus-tests]
-----------------------------------------------------------------------

Ao escrever testes, assumimos que cada teste √© uma unidade isolada e que nenhum estado externo entra nele. E que nenhum estado deixa os testes. Quando um teste √© conclu√≠do, qualquer estado associado com o teste deve ser removido automaticamente pelo coletor de lixo. Isto faz com que os testes sejam isolados. Portanto, podemos executar os testes em qualquer ordem.

Entretanto, se estados/cingil√µes globais estiverem presentes, todas essas simp√°ticas suposi√ß√µes se desmoronam. Um estado pode entrar e sair de um teste. De repente, a ordem dos testes pode ser importante.

Para testar singletons, os desenvolvedores muitas vezes t√™m que relaxar suas propriedades, talvez permitindo que uma inst√¢ncia seja substitu√≠da por outra. Tais solu√ß√µes s√£o, na melhor das hip√≥teses, hacks que produzem c√≥digos dif√≠ceis de manter e de entender. Qualquer teste ou m√©todo `tearDown()` que afete qualquer estado global deve desfazer essas mudan√ßas.

O estado global √© a maior dor de cabe√ßa em testes unit√°rios!

Como consertar a situa√ß√£o? F√°cil. N√£o escreva c√≥digo que utilize singletons, prefira passar depend√™ncias. Ou seja, inje√ß√£o de depend√™ncia.


Constantes globais .[#toc-global-constants]
-------------------------------------------

O estado global n√£o se limita ao uso de singletons e vari√°veis est√°ticas, mas tamb√©m pode se aplicar a constantes globais.

Constantes cujo valor n√£o nos fornece nenhuma informa√ß√£o nova (`M_PI`) ou √∫til (`PREG_BACKTRACK_LIMIT_ERROR`) s√£o claramente OK.
Por outro lado, constantes que servem como uma forma de *sem fio* passar informa√ß√µes dentro do c√≥digo nada mais s√£o do que uma depend√™ncia oculta. Como `LOG_FILE` no exemplo a seguir.
O uso da constante `FILE_APPEND` √© perfeitamente correto.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Neste caso, devemos declarar o par√¢metro no construtor da classe `Foo` para torn√°-la parte da API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Agora podemos passar informa√ß√µes sobre o caminho para o arquivo de registro e facilmente alter√°-lo conforme necess√°rio, facilitando o teste e a manuten√ß√£o do c√≥digo.


Fun√ß√µes globais e m√©todos est√°ticos .[#toc-global-functions-and-static-methods]
-------------------------------------------------------------------------------

Queremos enfatizar que o uso de m√©todos est√°ticos e fun√ß√µes globais n√£o √©, por si s√≥, problem√°tico. Explicamos a inadequa√ß√£o do uso de `DB::insert()` e m√©todos similares, mas sempre foi uma quest√£o de estado global armazenada em uma vari√°vel est√°tica. O m√©todo `DB::insert()` requer a exist√™ncia de uma vari√°vel est√°tica porque armazena a conex√£o de banco de dados. Sem esta vari√°vel, seria imposs√≠vel implementar o m√©todo.

O uso de m√©todos e fun√ß√µes est√°ticas determin√≠sticas, tais como `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` e muitas outras, √© perfeitamente consistente com a inje√ß√£o de depend√™ncia. Estas fun√ß√µes sempre retornam os mesmos resultados a partir dos mesmos par√¢metros de entrada e s√£o, portanto, previs√≠veis. Elas n√£o utilizam nenhum estado global.

No entanto, h√° fun√ß√µes no PHP que n√£o s√£o determin√≠sticas. Estas incluem, por exemplo, a fun√ß√£o `htmlspecialchars()`. Seu terceiro par√¢metro, `$encoding`, se n√£o for especificado, √© o valor padr√£o da op√ß√£o de configura√ß√£o `ini_get('default_charset')`. Portanto, recomenda-se sempre especificar este par√¢metro para evitar um poss√≠vel comportamento imprevis√≠vel da fun√ß√£o. A Nette faz isto de forma consistente.

Algumas fun√ß√µes, tais como `strtolower()`, `strtoupper()`, e similares, tiveram um comportamento n√£o determin√≠stico no passado recente e dependeram da configura√ß√£o `setlocale()`. Isto causou muitas complica√ß√µes, na maioria das vezes quando se trabalha com o idioma turco.
Isto porque o idioma turco distingue entre mai√∫sculas e min√∫sculas `I` com e sem um ponto. Assim, `strtolower('I')` devolveu o caracter `ƒ±` e `strtoupper('i')` devolveu o caracter `ƒ∞`, o que levou a aplica√ß√µes que causaram uma s√©rie de erros misteriosos.
Entretanto, este problema foi corrigido na vers√£o 8.2 do PHP e as fun√ß√µes n√£o s√£o mais dependentes do locale.

Este √© um bom exemplo de como o estado global tem atormentado milhares de desenvolvedores em todo o mundo. A solu√ß√£o foi substitu√≠-lo por uma inje√ß√£o de depend√™ncia.


Sum√°rio .[#toc-summary]
-----------------------

Mostramos porque faz sentido

1) Remover todas as vari√°veis est√°ticas do c√≥digo
2) Declarar as depend√™ncias
3) E usar inje√ß√£o de depend√™ncia

N√£o h√° exce√ß√µes, n√£o h√° situa√ß√µes em que o estado global √© um amigo √∫til. Cada `static $foo` dentro do c√≥digo indica um problema. Para que seu c√≥digo seja um ambiente consciente de DI, voc√™ precisa erradicar completamente o estado global e substitu√≠-lo por inje√ß√£o de depend√™ncia.

Durante este processo, voc√™ pode descobrir que precisa dividir uma classe porque ela tem mais de uma responsabilidade. N√£o se preocupe com isso; esforce-se pelo princ√≠pio de uma responsabilidade.

*Gostaria de agradecer a Mi≈°ko Hevery, cujos artigos como [Flaw: Brittle Global State & Singletons |http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] formam a base deste cap√≠tulo.*
