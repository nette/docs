Τι είναι το Dependency Injection;
*********************************

.[perex]
Αυτό το κεφάλαιο σας εισάγει στις βασικές πρακτικές προγραμματισμού που διέπουν ολόκληρο το πλαίσιο Nette και τις οποίες θα πρέπει να ακολουθείτε όταν γράφετε τις δικές σας εφαρμογές. Αυτά είναι τα βασικά που απαιτούνται για να γράψετε καθαρό, κατανοητό και συντηρήσιμο κώδικα.

Αν μάθετε και ακολουθήσετε αυτούς τους κανόνες, το πλαίσιο θα είναι δίπλα σας σε κάθε σας βήμα. Θα χειρίζεται τις εργασίες ρουτίνας για εσάς και θα σας κάνει να αισθάνεστε όσο το δυνατόν πιο άνετα, ώστε να μπορείτε να επικεντρωθείτε στην ίδια τη λογική.

Οι αρχές που θα παρουσιάσουμε εδώ είναι αρκετά απλές. Δεν χρειάζεται να ανησυχείτε για τίποτα.


Θυμάστε το πρώτο σας πρόγραμμα; .[#toc-remember-your-first-program]
-------------------------------------------------------------------

Δεν έχουμε ιδέα σε ποια γλώσσα το γράψατε, αλλά αν επρόκειτο για PHP, πιθανόν να έμοιαζε κάπως έτσι:

```php
function addition(float $a, float $b): float
{
	return $a + $b;
}

echo addition(23, 1); // εκτυπώσεις 24
```

Λίγες ασήμαντες γραμμές κώδικα, αλλά τόσες πολλές βασικές έννοιες είναι κρυμμένες σε αυτές. Βλέπουμε ότι υπάρχουν μεταβλητές. Ότι ο κώδικας αναλύεται σε μικρότερες μονάδες, οι οποίες είναι συναρτήσεις, για παράδειγμα. Ότι τους δίνουμε ορίσματα εισόδου και επιστρέφουν αποτελέσματα. Το μόνο που λείπει είναι οι συνθήκες και οι βρόχοι.

Το γεγονός ότι περνάμε είσοδο σε μια συνάρτηση και αυτή επιστρέφει ένα αποτέλεσμα είναι μια απολύτως κατανοητή έννοια που χρησιμοποιείται και σε άλλα πεδία, όπως τα μαθηματικά.

Μια συνάρτηση έχει μια υπογραφή, η οποία αποτελείται από το όνομά της, μια λίστα παραμέτρων και τους τύπους τους και, τέλος, τον τύπο της τιμής επιστροφής. Ως χρήστες, μας ενδιαφέρει η υπογραφή- συνήθως δεν χρειάζεται να γνωρίζουμε τίποτα για την εσωτερική υλοποίηση.

Φανταστείτε τώρα ότι η υπογραφή μιας συνάρτησης μοιάζει ως εξής:

```php
function addition(float $x): float
```

Μια πρόσθεση με μία παράμετρο; Αυτό είναι παράξενο... Τι λέτε για αυτό;

```php
function addition(): float
```

Αυτό είναι πραγματικά περίεργο, έτσι δεν είναι; Πώς νομίζεις ότι χρησιμοποιείται η λειτουργία;

```php
echo addition(); // τι εκτυπώνει;
```

Κοιτάζοντας έναν τέτοιο κώδικα, είμαστε μπερδεμένοι. Όχι μόνο ένας αρχάριος δεν θα τον καταλάβαινε, ακόμη και ένας εξειδικευμένος προγραμματιστής δεν θα καταλάβαινε έναν τέτοιο κώδικα.

Αναρωτιέστε πώς θα έμοιαζε στην πραγματικότητα μια τέτοια συνάρτηση στο εσωτερικό της; Από πού θα έπαιρνε τις προσθήκες; Πιθανότατα θα τους έπαιρνε *με κάποιο τρόπο* από μόνη της, κάπως έτσι:

```php
function addition(): float
{
	$a = Input::get('a');
	$b = Input::get('b');
	return $a + $b;
}
```

Αποδεικνύεται ότι υπάρχουν κρυφές συνδέσεις με άλλες συναρτήσεις (ή στατικές μεθόδους) στο σώμα της συνάρτησης, και για να μάθουμε από πού προέρχονται στην πραγματικότητα οι προσθήκες, πρέπει να ψάξουμε περισσότερο.


Όχι με αυτόν τον τρόπο! .[#toc-not-this-way]
--------------------------------------------

Ο σχεδιασμός που μόλις δείξαμε είναι η ουσία πολλών αρνητικών χαρακτηριστικών:

- Η υπογραφή της συνάρτησης προσποιούνταν ότι δεν χρειαζόταν προσθετέα, γεγονός που μας μπέρδευε
- δεν έχουμε ιδέα πώς να κάνουμε τη συνάρτηση να υπολογίζει με δύο άλλους αριθμούς
- έπρεπε να κοιτάξουμε τον κώδικα για να δούμε πού παίρνει τους προσθετέους
- ανακαλύψαμε κρυφές δεσμεύσεις
- για να κατανοήσουμε πλήρως, πρέπει να εξερευνήσουμε και αυτές τις δεσμεύσεις

Και μήπως είναι καν δουλειά της συνάρτησης πρόσθεσης να προμηθεύεται εισόδους; Φυσικά και δεν είναι.  Η ευθύνη της είναι μόνο να προσθέτει.


Δεν θέλουμε να συναντήσουμε τέτοιο κώδικα και σίγουρα δεν θέλουμε να τον γράψουμε. Η λύση είναι απλή: επιστρέψτε στα βασικά και χρησιμοποιήστε απλά παραμέτρους:


```php
function addition(float $a, float $b): float
{
	return $a + $b;
}
```


Κανόνας #1: Χρήση παραμέτρων .[#toc-rule-1-use-parameters]
----------------------------------------------------------

Ο πιο σημαντικός κανόνας είναι: **Όλα τα δεδομένα που χρειάζονται οι συναρτήσεις ή οι κλάσεις πρέπει να μεταβιβάζονται σε αυτές**.

Αν παραβιάσουμε αυτόν τον κανόνα, θα είναι αδύνατο να κάνουμε τον κώδικα κατανοητό, καθαρό και βιώσιμο.

Αν τον ακολουθήσουμε, βρισκόμαστε στο δρόμο για κώδικα χωρίς κρυφούς περιορισμούς. Προς κώδικα που είναι κατανοητός όχι μόνο για τον συγγραφέα, αλλά και για οποιονδήποτε τον διαβάσει στη συνέχεια. Όπου τα πάντα είναι κατανοητά από τις υπογραφές των συναρτήσεων και των κλάσεων και δεν χρειάζεται να ψάχνουμε για κρυμμένα μυστικά στην υλοποίηση.

Αυτή η τεχνική της μετάδοσης επιχειρημάτων ονομάζεται τεχνικά **έγχυση εξάρτησης**.

(Μην μπερδεύετε την έγχυση εξάρτησης με έναν "περιέκτη έγχυσης εξάρτησης", είναι κάτι ριζικά διαφορετικό και θα καλύψουμε τους περιέκτες στο [επόμενο |container] κεφάλαιο).


Από τις συναρτήσεις στις κλάσεις .[#toc-from-functions-to-classes]
------------------------------------------------------------------

Και πώς σχετίζονται οι κλάσεις με αυτό; Μια κλάση είναι μια πιο σύνθετη οντότητα από μια απλή συνάρτηση, αλλά ο κανόνας #1 ισχύει και εδώ. Απλά υπάρχουν [περισσότεροι τρόποι για να περάσετε ορίσματα |passing-dependencies]. Για παράδειγμα, αρκετά παρόμοια με την περίπτωση μιας συνάρτησης:

```php
class Math
{
	public function addition(float $a, float $b): float
	{
		return $a + $b;
	}
}

$math = new Math;
echo $math->addition(23, 1); // 24
```

Ή με τη χρήση άλλων μεθόδων ή απευθείας του κατασκευαστή:

```php
class Addition
{
	public function __construct(
		private float $a,
		private float $b,
	) {
	}

	public function calculate(): float
	{
		return $this->a + $this->b;
	}

}

$addition = new Addition(23, 1);
echo $addition->calculate(); // 24
```

Και τα δύο παραδείγματα συμμορφώνονται πλήρως με την έγχυση εξάρτησης.


Παραδείγματα πραγματικής ζωής .[#toc-real-life-examples]
--------------------------------------------------------

Στον πραγματικό κόσμο, δεν θα γράψετε κλάσεις για να προσθέσετε αριθμούς. Ας προχωρήσουμε σε παραδείγματα πραγματικής ζωής.

Ας έχουμε μια κλάση `Article` που αναπαριστά ένα άρθρο ιστολογίου:

```php
class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		// αποθήκευση του άρθρου στη βάση δεδομένων
	}
}
```

και η χρήση θα είναι η εξής:

```php
$article = new Article;
$article->title = '10 Things You Need to Know About Losing Weight';
$article->content = 'Every year millions of people in ...';
$article->save();
```

Η μέθοδος `save()` θα αποθηκεύσει το άρθρο σε έναν πίνακα της βάσης δεδομένων. Η υλοποίησή της με τη χρήση [της Nette Database |database:en] θα ήταν πανεύκολη, αν δεν υπήρχε ένα εμπόδιο: από πού παίρνει το `Article` τη σύνδεση με τη βάση δεδομένων, δηλαδή το αντικείμενο της κλάσης `Nette\Database\Connection`;

Φαίνεται ότι έχουμε πολλές επιλογές. Μπορεί να την πάρει από κάποια στατική μεταβλητή. Ή να κληρονομήσει από την κλάση που θα παρέχει τη σύνδεση με τη βάση δεδομένων. Ή να εκμεταλλευτεί ένα λεγόμενο singleton. Ή τα λεγόμενα facades που χρησιμοποιούνται στο Laravel:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		DB::insert(
			'INSERT INTO articles (title, content) VALUES (?, ?)',
			[$this->title, $this->content],
		);
	}
}
```

Υπέροχα, έχουμε λύσει το πρόβλημα.

Ή μήπως όχι;

Θυμηθείτε τον [κανόνα #1: χρησιμοποιήστε παραμέτρους |#rule #1: use parameters]: πρέπει να τους περάσουμε όλα τα δεδομένα που χρειάζεται η κλάση. Διότι αν δεν το κάνουμε και παραβιάσουμε τον κανόνα, έχουμε ξεκινήσει το δρόμο για βρώμικο κώδικα γεμάτο κρυφές δεσμεύσεις, ακατανόητο και το αποτέλεσμα θα είναι μια εφαρμογή που θα είναι μπελάς στη συντήρηση και την ανάπτυξη.

Ο χρήστης της κλάσης `Article` δεν έχει ιδέα πού αποθηκεύει το άρθρο η μέθοδος `save()`. Σε έναν πίνακα της βάσης δεδομένων; Σε ποιον, στην παραγωγή ή στην ανάπτυξη; Και πώς μπορεί να αλλάξει αυτό;

Ο χρήστης πρέπει να εξετάσει τον τρόπο υλοποίησης της μεθόδου `save()` για να βρει τη χρήση της μεθόδου `DB::insert()`. Έτσι, πρέπει να ψάξει περαιτέρω για να βρει πώς αυτή η μέθοδος προμηθεύεται μια σύνδεση με τη βάση δεδομένων. Και οι κρυφές συνδέσεις μπορούν να σχηματίσουν μια αρκετά μεγάλη αλυσίδα.

Οι κρυφές δεσμεύσεις, οι προσόψεις του Laravel ή οι στατικές μεταβλητές δεν υπάρχουν ποτέ σε καθαρό, καλά σχεδιασμένο κώδικα. Στον καθαρό και καλά σχεδιασμένο κώδικα, τα ορίσματα μεταβιβάζονται:

```php
class Article
{
	public function save(Nette\Database\Connection $db): void
	{
		$db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Ακόμα πιο πρακτικό, όπως θα δούμε στη συνέχεια, είναι η χρήση ενός κατασκευαστή:

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function save(): void
	{
		$this->db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Αν πρόκειται να γράψετε μια κλάση που απαιτεί μια βάση δεδομένων, για παράδειγμα, μην βρείτε από πού θα την πάρετε, αλλά αφήστε την να σας μεταβιβαστεί. Ίσως ως παράμετρος σε έναν κατασκευαστή ή σε μια άλλη μέθοδο. Δηλώστε εξαρτήσεις. Εκθέστε τις στο API της κλάσης σας. Θα έχετε κατανοητό και προβλέψιμο κώδικα.

Τι θα λέγατε για αυτή την κλάση που καταγράφει μηνύματα σφάλματος:

```php
class Logger
{
	public function log(string $message)
	{
		$file = LOG_DIR . '/log.txt';
		file_put_contents($file, $message . "\n", FILE_APPEND);
	}
}
```

Ακολουθήσαμε τον [κανόνα #1: χρησιμοποιήστε παραμέτρους |#rule #1: use parameters];

Δεν το κάναμε.

Η κλάση *αποκτά* τις βασικές πληροφορίες, τον κατάλογο που περιέχει το αρχείο καταγραφής, από μια σταθερά.

Δείτε ένα παράδειγμα χρήσης:

```php
$logger = new Logger;
$logger->log('The temperature is 23 °C');
$logger->log('The temperature is 10 °C');
```

Χωρίς να γνωρίζετε την υλοποίηση, μπορείτε να απαντήσετε στην ερώτηση πού γράφονται τα μηνύματα; Θα σας έδειχνε ότι η ύπαρξη της σταθεράς LOG_DIR είναι απαραίτητη για να λειτουργήσει; Και θα μπορούσατε να δημιουργήσετε μια δεύτερη περίπτωση που να γράφει σε διαφορετική θέση; Σίγουρα όχι.

Ας διορθώσουμε την κλάση:

```php
class Logger
{
	public function __construct(
		private string $file,
	) {
	}

	public function log(string $message)
	{
		file_put_contents($this->file, $message . "\n", FILE_APPEND);
	}
}
```

Η κλάση είναι τώρα πολύ πιο σαφής, πιο παραμετροποιήσιμη και επομένως πιο χρήσιμη.

```php
$logger = new Logger('/path/to/log.txt');
$logger->log('The temperature is 15 °C');
```


Αλλά δεν με νοιάζει! .[#toc-but-i-don-t-care]
---------------------------------------------

*"Όταν δημιουργώ ένα αντικείμενο Article και καλώ την save(), δεν θέλω να ασχοληθώ με τη βάση δεδομένων, θέλω απλώς να αποθηκευτεί σε αυτήν που έχω ορίσει στη διαμόρφωση. "*

*"Όταν χρησιμοποιώ το Logger, θέλω απλώς να γράφεται το μήνυμα και δεν θέλω να ασχοληθώ με το πού. Αφήστε να χρησιμοποιηθούν οι παγκόσμιες ρυθμίσεις. "*

Αυτά είναι σωστά σχόλια.

Ως παράδειγμα, ας πάρουμε μια τάξη που στέλνει ενημερωτικά δελτία και καταγράφει πώς πήγε αυτό:

```php
class NewsletterDistributor
{
	public function distribute(): void
	{
		$logger = new Logger(/* ... */);
		try {
			$this->sendEmails();
			$logger->log('Emails have been sent out');

		} catch (Exception $e) {
			$logger->log('An error occurred during the sending');
			throw $e;
		}
	}
}
```

Ωστόσο, η νέα `Logger`, η οποία δεν χρησιμοποιεί πλέον τη σταθερά `LOG_DIR`, απαιτεί τη διαδρομή του αρχείου στον κατασκευαστή. Πώς να το λύσετε αυτό; Η κλάση `NewsletterDistributor` δεν ενδιαφέρεται για το πού γράφονται τα μηνύματα, απλά θέλει να τα γράψει.

Η λύση είναι και πάλι ο [κανόνας #1: χρησιμοποιήστε παραμέτρους |#rule #1: use parameters]: περάστε της όλα τα δεδομένα που χρειάζεται η κλάση.

Οπότε περνάμε τη διαδρομή προς το αρχείο καταγραφής στον κατασκευαστή, την οποία στη συνέχεια χρησιμοποιούμε κατά τη δημιουργία του αντικειμένου `Logger`; Όχι. Επειδή η διαδρομή δεν είναι τα δεδομένα που χρειάζεται η κλάση `NewsletterDistributor` - αυτά χρειάζεται η κλάση `Logger`. Η κλάση χρειάζεται τον ίδιο τον καταγραφέα. Και θα το περάσουμε αυτό:


```php
class NewsletterDistributor
{
	public function __construct(
		private Logger $logger,
	) {
	}

	public function distribute(): void
	{
		try {
			$this->sendEmails();
			$this->logger->log('Emails have been sent out');

		} catch (Exception $e) {
			$this->logger->log('An error occurred during the sending');
			throw $e;
		}
	}
}
```

Τώρα είναι σαφές από τις υπογραφές της κλάσης `NewsletterDistributor` ότι η καταγραφή αποτελεί μέρος της λειτουργικότητάς της. Και έχετε τη δυνατότητα να αντικαταστήσετε τον καταγραφέα με έναν άλλο.

Ενώ σε ολόκληρη την εφαρμογή μπορούμε να είμαστε ευχαριστημένοι με μία μόνο περίπτωση του καταγραφέα και να την περνάμε όπου καταγράφεται κάτι, στην περίπτωση της κλάσης `Article` τα πράγματα είναι διαφορετικά. Θα θελήσουμε να δημιουργήσουμε πολλαπλές περιπτώσεις του. Πώς θα αντιμετωπίσουμε την εξάρτηση από τη βάση δεδομένων στον κατασκευαστή; Ως παράδειγμα, ας πάρουμε έναν ελεγκτή που πρέπει να αποθηκεύει ένα άρθρο στη βάση δεδομένων μετά την υποβολή μιας φόρμας:

```php
class UserController extends Controller
{
	public function formSubmitted($data)
	{
		$article = new Article(/* ... */);
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Προτείνεται μια πιθανή λύση: περάστε το αντικείμενο της βάσης δεδομένων στο `UserController` από τον κατασκευαστή και χρησιμοποιήστε το `$article = new Article($this->db)`.

Όπως και στην προηγούμενη περίπτωση, αυτή δεν είναι η σωστή πρακτική. Η βάση δεδομένων δεν είναι μια εξάρτηση `UserController`, αλλά μια εξάρτηση `Article`. Επιπλέον, τη στιγμή που ο κατασκευαστής της κλάσης `Article` θα αλλάξει με κάποιο τρόπο (θα προστεθεί μια νέα παράμετρος), θα πρέπει να τροποποιήσουμε τον κώδικα σε όλα τα σημεία όπου δημιουργούνται περιπτώσεις.

Η λύση είναι τα εργοστάσια.


Κανόνας #2: Χρήση εργοστασίων .[#toc-rule-2-use-factories]
----------------------------------------------------------

Αφαιρώντας τις κρυφές δεσμεύσεις και περνώντας όλα τα δεδομένα ως ορίσματα, παίρνουμε πιο παραμετροποιήσιμες και ευέλικτες κλάσεις. Επομένως, εξακολουθούμε να χρειαζόμαστε κάτι για να δημιουργήσουμε και να διαμορφώσουμε αυτές τις πιο ευέλικτες κλάσεις. Θα το ονομάσουμε εργοστάσιο.

Ο γενικός κανόνας είναι: αν μια κλάση έχει εξαρτήσεις, αφήστε τη δημιουργία των περιπτώσεων τους στο εργοστάσιο.

Τα εργοστάσια είναι μια πιο έξυπνη αντικατάσταση του τελεστή `new` στον κόσμο του dependency injection.


Εργοστάσιο .[#toc-factory]
--------------------------

Ένα εργοστάσιο είναι μια κλάση που δημιουργεί και διαμορφώνει αντικείμενα. Το εργοστάσιο που παράγει το `Article` θα ονομάζεται `ArticleFactory` και η χρήση του στον ελεγκτή θα έχει ως εξής:

```php
class UserController extends Controller
{
	public function __construct(
		private ArticleFactory $articleFactory,
	) {
	}

	public function formSubmitted($data)
	{
		// αφήστε το εργοστάσιο να δημιουργήσει ένα αντικείμενο
		$article = $this->articleFactory->create();
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Μια υλοποίηση του εργοστασίου μπορεί να μοιάζει ως εξής:


```php
class ArticleFactory
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

 `Article` Το μόνο μέρος του κώδικα που χρειάζεται να αντιδράσει σε αυτό είναι το εργοστάσιο `ArticleFactory`. Οποιοσδήποτε άλλος κώδικας που εργάζεται με αντικείμενα `Article`, όπως το `UserController`, δεν επηρεάζεται.

Μπορεί να χτυπάτε το μέτωπό σας αυτή τη στιγμή και να αναρωτιέστε πώς πραγματικά βοηθήσαμε τους εαυτούς μας. Η ποσότητα του κώδικα αυξήθηκε και μεταφέρθηκε από τον ελεγκτή σε μια ξεχωριστή κλάση. Ωστόσο, η Nette DI έχει έναν κρυφό άσσο στο μανίκι της. Κατανοεί την έννοια των εργοστασίων και μπορεί ακόμη και να [γράψει μια τέτοια υπηρεσία για εμάς |factory]. Έτσι, αντί για την κλάση `ArticleFactory`, θα μπορούσαμε απλώς να δημιουργήσουμε μια διεπαφή:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

Αλλά το ξεπερνάμε λίγο αυτό τώρα, θα φτάσουμε σε αυτό σε ένα λεπτό.


Περίληψη .[#toc-summary]
------------------------

Στην αρχή αυτού του κεφαλαίου, υποσχεθήκαμε να παρουσιάσουμε μια απλή αρχή για το πώς να σχεδιάζουμε εφαρμογές. Αν και η ίδια η αρχή είναι απλή (δώστε στις κλάσεις τα δεδομένα που χρειάζονται), αυτό που προκύπτει από αυτήν απαιτεί περισσότερη σκέψη. Μη διστάσετε να διαβάσετε αυτό το κεφάλαιο αρκετές φορές.

Οι προγραμματιστές που έχουν πετάξει τις παλιές συνήθειες και έχουν αρχίσει να χρησιμοποιούν την έγχυση εξάρτησης θεωρούν σταθερά ότι πρόκειται για μια κομβική στιγμή στην επαγγελματική τους ζωή. Άνοιξε έναν κόσμο ξεκάθαρων και βιώσιμων εφαρμογών.

Τώρα θα δούμε τι είναι το [Dependency Injection Container |container].
