Anotacije testov
****************

.[perex]
Anotacije določajo, kako bo s testi ravnal [zaganjalnik testov iz ukazne vrstice|running-tests]. Zapisujejo se na začetek datoteke s testom.

Pri anotacijah se ne upošteva velikost črk. Prav tako nimajo nobenega vpliva, če je test zagnan ročno kot običajen PHP skript.

Primer:

```php
/**
 * TEST: Basic database query test.
 *
 * @dataProvider files/databases.ini
 * @exitCode 56
 * @phpVersion < 5.5
 */

require __DIR__ . '/../bootstrap.php';
```


TEST .[filter]
--------------
To pravzaprav sploh ni anotacija, ampak samo določa naslov testa, ki se izpiše ob neuspehu ali v dnevnik.


@skip .[filter]
---------------
Test se preskoči. Uporabno za začasno izključitev testov.


@phpVersion .[filter]
---------------------
Test se preskoči, če ni zagnan z ustrezno različico PHP. Anotacijo zapisujemo kot `@phpVersion [operator] verzija`. Operator lahko izpustimo, privzeti je `>=`. Primeri:

```php
/**
 * @phpVersion 5.3.3
 * @phpVersion < 5.5
 * @phpVersion != 5.4.5
 */
```


@phpExtension .[filter]
-----------------------
Test se preskoči, če niso naložene vse navedene PHP razširitve. Več razširitev lahko navedemo v eni anotaciji ali jo uporabimo večkrat.

```php
/**
 * @phpExtension pdo, pdo_pgsql, pdo_mysql
 * @phpExtension json
 */
```


@dataProvider .[filter]
-----------------------
Če želimo testno datoteko zagnati večkrat, vendar z drugačnimi vhodnimi podatki, je uporabna prav ta anotacija. (Ne zamenjujte z istoimensko anotacijo za [TestCase|TestCase#dataProvider].)

Zapisujemo kot `@dataProvider file.ini`, pot do datoteke se jemlje relativno glede na datoteko s testom. Test bo zagnan tolikokrat, kolikor je sekcij v INI datoteki. Predpostavimo INI datoteko `databases.ini`:

```ini
[mysql]
dsn = "mysql:host=127.0.0.1"
user = root
password = ******

[postgresql]
dsn = "pgsql:host=127.0.0.1;dbname=test"
user = postgres
password = ******

[sqlite]
dsn = "sqlite::memory:"
```

in v istem imeniku test `database.phpt`:

```php
/**
 * @dataProvider databases.ini
 */

$args = Tester\Environment::loadData();
```

Test bo zagnan trikrat in `$args` bo vedno vseboval vrednosti iz sekcije `mysql`, `postgresql` ali `sqlite`.

Obstaja še varianta, ko anotacijo zapišemo z vprašajem kot `@dataProvider? file.ini`. V tem primeru se test preskoči, če INI datoteka ne obstaja.

S tem možnosti anotacije še niso izčrpane. Za ime INI datoteke lahko specificiramo pogoje, pod katerimi bo test za dano sekcijo zagnan. Razširimo INI datoteko:

```ini
[mysql]
dsn = "mysql:host=127.0.0.1"
user = root
password = ******

[postgresql 8.4]
dsn = "pgsql:host=127.0.0.1;dbname=test"
user = postgres
password = ******

[postgresql 9.1]
dsn = "pgsql:host=127.0.0.1;dbname=test;port=5433"
user = postgres
password = ******

[sqlite]
dsn = "sqlite::memory:"
```

in uporabimo anotacijo s pogojem:

```php
/**
 * @dataProvider  databases.ini  postgresql, >=9.0
 */
```

Test bo zagnan samo enkrat in to za sekcijo `postgresql 9.1`. Ostale sekcije ne bodo šle skozi filter pogoja.

Podobno lahko namesto INI datoteke pokažemo na PHP skript. Ta mora vrniti polje ali Traversable. Datoteka `databases.php`:

```php
return [
	'postgresql 8.4' => [
		'dsn' => '...',
		'user' => '...',
	],

	'postgresql 9.1' => [
		'dsn' => '...',
		'user' => '...',
	],
];
```


@multiple .[filter]
-------------------
Zapisujemo kot `@multiple N`, kjer je `N` celo število. Test bo zagnan natanko N-krat.


@testCase .[filter]
-------------------
Anotacija nima parametrov. Uporabimo jo, če teste pišemo kot [TestCase] razrede. V tem primeru bo zaganjalnik testov iz ukazne vrstice zaganjal posamezne metode v ločenih procesih in vzporedno v več nitih. To lahko znatno pospeši celoten proces testiranja.


@exitCode .[filter]
-------------------
Zapisujemo kot `@exitCode N`, kjer je `N` izhodna koda zagnanega testa. Če je v testu na primer klicano `exit(10)`, anotacijo zapišemo kot `@exitCode 10` in če test konča z drugo kodo, se to šteje za neuspeh. Če anotacije ne navedemo, se preveri izhodna koda 0 (nič).


@httpCode .[filter]
-------------------
Anotacija se uporabi samo, če je PHP binarna datoteka CGI. Sicer se ignorira. Zapisujemo kot `@httpCode NNN`, kjer je `NNN` pričakovana HTTP koda. Če anotacije ne navedemo, se preverja HTTP koda 200. Če `NNN` zapišemo kot niz, ki se ovrednoti na nič, na primer `any`, se HTTP koda ne preverja.


@outputMatch in @outputMatchFile .[filter]
------------------------------------------
Funkcija anotacij je enaka asercijam `Assert::match()` in `Assert::matchFile()`. Vzorec (pattern) pa se išče v besedilu, ki ga je test poslal na svoj standardni izhod. Uporabo najde, če predpostavljamo, da se bo test končal s fatalno napako in moramo preveriti njegov izhod.


@phpIni .[filter]
-----------------
Za test nastavi konfiguracijske INI vrednosti. Zapisujemo na primer kot `@phpIni precision=20` in deluje enako, kot če bi vrednost vnesli iz ukazne vrstice preko parametra `-d precision=20`.
