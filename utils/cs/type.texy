PHP Typ
*******

.[perex]
[api:Nette\Utils\Type] reprezentuje datový typ PHP. Slouží k analýze, porovnávání a manipulaci s typy, ať už pocházejí z řetězce nebo z reflexe.

PHP má dnes velmi bohatý typový systém: od skalárních typů (`int`, `string`) přes objekty a rozhraní až po složené typy (union `A|B`, intersection `A&B` nebo disjunktivní normální formy `(A&B)|D`). Navíc existují speciální typy jako `void`, `never`, `mixed` nebo relativní `self` či `static`.

Práce s těmito typy nativně, zejména přes `ReflectionType`, je často zdlouhavá, protože musíte rekurzivně rozlišovat mezi `ReflectionNamedType`, `ReflectionUnionType` a dalšími objekty. Třída `Nette\Utils\Type` toto vše zapouzdřuje a poskytuje **jednotné a srozumitelné API** pro práci s jakýmkoliv typem, který PHP podporuje.

Umožňuje například snadno zjistit, zda jeden typ [akceptuje|#allows] druhý (kompatibilita), [rozšiřovat typy|#with] nebo převádět reflexe na čitelný zápis.

Instalace:

```shell
composer require nette/utils
```

Všechny příklady předpokládají vytvořený alias:

```php
use Nette\Utils\Type;
```


fromReflection($reflection): ?Type .[method]
--------------------------------------------

Statická metoda vytvoří objekt Type na základě reflexe. Parameterem může být objekt `ReflectionMethod` nebo `ReflectionFunction` (vrací typ návratové hodnoty) nebo `ReflectionParameter` či `ReflectionProperty`. Překládá `self`, `static` a `parent` na skutečný název třídy. Pokud subjekt nemá žádný typ, vrátí `null`.

```php
class DemoClass
{
	public self $foo;
}

$prop = new ReflectionProperty(DemoClass::class, 'foo');
echo Type::fromReflection($prop); // 'DemoClass'
```


fromString(string $type): Type .[method]
----------------------------------------

Statická metoda vytvoří objekt Type podle textového zápisu.

```php
$type = Type::fromString('Foo|Bar');
echo $type;      // 'Foo|Bar'
```


fromValue(mixed $value): Type .[method]{data-version:4.0.10}
------------------------------------------------------------

Statická metoda, která vytvoří objekt Type podle typu předané hodnoty.

```php
$type = Type::fromValue('hello'); // 'string'
$type = Type::fromValue(123);     // 'int'
$type = Type::fromValue(new stdClass); // 'stdClass'
```

Pro resources vrací `mixed`, protože PHP typ `resource` nezná. U anonymních tříd vrací nejbližšího předka nebo typ `object`.

```php
$obj = new class extends Foo { };
$type = Type::fromValue($obj);    // 'Foo'
```


getNames(): (string|array)[] .[method]
--------------------------------------

Vrací pole podtypů, ze kterých se skládá složený typ, jako řetězce.

```php
$type = Type::fromString('string|null'); // nebo '?string'
$type->getNames();  // ['string', 'null']

$type = Type::fromString('(Foo&Bar)|string');
$type->getNames();  // [['Foo', 'Bar'], 'string']
```


getTypes(): Type[] .[method]
----------------------------

Vrací pole podtypů, ze kterých se skládá složený typ, jako objekty `ReflectionType`:

```php
$type = Type::fromString('string|null'); // or '?string'
$type->getTypes();  // [Type::fromString('string'), Type::fromString('null')]

$type = Type::fromString('(Foo&Bar)|string');
$type->getTypes();  // [Type::fromString('Foo&Bar'), Type::fromString('string')]

$type = Type::fromString('Foo&Bar');
$type->getTypes();  // [Type::fromString('Foo'), Type::fromString('Bar')]
```


getSingleName(): ?string .[method]
----------------------------------

U simple typů vrací název typu, jinak null.

```php
$type = Type::fromString('string|null');
echo $type;                       // '?string'
echo $type->getSingleName();      // 'string'

$type = Type::fromString('?Foo');
echo $type;                       // '?Foo'
echo $type->getSingleName();      // 'Foo'

$type = Type::fromString('Foo|Bar');
echo $type;                       // 'Foo|Bar'
echo $type->getSingleName();      // null
```


isSimple(): bool .[method]
--------------------------

Vrací, zda je o simple typ. Za simple typy se považují i jednoduché nullable typy:

```php
$type = Type::fromString('string');
$type->isSimple();       // true
$type->isUnion();        // false

$type = Type::fromString('?Foo'); // nebo 'Foo|null'
$type->isSimple();       // true
$type->isUnion();        // true
```


isUnion(): bool .[method]
-------------------------

Vrací, zda je o union typ.

```php
$type = Type::fromString('string|int');
$type->isUnion();        // true
```


isIntersection(): bool .[method]
--------------------------------

Vrací, zda je o intersection typ.


```php
$type = Type::fromString('Foo&Bar');
$type->isIntersection(); // true
```


isBuiltin(): bool .[method]
---------------------------

Vrací, zda je typ simple a zároveň vestavěným typem PHP.

```php
$type = Type::fromString('string');
$type->isBuiltin(); // true

$type = Type::fromString('string|int');
$type->isBuiltin(); // false

$type = Type::fromString('Foo');
$type->isBuiltin(); // false
```


isClass(): bool .[method]
-------------------------

Vrací, zda je typ simple a zároveň název třídy.

```php
$type = Type::fromString('string');
$type->isClass();   // false

$type = Type::fromString('Foo|null');
$type->isClass();   // true

$type = Type::fromString('Foo|Bar');
$type->isClass();   // false
```


isClassKeyword(): bool .[method]
--------------------------------

Vrací, zda je typ jedním z interních typů `self`, `parent`, `static`.

```php
$type = Type::fromString('self');
$type->isClassKeyword();   // true

$type = Type::fromString('Foo');
$type->isClassKeyword();   // false
```


allows(string|Type $type): bool .[method]
-----------------------------------------

Metoda `allows()` ověřuje kompatibilitu typů. Například umožní zjistit, jestli hodnota určitého typu by mohla být předaná jako parametr.

```php
$type = Type::fromString('string|null');
$type->allows('string'); // true
$type->allows('null');   // true
$type->allows('Foo');    // false

$type = Type::fromString('mixed');
$type->allows('null');   // true
```


with(string|Type $type): Type .[method]{data-version:4.0.10}
------------------------------------------------------------

Vrací objekt Type, který akceptuje jak původní typ, tak i nově přidaný. Vytváří tzv. union type.

Metoda je chytrá a typy zbytečně nezdvojuje. Pokud přidáte typ, který je již obsažen, nebo je nadmnožinou stávajícího typu (např. přidání `mixed` k `string`), vrátí se zjednodušený výsledek.

```php
$type = Type::fromString('string');

// Rozšíření na nullable string
echo $type->with('null'); // '?string'

// Vytvoření union typu
echo $type->with('int');  // 'string|int'

// Přidání typu, který "přebije" vše ostatní
echo $type->with('mixed'); // 'mixed'
```
