Що таке "впровадження залежностей"?
***********************************

.[perex]
Цей розділ знайомить вас з основними методами програмування, які лежать в основі всього фреймворка Nette і яких ви маєте дотримуватися, пишучи власні програми. Це основи, необхідні для написання чистого, зрозумілого і супроводжуваного коду.

Якщо ви засвоїте ці правила і дотримуватиметеся їх, фреймворк допомагатиме вам на кожному кроці. Він виконуватиме за вас рутинні завдання і забезпечить вам максимальний комфорт, щоб ви могли зосередитися на самій логіці.

Принципи, які ми тут покажемо, досить прості. Вам нема про що турбуватися.


Пам'ятаєте свою першу програму? .[#toc-remember-your-first-program]
-------------------------------------------------------------------

Ми й гадки не маємо, якою мовою ви її написали, але якби це був PHP, вона, ймовірно, мала б приблизно такий вигляд:

```php
function addition(float $a, float $b): float
{
	return $a + $b;
}

echo addition(23, 1); // виводить 24
```

Кілька тривіальних рядків коду, але в них приховано так багато ключових понять. Ми бачимо, що є змінні. Що код розбивається на більш дрібні одиниці, якими є, наприклад, функції. Що ми передаємо їм вхідні аргументи, а вони повертають результати. Усе, чого бракує - це умови та цикли.

Те, що ми передаємо функції вхідні дані, а вона повертає результат - це цілком зрозуміла концепція, яка використовується і в інших галузях, наприклад, у математиці.

Функція має сигнатуру, яка складається з її імені, списку параметрів та їхніх типів, і, нарешті, типу значення, що повертається. Як користувачів, нас цікавить сигнатура; нам зазвичай не потрібно знати нічого про внутрішню реалізацію.

Тепер уявіть, що сигнатура функції має такий вигляд:

```php
function addition(float $x): float
```

Доповнення з одним параметром? Дивно... Як щодо цього?

```php
function addition(): float
```

Це дуже дивно, чи не так? Як ви думаєте, як використовується ця функція?

```php
echo addition(); // що тут виводиться?
```

Дивлячись на такий код, ми приходимо в замішання. Не тільки новачок не зрозуміє його, навіть досвідчений програміст не розбереться в такому коді.

Цікаво, який вигляд така функція матиме всередині? Звідки вона візьме змінні? Ймовірно, вона могла б отримати їх *якимось чином* самостійно, ось так:

```php
function addition(): float
{
	$a = Input::get('a');
	$b = Input::get('b');
	return $a + $b;
}
```

Виявляється, у тілі функції є приховані прив'язки до інших функцій (або статичних методів), і щоб з'ясувати, звідки насправді беруться доповнення, потрібно копати далі.


Не так! .[#toc-not-this-way]
----------------------------

Дизайн, який ми щойно показали, є сутністю багатьох негативних ознак:

- сигнатура функції робить вигляд, що їй не потрібні доданки, що збиває нас з пантелику
- ми поняття не маємо, як змусити функцію обчислювати з двома іншими числами
- нам довелося зазирнути в код, щоб зрозуміти, де вона бере доданки
- ми виявили приховані прив'язки
- Для повного розуміння нам потрібно вивчити і ці прив'язки.

А чи входить взагалі в завдання функції додавання отримання вихідних даних? Звичайно, ні.  В її обов'язки входить тільки додавання.


Ми не хочемо стикатися з таким кодом, і вже точно не хочемо його писати. Рішення просте: поверніться до основ і просто використовуйте параметри:


```php
function addition(float $a, float $b): float
{
	return $a + $b;
}
```


Правило №1: використовуйте параметри .[#toc-rule-1-use-parameters]
------------------------------------------------------------------

Найважливіше правило говорить: **всі дані, які потрібні функціям або класам, мають бути передані їм**.

Якщо ми порушимо це правило, то неможливо буде зробити код зрозумілим, чистим і стійким.

Якщо слідувати йому, то ми на шляху до коду без прихованих обмежень. До коду, який зрозумілий не тільки автору, а й будь-кому, хто прочитає його згодом. Де все зрозуміло з сигнатур функцій і класів і немає необхідності шукати приховані секрети в реалізації.

Така техніка передачі аргументів технічно називається **впровадження залежностей**.

(Не плутайте впровадження залежностей з "контейнером впровадження залежностей"; це щось принципово інше, і про контейнери ми поговоримо в [наступному розділі |container]).


Від функцій до класів .[#toc-from-functions-to-classes]
-------------------------------------------------------

А як класи пов'язані з цим? Клас - це складніша сутність, ніж проста функція, але й тут діє правило №1. Просто є [більше способів передачі аргументів |passing-dependencies]. Наприклад, дуже схоже на випадок із функцією:

```php
class Math
{
	public function addition(float $a, float $b): float
	{
		return $a + $b;
	}
}

$math = new Math;
echo $math->addition(23, 1); // 24
```

Або за допомогою інших методів, або за допомогою конструктора:

```php
class Addition
{
	public function __construct(
		private float $a,
		private float $b,
	) {
	}

	public function calculate(): float
	{
		return $this->a + $this->b;
	}

}

$addition = new Addition(23, 1);
echo $addition->calculate(); // 24
```

Обидва приклади повністю відповідають принципу впровадження залежностей.


Приклади з реального життя .[#toc-real-life-examples]
-----------------------------------------------------

У реальному світі ви не будете писати класи для додавання чисел. Давайте перейдемо до прикладів із реального життя.

Нехай у нас є клас `Article`, що представляє статтю в блозі:

```php
class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		// зберегти статтю в базі даних
	}
}
```

а його використання буде таким:

```php
$article = new Article;
$article->title = '10 вещей, которые нужно знать о потере веса';
$article->content = 'Каждый год миллионы людей в ...';
$article->save();
```

Метод `save()` збереже статтю в таблиці бази даних. Реалізація цього методу з використанням [Nette Database |database:] була б простою справою, якби не одна заковика: де `Article` отримує з'єднання з базою даних, тобто об'єкт класу `Nette\Database\Connection`?

Здається, у нас є багато варіантів. Він може взяти його з якоїсь статичної змінної. Або успадковуватися від класу, який буде надавати з'єднання з базою даних. Або скористатися так званим синглтоном. Або скористатися так званими фасадами, які використовуються в Laravel:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		DB::insert(
			'INSERT INTO articles (title, content) VALUES (?, ?)',
			[$this->title, $this->content],
		);
	}
}
```

Чудово, ми вирішили проблему.

Чи ні?

Згадайте [правило №1: використовувати параметри |#правило №1: использовать параметры]: ми повинні передавати класу всі дані, які йому потрібні. Тому що якщо ми цього не зробимо і порушимо правило, ми почнемо шлях до брудного коду, сповненого прихованих прив'язок, незрозумілостей, і в результаті отримаємо застосунок, який дуже складно підтримувати і розвивати.

Користувач класу `Article` поняття не має, де метод `save()` зберігає статтю. У таблиці бази даних? У якій саме, в crisp або test? І як це можна змінити?

Користувач має подивитися, як реалізовано метод `save()`, щоб знайти використання методу `DB::insert()`. Тому йому доводиться шукати далі, щоб з'ясувати, як цей метод забезпечує підключення до бази даних. А приховані прив'язки можуть утворювати досить довгий ланцюжок.

Приховані прив'язки, фасади Laravel або статичні змінні ніколи не присутні в чистому, добре продуманому коді. У чистому і добре продуманому коді передаються аргументи:

```php
class Article
{
	public function save(Nette\Database\Connection $db): void
	{
		$db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Ще більш практичним, як ми побачимо далі, є використання конструктора:

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function save(): void
	{
		$this->db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Якщо ви збираєтеся написати клас, якому, наприклад, потрібна база даних, не з'ясовуйте, звідки її взяти, а нехай вона буде передана вам. Можливо, як параметр конструктора або іншого методу. Оголошуйте залежності. Оголошуйте їх в API вашого класу. Ви отримаєте зрозумілий і передбачуваний код.

Як щодо класу, який реєструє повідомлення про помилки:

```php
class Logger
{
	public function log(string $message)
	{
		$file = LOG_DIR . '/log.txt';
		file_put_contents($file, $message . "\n", FILE_APPEND);
	}
}
```

Як ви думаєте, чи дотримувалися ми [правила №1: використовувати параметри |#правилу №1: использовать параметры]?

Ні.

Клас *отримує* ключову інформацію, директорію, що містить файл журналу, з константи.

Подивіться приклад використання:

```php
$logger = new Logger;
$logger->log('Температура 23 °C');
$logger->log('Температура 10 °C');
```

Не знаючи реалізації, чи можете ви відповісти на запитання, де записані повідомлення? Чи не здається вам, що існування константи LOG_DIR необхідне для його роботи? І чи зможете ви створити другий екземпляр, який писатиме в інше місце? Звичайно, ні.

Давайте виправимо клас:

```php
class Logger
{
	public function __construct(
		private string $file,
	) {
	}

	public function log(string $message)
	{
		file_put_contents($this->file, $message . "\n", FILE_APPEND);
	}
}
```

Тепер клас став набагато зрозумілішим, більш налаштовуваним і, отже, більш корисним:

```php
$logger = new Logger('/path/to/log.txt');
$logger->log('Температура 15 °C');
```


Але мені все одно! .[#toc-but-i-don-t-care]
-------------------------------------------

*"Коли я створюю об'єкт Article і викликаю save(), я не хочу мати справу з базою даних, я просто хочу, щоб він був збережений у тій, яку я встановив у конфігурації. "*

*"Коли я використовую Logger, я просто хочу, щоб повідомлення було записано, і я не хочу розбиратися з тим, куди. Нехай використовуються глобальні налаштування. "*

Це правильні коментарі.

Як приклад візьмемо клас, який розсилає інформаційні повідомлення і реєструє в журналі результати розсилки:

```php
class NewsletterDistributor
{
	public function distribute(): void
	{
		$logger = new Logger(/* ... */);
		try {
			$this->sendEmails();
			$logger->log('Были разосланы электронные письма');

		} catch (Exception $e) {
			$logger->log('Во время отправки произошла ошибка');
			throw $e;
		}
	}
}
```

Однак новий `Logger`, який більше не використовує константу `LOG_DIR`, вимагає зазначення шляху до файлу в конструкторі. Як вирішити цю проблему? Класу `NewsletterDistributor` все одно, куди записуються повідомлення, він просто хоче їх записувати.

Рішенням знову є [правило №1: використовуйте параметри |#правило №1: используйте параметры]: передавайте класу всі дані, які йому потрібні.

Отже, ми передаємо шлях до журналу в конструктор, який потім використовуємо при створенні об'єкта `Logger`? Ні. Тому що шлях - це не ті дані, які потрібні класу `NewsletterDistributor`. Класу потрібен сам логгер. І ми збираємося передати його:


```php
class NewsletterDistributor
{
	public function __construct(
		private Logger $logger,
	) {
	}

	public function distribute(): void
	{
		try {
			$this->sendEmails();
			$this->logger->log('Были разосланы электронные письма');

		} catch (Exception $e) {
			$this->logger->log('Во время отправки произошла ошибка');
			throw $e;
		}
	}
}
```

Тепер із сигнатур класу `NewsletterDistributor` зрозуміло, що ведення журналу є частиною його функціональності. І у вас є можливість замінити логгер на інший.

Якщо в усьому застосунку ми можемо задовольнятися єдиним екземпляром логгера і передавати його скрізь, де щось реєструється, то у випадку з класом `Article` все інакше. Ми захочемо створити кілька його екземплярів. Як впоратися із залежністю від бази даних у конструкторі? Як приклад візьмемо контролер, який має зберігати статтю в базу даних після відправлення форми:

```php
class UserController extends Controller
{
	public function formSubmitted($data)
	{
		$article = new Article(/* ... */);
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Пропонується можливе рішення: передайте об'єкт бази даних у конструктор класу `UserController` і використовуйте `$article = new Article($this->db)`.

Як і в попередньому випадку, це неправильна практика. База даних не є залежністю `UserController`, а є залежністю `Article`. Ба більше, щойно конструктор класу `Article` буде якимось чином змінено (додано новий параметр), нам доведеться модифікувати код у всіх місцях, де створюються екземпляри.

Правильне рішення - фабрики.


Правило №2: Використовуйте фабрики .[#toc-rule-2-use-factories]
---------------------------------------------------------------

Видаляючи приховані прив'язки і передаючи всі дані як аргументи, ми отримуємо гнучкіші та гнучкіші класи, які можна налаштувати. Тому нам все ще потрібно щось для створення і налаштування цих більш гнучких класів. Ми назвемо це фабрикою.

Емпіричне правило таке: якщо клас має залежності, залиште створення їхніх екземплярів фабриці.

Фабрики є більш розумною заміною оператору `new` у світі впровадження залежностей.


Фабрика .[#toc-factory]
-----------------------

Фабрика - це клас, який створює і налаштовує об'єкти. Фабрика, яка виробляє `Article`, називатиметься `ArticleFactory`, і її використання в контролері буде таким:

```php
class UserController extends Controller
{
	public function __construct(
		private ArticleFactory $articleFactory,
	) {
	}

	public function formSubmitted($data)
	{
		// дозволити фабриці створити об'єкт
		$article = $this->articleFactory->create();
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Реалізація фабрики може виглядати таким чином:


```php
class ArticleFactory
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

У цей момент, коли сигнатура конструктора класу `Article` змінюється, єдиною частиною коду, яка повинна реагувати на це, є фабрика `ArticleFactory`. Будь-який інший код, що працює з об'єктами `Article`, наприклад, `UserController`, залишається незачепленим.

Ви, можливо, зараз б'єте себе по лобі, задаючись питанням, яким чином вам це допоможе. Адже обсяг коду виріс і перемістився з контролера в окремий клас. Однак у Nette DI є прихований туз у рукаві. Він розуміє концепцію фабрик і навіть може [написати такий сервіс для нас |factory]. Тому замість класу `ArticleFactory` ми можемо просто створити інтерфейс:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

Але ми трохи забігаємо наперед, перейдемо до цього за хвилину.


Підіб'ємо підсумок .[#toc-summary]
----------------------------------

На початку цього розділу ми обіцяли продемонструвати простий принцип розроблення додатків. Хоча сам принцип простий (надати класам необхідні їм дані), те, що з нього випливає, вимагає більш глибокого осмислення. Не соромтеся перечитувати цей розділ кілька разів.

Програмісти, які відкинули старі звички і почали послідовно використовувати впровадження залежностей, вважають це поворотним моментом у своєму професійному житті. Вона відкрила світ чітких і стійких додатків.

Тепер ми подивимося, що таке [Контейнер впровадження залежно стей|container].
