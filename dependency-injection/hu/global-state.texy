Glob√°lis √°llapot √©s singletonok
*******************************

.[perex]
Figyelmeztet√©s: A k√∂vetkez≈ë konstrukci√≥k a rossz k√≥dtervez√©s t√ºnetei:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` vagy `static::$var`

El≈ëfordulnak-e ezek a konstrukci√≥k az √ñn k√≥dj√°ban? Akkor lehet≈ës√©ge van a jav√≠t√°sra. Tal√°n arra gondolsz, hogy ezek olyan gyakori konstrukci√≥k, amelyeket k√ºl√∂nb√∂z≈ë k√∂nyvt√°rak √©s keretrendszerek mintamegold√°saiban l√°tunk.
Sajnos ezek m√©g mindig a rossz tervez√©s egy√©rtelm≈± jelei. Egy dolog k√∂z√∂s benn√ºk: a glob√°lis √°llapot haszn√°lata.

Most biztosan nem valamif√©le akad√©miai tisztas√°gr√≥l besz√©l√ºnk. A glob√°lis √°llapot √©s a singletonok haszn√°lata rombol√≥ hat√°ssal van a k√≥d min≈ës√©g√©re. A viselked√©s kisz√°m√≠thatatlann√° v√°lik, cs√∂kkenti a fejleszt≈ëk termel√©kenys√©g√©t, √©s arra k√©nyszer√≠ti az oszt√°lyinterf√©szeket, hogy hazudjanak a val√≥di f√ºgg≈ës√©g√ºkr≈ël. Ami √∂sszezavarja a programoz√≥kat.

Ebben a fejezetben megmutatjuk, hogyan lehets√©ges ez.


Glob√°lis √∂sszekapcsol√°s .[#toc-global-interlinking]
---------------------------------------------------

A glob√°lis √°llammal az az alapvet≈ë probl√©ma, hogy glob√°lisan hozz√°f√©rhet≈ë. Ez lehet≈ëv√© teszi, hogy a `DB::insert()` glob√°lis (statikus) met√≥duson kereszt√ºl √≠rjunk az adatb√°zisba.
Egy ide√°lis vil√°gban egy objektumnak csak olyan m√°s objektumokkal kellene tudnia kommunik√°lni, amelyeket [k√∂zvetlen√ºl √°tadtak neki |passing-dependencies].
Ha l√©trehozok k√©t objektumot `A` √©s `B`, √©s soha nem adok √°t hivatkoz√°st a `A` objektumr√≥l a `B` objektumra, akkor sem a `A`, sem a `B` nem tud hozz√°f√©rni a m√°sik objektumhoz, √©s nem tudja megv√°ltoztatni annak √°llapot√°t.
Ez egy nagyon k√≠v√°natos tulajdons√°ga a k√≥dnak. Hasonl√≥ ahhoz, mintha lenne egy elem √©s egy izz√≥; az izz√≥ nem fog vil√°g√≠tani, am√≠g √∂ssze nem kapcsoljuk ≈ëket.

Ez nem igaz a glob√°lis (statikus) v√°ltoz√≥kra vagy a szingletonokra. A `A` objektum *vezet√©k n√©lk√ºl* hozz√°f√©rhet a `C` objektumhoz, √©s m√≥dos√≠thatja azt hivatkoz√°s √°tad√°sa n√©lk√ºl, a `C::changeSomething()` megh√≠v√°s√°val.
Ha a `B` objektum a glob√°lis `C` objektumot is megragadja, akkor a `A` √©s a `B` objektum a `C` objektumon kereszt√ºl k√∂lcs√∂nhat√°sba l√©phet egym√°ssal.

A glob√°lis v√°ltoz√≥k haszn√°lata a *vezet√©k n√©lk√ºli* csatol√°s egy √∫j, k√≠v√ºlr≈ël nem l√°that√≥ form√°j√°t vezeti be a rendszerbe.
Ez egy f√ºstf√ºgg√∂nyt hoz l√©tre, amely megnehez√≠ti a k√≥d meg√©rt√©s√©t √©s haszn√°lat√°t.
A fejleszt≈ëknek a forr√°sk√≥d minden sor√°t el kell olvasniuk ahhoz, hogy val√≥ban meg√©rts√©k a f√ºgg≈ës√©geket. Ahelyett, hogy csak az oszt√°lyok interf√©sz√©vel ismerkedn√©nek.
R√°ad√°sul ez egy teljesen felesleges csatol√°s.

.[note]
A viselked√©s szempontj√°b√≥l nincs k√ºl√∂nbs√©g egy glob√°lis √©s egy statikus v√°ltoz√≥ k√∂z√∂tt. Egyform√°n k√°rosak.


A k√≠s√©rteties cselekv√©s t√°volr√≥l .[#toc-the-spooky-action-at-a-distance]
------------------------------------------------------------------------

"K√≠s√©rteties hat√°s a t√°volban" - √≠gy nevezte Albert Einstein 1935-ben a kvantumfizika egyik jelens√©g√©t, amelyt≈ël kir√°zta a hideg.
Ez a kvantum √∂sszefon√≥d√°s, amelynek saj√°toss√°ga, hogy amikor egy r√©szecsk√©r≈ël inform√°ci√≥t m√©r√ºnk, azonnal hat√°ssal vagyunk egy m√°sik r√©szecsk√©re, m√©g akkor is, ha azok t√∂bb milli√≥ f√©ny√©vre vannak egym√°st√≥l.
ami l√°tsz√≥lag s√©rti a vil√°gegyetem alapvet≈ë t√∂rv√©ny√©t, miszerint semmi sem haladhat gyorsabban a f√©nyn√©l.

A szoftverek vil√°g√°ban "spooky action at a distance"-nek nevezhetj√ºk azt a helyzetet, amikor lefuttatunk egy folyamatot, amelyr≈ël azt gondoljuk, hogy elszigetelt (mert nem adtunk √°t neki semmilyen hivatkoz√°st), de v√°ratlan k√∂lcs√∂nhat√°sok √©s √°llapotv√°ltoz√°sok t√∂rt√©nnek a rendszer t√°voli pontjain, amelyekr≈ël nem sz√≥ltunk az objektumnak. Ez csak a glob√°lis √°llapoton kereszt√ºl t√∂rt√©nhet.

K√©pzelj√ºk el, hogy csatlakozunk egy olyan projektfejleszt≈ë csapathoz, amely nagy, kiforrott k√≥db√°zissal rendelkezik. Az √∫j vezet≈ëd megk√©r egy √∫j funkci√≥ megval√≥s√≠t√°s√°ra, √©s j√≥ fejleszt≈ëh√∂z m√©lt√≥an egy teszt meg√≠r√°s√°val kezded. De mivel √∫j vagy a projektben, sok felt√°r√≥ "mi t√∂rt√©nik, ha megh√≠vom ezt a met√≥dust" t√≠pus√∫ tesztet csin√°lsz. √âs megpr√≥b√°lod meg√≠rni a k√∂vetkez≈ë tesztet:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // az √ñn k√°rtyasz√°m√°t
	$cc->charge(100);
}
```

Egy id≈ë ut√°n √©szreveszed, hogy a bank √©rtes√≠t√©st k√ºld a telefonodon, hogy minden egyes futtat√°skor 100 doll√°rral terhelt√©k meg a hitelk√°rty√°dat. ü§¶‚Äç‚ôÇÔ∏è

Hogy a fen√©be okozhatott a teszt t√©nyleges terhel√©st? Nem k√∂nny≈± a hitelk√°rty√°val oper√°lni. Egy harmadik f√©l webes szolg√°ltat√°s√°val kell kapcsolatba l√©pnie, ismernie kell a webes szolg√°ltat√°s URL-j√©t, be kell jelentkeznie, √©s √≠gy tov√°bb.
Ezek k√∂z√ºl az inform√°ci√≥k k√∂z√ºl egyik sem szerepel a tesztben. M√©g rosszabb, hogy azt sem tudod, hol vannak ezek az inform√°ci√≥k, √©s ez√©rt nem tudod, hogyan kell a k√ºls≈ë f√ºgg≈ës√©geket leut√°nozni, hogy minden egyes futtat√°sn√°l ne kelljen √∫jra 100 doll√°rt fizetni. √âs √∫j fejleszt≈ëk√©nt honnan kellett volna tudnod, hogy amit most fogsz csin√°lni, az 100 doll√°rral szeg√©nyebb√© tesz t√©ged?

Ez egy k√≠s√©rteties akci√≥ a t√°volb√≥l!

Nincs m√°s v√°laszt√°sod, mint rengeteg forr√°sk√≥dban turk√°lni, megk√©rdezni id≈ësebb √©s tapasztaltabb koll√©g√°kat, am√≠g meg nem √©rted, hogyan m≈±k√∂dnek az √∂sszef√ºgg√©sek a projektben.
Ennek oka, hogy a `CreditCard` oszt√°ly interf√©sz√©t megn√©zve nem tudod meghat√°rozni az inicializ√°land√≥ glob√°lis √°llapotot. M√©g az oszt√°ly forr√°sk√≥dj√°nak megn√©z√©se sem √°rulja el, hogy melyik inicializ√°l√°si met√≥dust kell megh√≠vni. A legjobb esetben megkereshetj√ºk a glob√°lis v√°ltoz√≥t, amelyhez hozz√°f√©r√ºnk, √©s ebb≈ël pr√≥b√°lhatjuk kital√°lni, hogyan kell inicializ√°lni.

Egy ilyen projektben az oszt√°lyok beteges hazudoz√≥k. A fizet√©si k√°rtya √∫gy tesz, mintha egyszer≈±en csak instanci√°zn√°d, √©s megh√≠vn√°d a `charge()` met√≥dust. Titokban azonban k√∂lcs√∂nhat√°sba l√©p egy m√°sik oszt√°llyal, a `PaymentGateway`. M√©g az interf√©sze is azt mondja, hogy √∂n√°ll√≥an inicializ√°lhat√≥, de a val√≥s√°gban valamilyen konfigur√°ci√≥s f√°jlb√≥l h√∫zza a hiteles√≠t≈ë adatokat, √©s √≠gy tov√°bb.
A k√≥dot √≠r√≥ fejleszt≈ëk sz√°m√°ra egy√©rtelm≈±, hogy a `CreditCard` -nak sz√ºks√©ge van a `PaymentGateway`. √çgy √≠rt√°k meg a k√≥dot. De b√°rki sz√°m√°ra, aki √∫j a projektben, ez teljes rejt√©ly, √©s akad√°lyozza a tanul√°st.

Hogyan lehet kijav√≠tani a helyzetet? Egyszer≈±en. **Hagyjuk, hogy az API deklar√°lja a f√ºgg≈ës√©geket.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Figyelj√ºk meg, hogy a k√≥don bel√ºli kapcsolatok hirtelen nyilv√°nval√≥v√° v√°lnak. Azzal, hogy deklar√°ljuk, hogy a `charge()` met√≥dusnak sz√ºks√©ge van a `PaymentGateway` c√≠mre, senkit≈ël sem kell megk√©rdezn√ºnk, hogy a k√≥d hogyan f√ºgg egym√°st√≥l. Tudod, hogy egy p√©ld√°nyt kell l√©trehoznod bel≈ële, √©s amikor megpr√≥b√°lod ezt megtenni, belefutsz abba, hogy hozz√°f√©r√©si param√©tereket kell megadnod. Ezek n√©lk√ºl a k√≥d nem is futna.

√âs ami a legfontosabb, most m√°r le tudja mockolni a fizet√©si √°tj√°r√≥t, hogy ne kelljen 100 doll√°rt fizetnie minden egyes teszt futtat√°sakor.

A glob√°lis √°llapot miatt az objektumaid titokban hozz√°f√©rhetnek olyan dolgokhoz, amelyek nincsenek deklar√°lva az API-jukban, √©s ennek eredm√©nyek√©ppen az API-id k√≥ros hazudoz√≥kk√° v√°lnak.

Lehet, hogy eddig nem gondolt√°l r√° √≠gy, de valah√°nyszor glob√°lis √°llapotot haszn√°lsz, titkos vezet√©k n√©lk√ºli kommunik√°ci√≥s csatorn√°kat hozol l√©tre. A h√°tborzongat√≥ t√°voli m≈±k√∂d√©s arra k√©nyszer√≠ti a fejleszt≈ëket, hogy minden egyes k√≥dsort elolvassanak a lehets√©ges interakci√≥k meg√©rt√©s√©hez, cs√∂kkenti a fejleszt≈ëk termel√©kenys√©g√©t, √©s √∂sszezavarja az √∫j csapattagokat.
Ha te vagy az, aki a k√≥dot l√©trehozta, akkor ismered a val√≥di f√ºgg≈ës√©geket, de b√°rki, aki ut√°nad j√∂n, tan√°cstalan.

Ne √≠rjon olyan k√≥dot, amely glob√°lis √°llapotot haszn√°l, ink√°bb adja √°t a f√ºgg≈ës√©geket. Vagyis a f√ºgg≈ës√©gi injekt√°l√°s.


A glob√°lis √°llam t√∂r√©kenys√©ge .[#toc-brittleness-of-the-global-state]
---------------------------------------------------------------------

A glob√°lis √°llapotot √©s singletonokat haszn√°l√≥ k√≥dban sosem lehet√ºnk biztosak abban, hogy az √°llapotot mikor √©s ki v√°ltoztatta meg. Ez a kock√°zat m√°r az inicializ√°l√°skor fenn√°ll. A k√∂vetkez≈ë k√≥dnak egy adatb√°zis-kapcsolatot kellene l√©trehoznia √©s inicializ√°lnia a fizet√©si √°tj√°r√≥t, de folyamatosan kiv√©telt dob, √©s az ok√°nak megtal√°l√°sa rendk√≠v√ºl f√°raszt√≥:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

R√©szletesen √°t kell n√©zni a k√≥dot, hogy kider√ºlj√∂n, hogy a `PaymentGateway` objektum vezet√©k n√©lk√ºl m√°s objektumokhoz is hozz√°f√©r, amelyek k√∂z√ºl n√©h√°nyhoz adatb√°zis-kapcsolat sz√ºks√©ges. √çgy a `PaymentGateway` el≈ëtt inicializ√°lni kell az adatb√°zist. A glob√°lis √°llapot f√ºstf√ºgg√∂nye azonban ezt elrejti √ñn el≈ël. Mennyi id≈ët sp√≥rolna meg, ha az egyes oszt√°lyok API-ja nem hazudna √©s nem jelenten√© be f√ºgg≈ës√©geit?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Hasonl√≥ probl√©ma mer√ºl fel, amikor glob√°lis hozz√°f√©r√©st haszn√°lunk egy adatb√°zis-kapcsolathoz:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

A `save()` met√≥dus megh√≠v√°sakor nem biztos, hogy az adatb√°zis-kapcsolat m√°r l√©trej√∂tt-e, √©s ki a felel≈ës a l√©trehoz√°s√°√©rt. Ha p√©ld√°ul menet k√∂zben szeretn√©nk megv√°ltoztatni az adatb√°zis-kapcsolatot, esetleg tesztel√©si c√©llal, akkor val√≥sz√≠n≈±leg tov√°bbi met√≥dusokat kellene l√©trehoznunk, p√©ld√°ul a `DB::reconnect(...)` vagy a `DB::reconnectForTest()` met√≥dusokat.

Vegy√ºnk egy p√©ld√°t:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Hol lehet√ºnk biztosak abban, hogy a `$article->save()` megh√≠v√°sakor val√≥ban a tesztadatb√°zist haszn√°ljuk ? Mi van, ha a `Foo::doSomething()` m√≥dszer megv√°ltoztatta a glob√°lis adatb√°zis-kapcsolatot? Ahhoz, hogy ezt megtudjuk, meg kellene vizsg√°lnunk a `Foo` oszt√°ly √©s val√≥sz√≠n≈±leg sok m√°s oszt√°ly forr√°sk√≥dj√°t. Ez a megk√∂zel√≠t√©s azonban csak r√∂vid t√°v√∫ v√°laszt adna, mivel a j√∂v≈ëben v√°ltozhat a helyzet.

Mi lenne, ha az adatb√°zis-kapcsolatot egy statikus v√°ltoz√≥ba helyezn√©nk √°t a `Article` oszt√°lyon bel√ºl?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Ez egy√°ltal√°n nem v√°ltoztat semmit. A probl√©ma egy glob√°lis √°llapot, √©s nem sz√°m√≠t, hogy melyik oszt√°lyban rejt≈ëzik. Ebben az esetben, ahogy az el≈ëz≈ë esetben is, fogalmunk sincs arr√≥l, hogy a `$article->save()` met√≥dus megh√≠v√°sakor milyen adatb√°zisba √≠r√≥dik. B√°rki az alkalmaz√°s t√°voli v√©g√©n b√°rmikor megv√°ltoztathatja az adatb√°zist a `Article::setDb()` seg√≠ts√©g√©vel. A mi kez√ºnk alatt.

A glob√°lis √°llapot miatt az alkalmaz√°sunk **rendk√≠v√ºl t√∂r√©kenny√©** v√°lik.

Van azonban egy egyszer≈± m√≥dja ennek a probl√©m√°nak a kezel√©s√©re. Csak az API-nak kell deklar√°lnia a f√ºgg≈ës√©geket a megfelel≈ë funkcionalit√°s biztos√≠t√°sa √©rdek√©ben.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Ez a megk√∂zel√≠t√©s kik√ºsz√∂b√∂li az adatb√°zis-kapcsolatok rejtett √©s v√°ratlan v√°ltoz√°sai miatti aggodalmat. Most m√°r biztosak vagyunk abban, hogy a cikket hol t√°roljuk, √©s semmilyen k√≥dm√≥dos√≠t√°s egy m√°sik, nem kapcsol√≥d√≥ oszt√°lyon bel√ºl nem v√°ltoztathatja meg t√∂bb√© a helyzetet. A k√≥d t√∂bb√© nem t√∂r√©keny, hanem stabil.

Ne √≠rjunk olyan k√≥dot, amely glob√°lis √°llapotot haszn√°l, ink√°bb adjuk √°t a f√ºgg≈ës√©geket. √çgy a f√ºgg≈ës√©gi injekt√°l√°s.


Singleton .[#toc-singleton]
---------------------------

A singleton egy olyan tervez√©si minta, amely a h√≠res Gang of Four kiadv√°ny [defin√≠ci√≥ja |https://en.wikipedia.org/wiki/Singleton_pattern] szerint egy oszt√°lyt egyetlen p√©ld√°nyra korl√°toz, √©s glob√°lis hozz√°f√©r√©st biztos√≠t hozz√°. Ennek a mint√°nak a megval√≥s√≠t√°sa √°ltal√°ban a k√∂vetkez≈ë k√≥dhoz hasonl√≠t:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// √©s m√°s met√≥dusok, amelyek az oszt√°ly funkci√≥it hajtj√°k v√©gre.
}
```

Sajnos a singleton glob√°lis √°llapotot vezet be az alkalmaz√°sba. √âs mint fentebb megmutattuk, a glob√°lis √°llapot nem k√≠v√°natos. Ez√©rt tekinthet≈ë a singleton antipatternnek.

Ne haszn√°ljon singletont a k√≥dj√°ban, √©s helyettes√≠tse m√°s mechanizmusokkal. T√©nyleg nincs sz√ºks√©ged szingletonokra. Ha azonban garant√°lnod kell egy oszt√°ly egyetlen p√©ld√°ny√°nak l√©tez√©s√©t az eg√©sz alkalmaz√°s sz√°m√°ra, akkor hagyd ezt a [DI kont√©nerre |container].
√çgy hozzon l√©tre egy alkalmaz√°s szingletont, vagy szolg√°ltat√°st. Ez√°ltal az oszt√°ly nem fogja biztos√≠tani a saj√°t egyedis√©g√©t (azaz nem lesz `getInstance()` met√≥dusa √©s statikus v√°ltoz√≥ja), √©s csak a funkci√≥it fogja v√©grehajtani. √çgy megsz≈±nik az egyetlen felel≈ëss√©g elv√©nek megs√©rt√©se.


Glob√°lis √°llapot a tesztek ellen√©ben .[#toc-global-state-versus-tests]
----------------------------------------------------------------------

A tesztek √≠r√°sa sor√°n felt√©telezz√ºk, hogy minden teszt egy izol√°lt egys√©g, √©s nem ker√ºl bele k√ºls≈ë √°llapot. √âs semmilyen √°llapot nem hagyja el a teszteket. Amikor egy teszt befejez≈ëdik, a teszthez kapcsol√≥d√≥ √°llapotot a szem√©tgy≈±jt≈ënek automatikusan el kell t√°vol√≠tania. Ez teszi a teszteket izol√°ltt√°. Ez√©rt a teszteket tetsz≈ëleges sorrendben futtathatjuk.

Ha azonban glob√°lis √°llapotok/singletonok vannak jelen, akkor mindezek a sz√©p felt√©telez√©sek √∂sszeomlanak. Egy √°llapot bel√©phet √©s kil√©phet egy tesztb≈ël. Hirtelen a tesztek sorrendje sz√°m√≠that.

Ahhoz, hogy a szingletonokat egy√°ltal√°n tesztelni lehessen, a fejleszt≈ëknek gyakran laz√≠taniuk kell a tulajdons√°gaikon, p√©ld√°ul √∫gy, hogy megengedik, hogy egy p√©ld√°nyt egy m√°sikra cser√©ljenek. Az ilyen megold√°sok a legjobb esetben is hackek, amelyek nehezen karbantarthat√≥ √©s nehezen √©rthet≈ë k√≥dot eredm√©nyeznek. Minden olyan tesztnek vagy met√≥dusnak `tearDown()`, amely b√°rmilyen glob√°lis √°llapotot √©rint, vissza kell vonnia ezeket a v√°ltoz√°sokat.

A glob√°lis √°llapot a legnagyobb fejf√°j√°s az egys√©gtesztel√©sben!

Hogyan lehet megoldani a helyzetet? Egyszer≈±en. Ne √≠rj olyan k√≥dot, amely singletonokat haszn√°l, ink√°bb add √°t a f√ºgg≈ës√©geket. Vagyis f√ºgg≈ës√©gi injekt√°l√°ssal.


Glob√°lis konstansok .[#toc-global-constants]
--------------------------------------------

A glob√°lis √°llapot nem korl√°toz√≥dik a szingletonok √©s statikus v√°ltoz√≥k haszn√°lat√°ra, hanem a glob√°lis konstansokra is vonatkozhat.

Azok a konstansok, amelyek √©rt√©ke nem szolg√°ltat sz√°munkra √∫j (`M_PI`) vagy hasznos (`PREG_BACKTRACK_LIMIT_ERROR`) inform√°ci√≥t, egy√©rtelm≈±en rendben vannak.
Ezzel szemben azok a konstansok, amelyek arra szolg√°lnak, hogy *vezet√©k n√©lk√ºl* inform√°ci√≥t adjunk √°t a k√≥don bel√ºl, nem t√∂bbek, mint rejtett f√ºgg≈ës√©g. Mint a `LOG_FILE` a k√∂vetkez≈ë p√©ld√°ban.
A `FILE_APPEND` konstans haszn√°lata teljesen helyes.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ebben az esetben a param√©tert a `Foo` oszt√°ly konstruktor√°ban kell deklar√°lnunk, hogy az API r√©sz√©v√© v√°ljon:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Most m√°r √°tadhatjuk a napl√≥f√°jl el√©r√©si √∫tvonal√°ra vonatkoz√≥ inform√°ci√≥t, √©s sz√ºks√©g eset√©n k√∂nnyen m√≥dos√≠thatjuk azt, √≠gy k√∂nnyebben tesztelhetj√ºk √©s karbantarthatjuk a k√≥dot.


Glob√°lis f√ºggv√©nyek √©s statikus met√≥dusok .[#toc-global-functions-and-static-methods]
-------------------------------------------------------------------------------------

Szeretn√©nk hangs√∫lyozni, hogy a statikus met√≥dusok √©s glob√°lis f√ºggv√©nyek haszn√°lata √∂nmag√°ban nem probl√©m√°s. A `DB::insert()` √©s hasonl√≥ m√≥dszerek haszn√°lat√°nak helytelens√©g√©t m√°r elmagyar√°ztuk, de mindig is a statikus v√°ltoz√≥ban t√°rolt glob√°lis √°llapotr√≥l volt sz√≥. A `DB::insert()` met√≥dus megk√∂veteli egy statikus v√°ltoz√≥ megl√©t√©t, mivel az adatb√°zis-kapcsolatot t√°rolja. E v√°ltoz√≥ n√©lk√ºl lehetetlen lenne a m√≥dszer v√©grehajt√°sa.

A determinisztikus statikus m√≥dszerek √©s f√ºggv√©nyek, mint p√©ld√°ul a `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` √©s sok m√°s, haszn√°lata t√∂k√©letesen √∂sszhangban van a f√ºgg≈ës√©gi injekt√°l√°ssal. Ezek a f√ºggv√©nyek mindig ugyanazokat az eredm√©nyeket adj√°k vissza ugyanazokb√≥l a bemeneti param√©terekb≈ël, ez√©rt kisz√°m√≠that√≥ak. Nem haszn√°lnak semmilyen glob√°lis √°llapotot.

Vannak azonban a PHP-ben olyan f√ºggv√©nyek, amelyek nem determinisztikusak. Ezek k√∂z√© tartozik p√©ld√°ul a `htmlspecialchars()` f√ºggv√©ny. Harmadik param√©tere, a `$encoding`, ha nincs megadva, alap√©rtelmez√©s szerint a `ini_get('default_charset')` konfigur√°ci√≥s opci√≥ √©rt√©k√©t veszi fel. Ez√©rt aj√°nlott mindig megadni ezt a param√©tert, hogy elker√ºlj√ºk a f√ºggv√©ny esetleges kisz√°m√≠thatatlan viselked√©s√©t. A Nette k√∂vetkezetesen ezt teszi.

Egyes f√ºggv√©nyek, mint p√©ld√°ul a `strtolower()`, `strtoupper()` √©s hasonl√≥k, a k√∂zelm√∫ltban nem determinisztikus viselked√©st mutattak, √©s a `setlocale()` be√°ll√≠t√°s√°t√≥l f√ºggtek. Ez sok bonyodalmat okozott, leggyakrabban a t√∂r√∂k nyelvvel val√≥ munka sor√°n.
Ennek oka, hogy a t√∂r√∂k nyelv k√ºl√∂nbs√©get tesz a kis- √©s nagybet≈±s `I` k√∂z√∂tt ponttal √©s pont n√©lk√ºl. √çgy a `strtolower('I')` a `ƒ±` karaktert, a `strtoupper('i')` pedig a `ƒ∞` karaktert adta vissza , ami az alkalmaz√°sokban sz√°mos rejt√©lyes hib√°t okozott.
Ezt a probl√©m√°t azonban a PHP 8.2-es verzi√≥j√°ban kijav√≠tott√°k, √©s a f√ºggv√©nyek t√∂bb√© nem f√ºggnek a nyelvj√°r√°st√≥l.

Ez egy sz√©p p√©lda arra, hogy a glob√°lis √°llapot fejleszt≈ëk ezreit s√∫jtotta vil√°gszerte. A megold√°s az volt, hogy f√ºgg≈ës√©gi injekt√°l√°ssal helyettes√≠tett√©k.


Mikor lehets√©ges a glob√°lis √°llapot haszn√°lata? .[#toc-when-is-it-possible-to-use-global-state]
-----------------------------------------------------------------------------------------------

Vannak bizonyos speci√°lis helyzetek, amikor lehets√©ges a glob√°lis √°llapot haszn√°lata. P√©ld√°ul k√≥d hibakeres√©skor, amikor ki kell dobni egy v√°ltoz√≥ √©rt√©k√©t, vagy meg kell m√©rni a program egy adott r√©sz√©nek id≈ëtartam√°t. Ilyen esetekben, amelyek olyan ideiglenes m≈±veletekre vonatkoznak, amelyeket k√©s≈ëbb elt√°vol√≠tunk a k√≥db√≥l, jogos egy glob√°lisan el√©rhet≈ë dumper vagy stopper√≥ra haszn√°lata. Ezek az eszk√∂z√∂k nem r√©szei a k√≥dtervez√©snek.

Egy m√°sik p√©lda a `preg_*`, a regul√°ris kifejez√©sekkel val√≥ munkav√©gz√©sre szolg√°l√≥ f√ºggv√©nyek, amelyek a leford√≠tott regul√°ris kifejez√©seket bels≈ëleg egy statikus gyors√≠t√≥t√°rban t√°rolj√°k a mem√≥ri√°ban. Ha ugyanazt a regul√°ris kifejez√©st a k√≥d k√ºl√∂nb√∂z≈ë r√©szeiben t√∂bbsz√∂r h√≠vja meg, akkor csak egyszer ford√≠tja le. A gyors√≠t√≥t√°r teljes√≠tm√©nyt takar√≠t meg, √©s a felhaszn√°l√≥ sz√°m√°ra is teljesen l√°thatatlan, √≠gy az ilyen haszn√°lat jogosnak tekinthet≈ë.


√ñsszefoglal√≥ .[#toc-summary]
----------------------------

Megmutattuk, mi√©rt van √©rtelme

1) T√°vol√≠tsunk el minden statikus v√°ltoz√≥t a k√≥db√≥l.
2) Deklar√°ljuk a f√ºgg≈ës√©geket
3) √âs haszn√°ljuk a f√ºgg≈ës√©gi injekt√°l√°st

Amikor a k√≥dtervez√©sr≈ël gondolkodik, tartsa szem el≈ëtt, hogy minden egyes `static $foo` egy probl√©m√°t jelent. Ahhoz, hogy a k√≥dod DI-tisztel≈ë k√∂rnyezet legyen, elengedhetetlen a glob√°lis √°llapot teljes kiirt√°sa √©s f√ºgg≈ës√©gi injekt√°l√°ssal val√≥ helyettes√≠t√©se.

E folyamat sor√°n el≈ëfordulhat, hogy egy oszt√°lyt fel kell osztanod, mert egyn√©l t√∂bb felel≈ëss√©ge van. Ne agg√≥djon emiatt; t√∂rekedjen az egy felel≈ëss√©g elv√©re.

*K√∂sz√∂n√∂m Mi≈°ko Hevery-nek, akinek olyan cikkei, mint a [Flaw: Brittle Global State & Singletons (Hiba: T√∂r√©keny glob√°lis √°llapot √©s szingletonok |http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] ) k√©pezik e fejezet alapj√°t.*
