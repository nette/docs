Tokenizer: Tokenização de Cordas
********************************

.[perex]
O Tokenizer é uma ferramenta simples que utiliza expressões regulares para dividir um determinado fio em fichas. **Esta biblioteca não está mais sendo desenvolvida.**

Instalação:

```shell
composer require nette/tokenizer
```


Tokenização de Cordas .[#toc-string-tokenization]
-------------------------------------------------

Vamos criar um tokenizer simples que separa as cordas em números, espaços em branco e letras.

```php
$tokenizer = new Nette\Tokenizer\Tokenizer([
	T_DNUMBER => '\d+',
	T_WHITESPACE => '\s+',
	T_STRING => '\w+',
]);
```

Dica: Caso você esteja se perguntando de onde vêm as constantes T_, elas são "do tipo interno":https://www.php.net/manual/tokens.php usadas para analisar o código. Elas cobrem a maioria dos nomes simbólicos comuns que normalmente precisamos. Tenha em mente que seu valor não é garantido, portanto não use números para comparação.

Agora, quando lhe dermos um cordel, ele retornará um [fluxo |api:Nette\Tokenizer\Stream] de [fichas |api:Nette\Tokenizer\Token].

```php
$stream = $tokenizer->tokenize("say \n123");
```

O conjunto resultante de fichas `$stream->tokens` seria parecido com este.

```php
[
	new Token('say', T_STRING, 0),
	new Token(" \n", T_WHITESPACE, 3),
	new Token('123', T_DNUMBER, 5),
]
```

Além disso, você pode acessar as propriedades individuais do token:

```php
$firstToken = $stream->tokens[0];
$firstToken->value; // say
$firstToken->type; // value of T_STRING
$firstToken->offset; // position in string: 0
```

Simples, não é?


Processamento dos Tokens .[#toc-processing-the-tokens]
------------------------------------------------------

Agora sabemos como criar fichas a partir de um fio. Vamos processá-los efetivamente usando [o Stream |api:Nette\Tokenizer\Stream]. Tem muitos métodos realmente incríveis se você precisar atravessar os tokens!

Vamos tentar analisar uma simples anotação do PHPDoc e criar um objeto a partir dele. De que expressões regulares precisamos para os tokens? Todas as anotações começam com `@`, depois há um nome, espaço em branco e o seu valor.

- `@` para o início da anotação
- `\s+` para espaços em branco
- `\w+` para cordas

.[note]
Nunca utilize a captura de subpadrões nas expressões regulares do Tokenizer como `'(ab)+c'`, utilize apenas as não-capturantes `'(?:ab)+c'`.

Isto deve funcionar em anotações simples, certo? Agora vamos mostrar a seqüência de entradas que vamos tentar analisar.

```php
$input = '
	@author David Grudl
	@package Nette
';
```

Vamos criar uma classe `Parser` que aceitará a corda e retornará um conjunto de pares '['nome, valor |name, value]''. Será muito ingênuo e simples.

```php
use Nette\Tokenizer\Tokenizer;
use Nette\Tokenizer\Stream;

class Parser
{
	const T_AT = 1;
	const T_WHITESPACE = 2;
	const T_STRING = 3;

	private Tokenizer $tokenizer;
	private Stream $stream;

	public function __construct()
	{
		$this->tokenizer = new Tokenizer([
			self::T_AT => '@',
			self::T_WHITESPACE => '\s+',
			self::T_STRING => '\w+',
		]);
	}

	public function parse(string $input): array
	{
		$this->stream = $this->tokenizer->tokenize($input);

		$result = [];
		while ($this->stream->nextToken()) {
			if ($this->stream->isCurrent(self::T_AT)) {
				$result[] = $this->parseAnnotation();
			}
		}

		return $result;
	}

	private function parseAnnotation(): array
	{
		$name = $this->stream->joinUntil(self::T_WHITESPACE);
		$this->stream->nextUntil(self::T_STRING);
		$content = $this->stream->joinUntil(self::T_AT);

		return [$name, trim($content)];
	}
}
```

```php
$parser = new Parser;
$annotations = $parser->parse($input);
```

Então o que o método `parse()` faz? Itera sobre os tokens e procura `@` which is the symbol annotations start with. Calling `nextToken()` move o cursor para o próximo token. O método `isCurrent()` verifica se o token atual no cursor é o tipo dado. Então, se o método `@` is found, the `parse()` chama `parseAnnotation()` que espera que as anotações estejam em um formato muito específico.

Primeiro, usando o método `joinUntil()`, o fluxo continua movendo o cursor e anexando os valores dos tokens ao buffer até encontrar o token do tipo requerido, depois pára e retorna a saída do buffer. Como há apenas um token do tipo `T_STRING` naquela posição e é `'name'`, haverá o valor `'name'` na variável `$name`.

O método `nextUntil()` é semelhante ao `joinUntil()`, mas não tem tampão. Ele apenas move o cursor até encontrar a ficha. Portanto, esta chamada simplesmente salta todos os espaços em branco após o nome da anotação.

E depois, há outro `joinUntil()`, que busca o próximo `@`. This specific call will return `"David Grudl\n    "`.

E lá vamos nós, analisamos uma anotação inteira! O `$content` provavelmente termina com espaços em branco, então temos que apará-lo. Agora podemos devolver esta anotação específica como par `[$name, $content]`.

Tente copiar o código e executá-lo. Se você despejar a variável `$annotations`, ela deverá retornar alguma saída semelhante.

```
array (2)
   0 => array (2)
   |  0 => 'author'
   |  1 => 'David Grudl'
   1 => array (2)
   |  0 => 'package'
   |  1 => 'Nette'
```


Métodos de fluxo .[#toc-stream-methods]
---------------------------------------

O fluxo pode retornar o token de corrente usando o método `currentToken()` ou apenas o seu valor usando `currentValue()`.

`nextToken()` move o cursor e retorna a ficha. Se você não der argumentos, ele simplesmente devolve o próximo símbolo.

`nextValue()` é exatamente como `nextToken()`, mas só retorna o valor simbólico.

A maioria dos métodos também aceita múltiplos argumentos para que você possa procurar por vários tipos ao mesmo tempo.

```php
// iterate until a string or a whitespace is found, then return the following token
$token = $stream->nextToken(T_STRING, T_WHITESPACE);

// give me next token
$token = $stream->nextToken();
```

Você também pode pesquisar pelo valor simbólico.

```php
// move the cursor until you find token containing only '@', then stop and return it
$token = $stream->nextToken('@');
```

`nextUntil()` move o cursor e devolve o conjunto de todas as fichas que ele vê até encontrar a ficha desejada, mas ele pára antes da ficha. Ele pode aceitar múltiplos argumentos.

`joinUntil()` é semelhante a `nextUntil()`, mas concatena todos os tokens pelos quais passou e retorna cadeia.

`joinAll()` simplesmente concatena todos os valores simbólicos restantes e os devolve. Ele move o cursor para o final do fluxo de fichas

`nextAll()` é exatamente como `joinAll()`, mas devolve uma série de fichas.

`isCurrent()` verifica se a ficha atual ou o valor da ficha atual é igual a um dos argumentos dados.

```php
// is the current token '@' or type of T_AT?
$stream->isCurrent(T_AT, '@');
```

`isNext()` é exatamente como `isCurrent()`, mas verifica o próximo sinal.

`isPrev()` é exatamente como `isCurrent()`, mas verifica a ficha anterior.

E o último método `reset()` reinicializa o cursor, para que você possa iterar novamente o fluxo de fichas.


{{leftbar: utils:@left-menu}}
