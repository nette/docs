Forms in presenters
*******************

.[perex]
Nette Forms greatly facilitates the creation and processing of web forms in your applications. In this chapter, you will learn how to use forms inside presenters.

If you do not use presenters and Nette Application, there is a guide for you: [standalone forms|form-standalone].


First Form
==========

We will try to write a simple registration form. Its code will look like this:

```php
use Nette\Application\UI\Form;

$form = new Form;
$form->addText('name', 'Name:');
$form->addPassword('password', 'Password:');
$form->addSubmit('send', 'Sign up');
$form->onSuccess[] = [$this, 'formSucceeded'];
```

and in the browser the result should look like this:

[* form-en.png *]

We created a form with [fields|form fields] name, password and submit button. In presenters we always use the class `Nette\Application\UI\Form` for forms, its predecessor `Nette\Forms\Form` is intended for standalone use. Finally, the line with `$form->onSuccess` says that after sending and successful validation, the method `$this->formSucceeded()` will be called.

From the presenter's point of view, the form is a common component. Therefore, it is treated as a component and incorporated into the presenter using [factory method |components#Factory Methods]. It will look like this:

```php .{data-file:app/Presenters/HomepagePresenter.php}
use Nette;
use Nette\Application\UI\Form;

class HomepagePresenter extends Nette\Application\UI\Presenter
{
	protected function createComponentRegistrationForm(): Form
	{
		$form = new Form;
		$form->addText('name', 'Name:');
		$form->addPassword('password', 'Password:');
		$form->addSubmit('send', 'Sign up');
		$form->onSuccess[] = [$this, 'formSucceeded'];
		return $form;
	}

	public function formSucceeded(Form $form, $data): void
	{
		// here we will process the data sent by the form
		// $data->name contains name
		// $data->password contains password
		$this->flashMessage('You have successfully signed up.');
		$this->redirect('Homepage:');
	}
}
```

And render in template is done using `{control}` tag:

```html .{data-file:app/Presenters/templates/Homepage/default.latte}
<h1>Registration</h1>

{control registrationForm}
```

And that is all :-) We have a functional and perfectly [secured |#Vulnerability Protection] form.

Now you're probably thinking that it was too fast, wondering how it's possible that the method `formSucceeded()` is called and what the parameters it gets. Sure, you're right, this deserves an explanation.

Nette comes up with a cool mechanism, which we call [Hollywood style |components#Hollywood style]. Instead of having to constantly ask if something has happened ("was the form submitted?", "was it validly submitted?" or "was it not forged?"), you say to the framework "when the form is validly completed, call this method" and leave further work on it. If you program in JavaScript, you are familiar with this style of programming. You write functions that are called when a certain event occurs. And the language passes the appropriate parameters to them.

This is how the above presenter code is built. Array `$form->onSuccess` represents the list of PHP callbacks that Nette will call when the form is submitted and filled in correctly.
Within the [presenter's life cycle |presenters#Life Cycle of Presenter] it is a so-called signal, so they are called after the `action*` method and before the `render*` method.
And it passes to each callback the form itself in the first parameter and the sent data as object [ArrayHash |arrays#ArrayHash] in the second. The second parameter can be even more handy, but about that [later|#Mapping to Classes].

Variable `$data` contains keys `name` and `password` with data entered by the user. Usually we send the data directly for further processing, such as insertion into the database.

After processing the form, we will redirect to the next page. This prevents the form from being unintentionally resubmitted by clicking the Refresh, Back button, or moving the browser history.


Access to Fields
================

The form is a component of the presenter, in our case named `registrationForm` (after the name of the factory method `createComponentRegistrationForm`), so anywhere in the presenter you can get to the form using:

```php
$form = $this->getComponent('registrationForm');
// alternative syntax: $form = $this['registrationForm'];
```

Also individual form fields are components, so you can access them in the same way:

```php
$input = $form->getComponent('name'); // or $input = $form['name'];
$button = $form->getComponent('send'); // or $button = $form['send'];
```

Validation Rules
================

The word *valid* was used several times, but the form has no validation rules yet. Let's fix it.

The name will be mandatory, so we will mark it with the method `setRequired()`, whose optional argument is the text of the error message that will be displayed if the user does not fill it. If no argument is given, the default error message is used.

```php
$form->addText('name', 'Name:')
	->setRequired('Please fill your name.');
```

Try to submit the form without the name filled in and you will see that an error message is displayed and the browser or server will reject it until you fill it.

At the same time, you will not be able cheat the system by typing only spaces in the input, for example. No way. Nette automatically trims left and right whitespace. Try it. It's something you should always do with every single-line input, but it's often forgotten. Nette does it automatically.

The form is always validated on the server side, but it also generates JavaScript validation on the browser side, which is quick and the user knows of the error immediately, without having to send the form to the server. This is handled by the script `netteForms.js`.
If you are based on *nette/sandbox*, you already have it linked in the page layout. Otherwise, add it to the page:

```html
<script src="https://nette.github.io/resources/js/3/netteForms.min.js"></script>
```

If you look in the source code of the page, you may notice that Nette inserts the required fields into an element with a CSS class `required`. Try adding the following style to the template, and the "Name" label will be red. Elegantly, we mark the required fields for the user:

```html
<style>
.required label { color: maroon }
</style>
```

Additional validation rules will be added by method `addRule()`. The first parameter is [rule |form-validation#rules], the second is again the text of the error message, and the optional validation rule argument can follow.

The form will get another optional input *age* with the condition, that it has to be a number (`addInteger()`) and in certain boundaries (`$form::RANGE`). This time we will utilize a third argument of `addRule()`, the range itself:

```php
$form->addInteger('age', 'Age:')
	->addRule($form::RANGE, 'You must be older 18 years and be under 120.', [18, 120]);
```

.[tip]
If the user does not fill in the field, the validation rules will not be verified, because the field is optional.

Obviously room for a small refactoring is available. In the error message and in the third parameter, the numbers are listed in duplicate, which is not ideal. If we were creating a [multilingual form|translations] and the message containing numbers would have to be translated into multiple languages, it would make it more difficult to change values. For this reason, substitute characters `%d` can be used:

```php
	->addRule($form::RANGE, 'You must be older %d years and be under %d.', [18, 120]);
```

Let's return to the *password* field, make it *required*, and verify the minimum password length (`$form::MIN_LENGTH`), again using the substitute characters in the message:

```php
$form->addPassword('password', 'Password:')
	->setRequired('Pick a password')
	->addRule($form::MIN_LENGTH, 'Your password has to be at least %d long', 8);
```

We will add a field `passwordVerify` to the form, where the user enters the password again, for checking. Using validation rules, we check whether both passwords are the same (`$form::EQUAL`). Notice the dynamic references to the first password using [square brackets |#Access to Fields]:

```php
$form->addPassword('passwordVerify', 'Password again:')
	->setRequired('Fill your password again to check for typo')
	->addRule($form::EQUAL, 'Password mismatch', $form['password'])
	->setOmitted(); // after validation the data is discarded and not passed to $data
```

We have a fully functional form that has the same validation on the browser and server side. It automatically treats whether an attacker does not send invalid UTF-8 strings, etc., does not spoof a form from another domain, etc. You just don't have to think about these things, Nette does them for you.

Try adding more [form fields|form-fields]. You can also find inspiration in the distribution in the [examples |https://github.com/nette/forms/tree/master/examples] directory.


Default Values
==============

We set the default values to form fields, for example, when the form is used to edit database records. We read it from the database and pass it to the form as an array of default values:

```php
$items = [
	'name' => 'John',
	'age' => '33'
];
$form->setDefaults($items);
```

Call `setDefaults()` after defining the fields.

The `setDefaultValue()` method can be used to set the default value for individual fields:

```php
$form->addEmail('email', 'Email')
	->setDefaultValue('user@example.com');
```


Rendering the Form
==================

By default, the form is rendered as a table. The individual fields follows basic web accessibility guidelines. All labels are generated as `<label>` elements and are associated with their inputs, clicking on the label moves the cursor on the input.

We can set any HTML attributes for each element. For example, add a placeholder:

```php
$form->addInteger('age', 'Age:')
	->setHtmlAttribute('placeholder', 'Please fill in the age');
```

There are really a lot of ways to render a form, so it's dedicated [chapter about rendering|form-rendering].


Mapping to Classes
==================

Let's return to the method `formSucceeded()`, which as the second parameter gets sent `$data` as object `ArrayHash`. Of course, since it's a generic object, something like `stdClass`, code hinting or [static code analysis |editors-and-tools#PHPStan] won't work for us.
Therefore, it would be more handy to create a class for each form, with properties represent individual fields. E.g.:

```php
class RegistrationFormData
{
	/** @var string */
	public $name;
	/** @var int */
	public $age;
	/** @var string */
	public $password;
}
```

Now all we have to do is specify this class as typehint for `$data` and lo and behold, Nette will create and pass this object to us:

```php
public function formSucceeded(Form $form, RegistrationFormData $data): void
{
	$name = $data->name;
	...
```

Conversely, if you would prefer to obtain the data as an array, specify type hint `array`.


Multiple Submit Buttons
=======================

If the form has more than one button, we usually need to distinguish which one was pressed. One option is to create multiple handlers, a different one for each button. We attach them for event `onClick` for buttons:

```php
$form->addSubmit('save', 'Save')
	->onClick[] = [$this, 'saveButtonPressed'];

$form->addSubmit('delete', 'Delete')
	->onClick[] = [$this, 'deleteButtonPressed'];
```

These handlers are also called only in the case form is valid and before the handlers for the event `onSuccess`. The difference is that the first parameter is not the form, but the submit button:

```php
public function saveButtonPressed(Nette\Forms\Controls\Button $button, $data)
{
	$form = $button->getForm();
	...
```

When the form is submitted with the *enter* key, the first button is considered as submitting.



Vulnerability Protection
========================

Nette Framework puts a great effort to be safe and since forms are the most common user input, Nette forms are as good as impenetrable. All is maintained dynamically and transparently, nothing has to be set manually. Well-known vulnerabilities such as [Cross-Site Scripting (XSS) |vulnerability-protection#cross-site-scripting-xss] and [Cross-Site Request Forgery (CSRF)|vulnerability-protection#cross-site-request-forgery-csrf] are filtered, as well as special control characters. All inputs are checked for UTF-8 validity. Every multiple-choice, select box and similar are checked for forged values upon validating.

A CSRF attack is that an attacker lures the victim to visit a page that silently executes a request in the victim's browser to the server where the victim is currently logged in, and the server believes that the request was made by the victim at will. Therefore, Nette prevents the form from being submitted from another domain. If for some reason you want to turn off protection and allow the form to be submitted from another domain, use:

```php
$form->disableSameSiteProtection(); // ATTENTION! Turns off protection!
```


Using One Form in Multiple Presenters
=====================================

If you need to use one form in more than one presenter, we recommend that you create a factory for it, which you then pass on to the presenter. A suitable location for such a class is, for example, the directory `app/Forms`.

Our factory class will look like this:

```php
use Nette\Application\UI\Form;

class SignInFormFactory
{
	public function create(): Form
	{
		$form = new Form;
		$form->addText('name', 'Name:');
		$form->addSubmit('send', 'Log in');
		return $form;
	}
}
```

In the factory method for component in presenter that use our form, we create it by calling the method `create()`:

```php
protected function createComponentSignInForm(): Form
{
	$form = (new SignInFormFactory)->create();
	$form['login']->caption = 'Continue'; // we can also modify our form
	$form->onSuccess[] = [$this, 'signInFormSubmitted']; // and add handler
	return $form;
}
```

Of course, form processing can already be part of the factory:

```php
use Nette\Application\UI\Form;

class SignInFormFactory
{
	public function create(): Form
	{
		$form = new Form;
		$form->addText('name', 'Name:');
		$form->addSubmit('send', 'Log in');
		$form->onSuccess[] = function (Form $form, $data): void {
			// we process our submitted form here
		};
		return $form;
	}
}
```


{{composer: nette/forms}}
