Генерирани фабрики
******************

.[perex]
Nette DI може автоматично да генерира фабричен код въз основа на интерфейса, като ви спестява писането на код.

Фабриката е клас, който създава и конфигурира обекти. Затова той предава тях и техните зависимости. Във [въведението |introduction#Factory] показахме как изглежда една такава фабрика:

```php
class ArticleFactory
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

Всичко, което трябва да направите, е да създадете интерфейс и Nette DI ще генерира неговата реализация. Интерфейсът трябва да има точно един метод с име `create` и да декларира тип на връщане:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

И така, фабриката `ArticleFactory` има метод `create`, който създава обекти `Article`. Един клас `Article` може да изглежда по следния начин, например

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}
}
```

Добавете фабриката към конфигурационния файл:

```neon
services:
	- ArticleFactory
```

Nette DI ще създаде подходяща фабрична реализация.

По този начин в кода, използващ фабриката, правим запитване към обекта по интерфейс, а Nette DI използва генерираната имплементация:

```php
class UserController
{
	public function __construct(
		private ArticleFactory $articleFactory,
	) {
	}

	public function foo()
	{
		// нека фабриката създаде обект
		$article = $this->articleFactory->create();
	}
}
```


Параметризирана фабрика .[#toc-parameterized-factory]
=====================================================

Фабричният метод `create` може да приема параметри, които след това предава на конструктора. Например нека добавим идентификатор на автор на статия към класа `Article`:

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
		private int $authorId,
	) {
	}
}
```

Ще добавим и параметър към фабриката:

```php
interface ArticleFactory
{
	function create(int $authorId): Article;
}
```

Тъй като параметърът в конструктора и параметърът във фабриката имат едно и също име, Nette DI ще ги предаде автоматично.


Разширено определение .[#toc-advanced-definition]
=================================================

Дефиницията може да бъде записана и в многоредова форма с помощта на клавиша `implement`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
```

Когато е написан по този удължен начин, е възможно да се предоставят допълнителни аргументи за конструктора в ключа `arguments` и допълнителна конфигурация с `setup`, точно както при нормалните услуги.

Пример: Ако методът `create()` не приема параметъра `$authorId`, бихме могли да посочим фиксирана стойност в конфигурацията, която ще бъде предадена на конструктора `Article`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
		arguments:
			authorId: 123
```

Или обратното, ако `create()` приеме параметъра `$authorId`, но той не е част от конструктора и е предаден на метода `Article::setAuthorId()`, ще го посочим в раздела `setup`:

```neon
services:
	articleFactory:
		implement: ArticleFactory
		setup:
			- setAuthorId($authorId)
```


Accessor .[#toc-accessor]
=========================

В допълнение към фабриките Nette може да генерира и така наречените аксесори. Това са обекти с метода `get()`, който връща конкретна услуга от DI-контейнера. Многократните извиквания на `get()` все още връщат една и съща инстанция.

Този аксесоар осигурява лениво зареждане на зависимостите. Да предположим, че имаме клас, който записва грешки в специална база данни. Ако този клас предаде на конструктора връзка към база данни като зависимост, тя винаги ще трябва да бъде създадена, въпреки че на практика много рядко ще възникне грешка и затова връзката обикновено ще остане неизползвана.
Вместо това класът предава метод за достъп и само когато той бъде извикан `get()`, се създава обект на базата данни:

Как да създадем аксесоар? Просто напишете интерфейс и Nette DI ще генерира реализация. Интерфейсът трябва да има точно един метод с име `get` и да декларира тип на връщане:

```php
interface PDOAccessor
{
	function get(): PDO;
}
```

Ще добавим аксесоара към конфигурационния файл, който съдържа и дефиниция на услугата, която той ще връща:

```neon
services:
	- PDOAccessor
	- PDO(%dsn%, %user%, %password%)
```

Тъй като методът за достъп връща услугата `PDO`, а в конфигурацията има само една такава услуга, той ще я върне. Ако има повече услуги от този тип, определяме върнатата услуга с име, например `- PDOAccessor(@db1)`.


Множество фабрики/оценители .[#toc-multifactory-accessor]
=========================================================

Досега нашите фабрики и аксесори винаги можеха да произвеждат или връщат само един обект. Въпреки това е много лесно да се създадат множество фабрики в комбинация с аксесори. Интерфейсът на такъв клас ще съдържа произволен брой методи, наречени `create<name>()` и `get<name>()`, напр:

```php
interface MultiFactory
{
	function createArticle(): Article;
	function createFoo(): Model\Foo;
	function getDb(): PDO;
}
```

Така че вместо да предадем няколко генерирани фабрики и аксесори, ще предадем друга сложна фабрика, която може да прави повече.

Алтернативно, вместо няколко метода, можем да използваме параметрите `create()` и `get()`:

```php
interface MultiFactoryAlt
{
	function create($name);
	function get($name): PDO;
}
```

Тогава `MultiFactory::createArticle()` прави същото като `MultiFactoryAlt::create('article')`. Алтернативният запис обаче има недостатъка, че не е ясно кои стойности поддържа `$name` и не е логически възможно да се разграничат различните стойности на връщане за различните `$name` в интерфейса.


Определение за списък .[#toc-definition-with-a-list]
----------------------------------------------------

И как да дефинираме множество фабрики в конфигурацията? Ще създадем три услуги за създаване/извличане и след това самата фабрика:

```neon
services:
	article: Article
	- Model\Foo
	- PDO(%dsn%, %user%, %password%)
	- MultiFactory(
		article: @article  # createArticle()
		foo: @Model\Foo    # createFoo()
		db: @\PDO          # getDb()
	)
```


Дефиниции с помощта на етикети .[#toc-definition-with-tags]
-----------------------------------------------------------

Вторият вариант е да използвате [тагове за |services#Tags] дефиниции:

```neon
services:
	- App\Router\RouterFactory::createRouter
	- App\Model\DatabaseAccessor(
		db1: @database.db1.context
	)
```
