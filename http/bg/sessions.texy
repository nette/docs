Сесии
*****

<div class=perex>

HTTP е протокол без статични данни, но почти всяко приложение трябва да съхранява състояние между заявките, напр. съдържанието на количка за пазаруване. Именно за това е сесията. Нека разгледаме

- как да използвате сесиите
- как да избегнете конфликти на имена
- как да зададете дата на изтичане на срока на валидност

</div>

Когато се използват сесии, на всеки потребител се дава уникален идентификатор, наречен идентификатор на сесия, който се предава на "бисквитката". Той служи като ключ към данните за сесията. За разлика от "бисквитките", които се съхраняват от страна на браузъра, данните за сесията се съхраняват от страна на сървъра.

Настройваме сесията в [конфигурацията |configuration#Session], като изборът на време на изтичане е важен.

Сесията се управлява от обекта [api:Nette\Http\Session], който получавате, като го предавате чрез [инжектиране на зависимости |dependency-injection:passing-dependencies]. В презентаторите наричаме `$session = $this->getSession()`.

→ [Монтаж и изисквания |@home#Installation]


Стартираща сесия .[#toc-starting-session]
=========================================

По подразбиране Nette автоматично стартира сесия в момента, в който започнем да четем от нея или да записваме данни в нея. За да стартирате сесия ръчно, използвайте `$session->start()`.

PHP изпраща HTTP хедъри, които влияят на кеширането, когато сесията започне, вж. [php:session_cache_limiter] и евентуално бисквитка с идентификатор на сесията. Затова винаги трябва да стартирате сесията, преди да изпратите какъвто и да е изход към браузъра, в противен случай ще бъде хвърлено изключение. Затова, ако знаете, че сесията ще се използва по време на визуализирането на страницата, стартирайте я ръчно, например в презентатора.

В режим за разработчици Tracy стартира сесията, тъй като я използва за показване на ленти за пренасочване и AJAX заявки в панела Tracy.


Раздел .[#toc-section]
======================

В чистия език PHP съхранението на данни за сесията се реализира като масив, достъпен чрез глобалната променлива `$_SESSION`. Проблемът се състои в това, че приложенията обикновено се състоят от няколко независими части и ако всички разполагат само с един и същ масив, рано или късно ще се стигне до колизии на имена.

Рамката на Nette решава този проблем, като разделя цялото пространство на секции (обекти [api:Nette\Http\SessionSection]). В този случай всяка част използва свой собствен раздел с уникално име и не се получават колизии.

Получаваме дяла от мениджъра на сесии:

```php
$section = $session->getSection('unique name');
```

Всичко, което трябва да направите в презентатора, е да извикате `getSession()` с параметъра:

```php
// $this - Presenter
$section = $this->getSession('unique name');
```

Съществуването на дяла може да се провери по метода `$session->hasSection('unique name')`.

Самият дял е много лесен за работа с помощта на методите `set()`, `get()` и `remove()`:

```php
// запись переменной
$section->set('userName', 'franta');

// чтение переменной, возвращает null, если она не существует
echo $section->get('userName');

// удаление переменной
$section->remove('userName');
```

Можете да използвате цикъла `foreach`, за да извлечете всички променливи от секцията:

```php
foreach ($section as $key => $val) {
	echo "$key = $val";
}
```


Как да зададете дата на изтичане .[#toc-how-to-set-expiration]
--------------------------------------------------------------

Срокът на валидност може да бъде зададен за отделни раздели или дори за отделни променливи. Можем да позволим на потребителския вход да изтече след 20 минути, но да запазим съдържанието на кошницата.

```php
// срок действия раздела истекает через 20 минут
$section->setExpiration('20 minutes');
```

Третият параметър на метода `set()` се използва за задаване на датата на изтичане на срока на валидност на отделните променливи:

```php
// переменная 'flash' истекает через 30 секунд
$section->set('flash', $message, '30 seconds');
```

.[note]
Не забравяйте, че времето на изтичане на цялата сесия (вж. [Конфигурация на сесията |configuration#Session]) трябва да е равно или по-голямо от времето, зададено за отделните секции или променливи.

Отмяна на предварително зададено време на изтичане може да се осъществи чрез метода `removeExpiration()`. Незабавното изтриване на цял раздел се осигурява от метода `remove()`.


Събития $onStart, $onBeforeWrite .[#toc-events-onstart-onbeforewrite]
---------------------------------------------------------------------

Обектът `Nette\Http\Session` има [събития |nette:glossary#Events] `$onStart` и `$onBeforeWrite`, така че можете да добавите обратни извиквания, които ще бъдат извикани след стартирането на сесията или преди тя да бъде записана на диска и след това завършена.

```php
$session->onBeforeWrite[] = function () {
	// записываем данные в сессию
	$this->section->set('basket', $this->basket);
};
```


Управление на сесиите .[#toc-session-management]
================================================

Преглед на методите на класа `Nette\Http\Session` за управление на сесии:<div class=wiki-methods-brief>


start(): void .[method]
-----------------------
Стартира сесията.


isStarted(): bool .[method]
---------------------------
Работи ли сесията?


close(): void .[method]
-----------------------
Приключва сесията. Сесията приключва автоматично в края на скрипта.


destroy(): void .[method]
-------------------------
Приключва и изтрива сесията.


exists(): bool .[method]
------------------------
Съдържа ли HTTP заявката "бисквитка" с идентификатор на сесията?


regenerateId(): void .[method]
------------------------------
Генерира нов случаен идентификатор на сесия. Данните остават непроменени.


getId(): string .[method]
-------------------------
Връща идентификатора на сесията.

</div>


Конфигурация .[#toc-configuration]
----------------------------------

Конфигурираме сесията в [конфигурацията |configuration#Session]. Ако пишете приложение, което не използва DI-контейнер, използвайте тези методи, за да го конфигурирате. Те трябва да бъдат извикани преди стартирането на сесията.<div class=wiki-methods-brief>


setName(string $name): static .[method]
---------------------------------------
Задава името на "бисквитката", използвана за предаване на идентификатора на сесията. Името по подразбиране е `PHPSESSID`. Това е полезно, ако използвате няколко различни приложения в един и същи сайт.


getName(): string .[method]
---------------------------
Връща името на "бисквитката" на сесията.


setOptions(array $options): static .[method]
--------------------------------------------
Конфигурира сесията. Могат да се задават всички [директиви на |https://www.php.net/manual/en/session.configuration.php] PHP [сесията |https://www.php.net/manual/en/session.configuration.php] (във формат camelCase, напр. запишете `savePath` вместо `session.save_path`), както и [readAndClose |https://www.php.net/manual/en/function.session-start.php#refsect1-function.session-start-parameters].


setExpiration(?string $time): static .[method]
----------------------------------------------
Задава времето за неактивност, след което сесията се затваря.


setCookieParameters(string $path, string $domain=null, bool $secure=null, string $samesite=null): static .[method]
------------------------------------------------------------------------------------------------------------------
Задава параметрите за бисквитките. Настройките по подразбиране могат да бъдат променени в раздела за [конфигурация |configuration#Session-Cookie].


setSavePath(string $path): static .[method]
-------------------------------------------
Задава директорията, в която се съхраняват файловете на сесиите.


setHandler(\SessionHandlerInterface $handler): static .[method]
---------------------------------------------------------------
Задава персонализирания манипулатор, вижте [документацията на PHP |https://www.php.net/manual/en/class.sessionhandlerinterface.php].

</div>


Сигурността на първо място .[#toc-safety-first]
===============================================

Сървърът приема, че комуникира с един и същ потребител, докато заявките съдържат един и същ идентификатор на сесията. Предизвикателството пред механизмите за сигурност е да се гарантира, че това поведение действително работи и че няма начин да се подмени или открадне идентификаторът.

Ето защо Nette Framework правилно конфигурира директивите на PHP да предават идентификаторите на сесията само на бисквитките, да предотвратяват достъпа от JavaScript и да игнорират идентификаторите в URL адресите. Освен това в критични моменти, като например влизане на потребител, той генерира нов идентификатор на сесията.

Функцията ini_set се използва за конфигуриране на PHP, но за съжаление някои уеб хостове не я разрешават. Ако вашият случай е такъв, опитайте се да помолите доставчика си на хостинг да разреши тази функция или поне да конфигурира правилно своя сървър. .[note]
