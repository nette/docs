Dependency Injection
********************

/--div .[perex]
Podstatou Dependency Injection (DI) je odebrat třídám zodpovědnost za získávání objektů, které potřebují ke své činnosti (tzv. služeb) a místo toho jim služby předávat při vytváření. Řekneme si:

- co je principem Dependency Injection?
- jak vytvářet dynamické a statické DI kontejnery
- jak na lazy loading služeb
\--


Co je to Dependency Injection?
==============================

Narovinu: Dependency Injection (DI) není nic tajemného nebo nepochopitelného. Celé se dá shrnout do jedné sobecké věty: **„nic nesháněj, ať se postará někdo jiný.“** Nic víc, nic míň. Převeďme to do řeči programátorů. Máme třídu `Article` reprezentující článek na blogu:

/--php
class Article
{
	public $id;
	public $title;
	public $content;

	function save()
	{
		// uložíme do databáze
	}

}
\--

a použití bude následující:

/--php
$article = new Article;
$article->title = '10 Things You Need to Know About Losing Weight';
$article->content = 'Every year millions of people in ...';
$article->save();
\--

Metoda `save()` nám uloží článek do databázové tabulky `articles`. Implementovat ji za pomoci [Nette\Database |database] bude hračka, nebýt jedno zádrhelu: kde má objekt `Article` vzít připojení k databázi, tj. objekt Connection?

Nejspíš bychom si poradili, můžeme jej uložit někde do globální proměnné `$GLOBALS['connection']`. Říkali vám, že používání globálních proměnných je špatné a že máte raději používat statické proměnné tříd? No měli pravdu, globální proměnné jsou zlo, jenže statické proměnné tříd jsou zcela totéž. To je jako říci: „Nejezte hamburgery, tloustne se po nich, dejte si raději cheeseburger.“

Kde tedy seženeme připojení k databázi? DI má odpověď: „nic nesháněj, ať se postará někdo jiný.“ Jinými slovy, pokud potřebuji databázi, ať mi ji někdo dodá, já to řešit nehodlám. Cha, to je vychytralé, milé DI! Tak do toho:

/--php
class Article
{
	public $id;
	public $title;
	public $content;
	private $connection;

	function __construct(Nette\Database\Connection $connection)
	{
		$this->connection = $connection;
	}

	function save()
	{
		$this->connection->table('articles')->insert(array(
			'title' => $this->title,
			'content' => $this->content,
		);
	}

}
\--

Použití třídy `Article` se pochopitelně trošku změní:

/--php
$article = new Article($connection);
$article->title = ...
$article->content = ...
$article->save();
\--

Ptáte se, kde tento kód vezme `$connection`? DI dává jasnou odpověď: „ať se postará někdo jiný“. Databázové spojení zkrátka dodá ten, kdo volá uvedený kód. A tak dále, a tak dále. Jistě si říkáte, že přece nelze delegovat zodpovědnost do nekonečna. Že musí být nějaký počátek všehomíra. A máte pravdu. Úplně na začátku je *stvořitel*, který už nic nedeleguje a objekty tvoří. Říká se mu **systémový kontejner.** A je mu věnovaná [jedna celá kapitola |configuring].


Proč jsou globální proměnné zlo?
--------------------------------

Dobrá otázka. Zvídavému programátorovi nestačí si přečíst, že to či ono je zlo, chce znát důvod. Třída `Article` tak jako tak databázové připojení potřebuje. Jenže z prvního příkladu užití není vůbec patrné, odkud a jak ho získá. Uživatel takové kódu může být až překvapen, že se vůbec článek uloží, a ptá se „kam se vlastně uložil?“ Naopak v druhém příkladu používajícím DI je kód samovysvětlující.

Představte si, že zkoumáte nějakou knihovnu pro platební brány a napíšete si příklad:

/--php
$cc = new CreditCard('4461510140804839', 12, 2013);
$cc->pay(1000, CreditCard::DOLLARS);
\--

Kód spustíte, s číslem své karty, a po nějaké době zjistíte, že vám to skutečně z účtu strhlo peníze! Šokovaný zíráte na výpis a lamentujete: „kde jsou mé peníze, jak je to mohlo strhnout, vždyť jsem to s žádnou platební bránou nepropojil!“ Třída `CreditCard` se s ní propojila nějak sama, získala ji odněkud z globální proměnné, podobně tajemně, jako si původní `Article` získal připojení k databázi. Takovou věc z kódu nejen že nevydedukujete, ale ani nevíte, jak změnit platební bránu na jinou, třeba testovací.


DI znamená víc psaní
--------------------

Můžete namítnout, že používání DI znamená víc psaní, že kvůli vytvoření instance `Article` musíte uchovávat a předávat databázové spojení a podobně. To je pravda, nicméně nezapomeňte, že posledně vás „méně psaní“ připravilo o $1000! Ne, nechceme to zlehčovat. Připomínka je zcela korektní a my ještě přidáme jednu závažnější: časem může ve třídě `Article` vzniknout potřeba nějaká data cachovat a v souladu s DI bude požadovat předání ještě objektu představujícího úložiště cache. To by znamenalo upravit aplikaci na mnoha místech: přinejmenším všude, kde se vytváří instance `Article`.

Co s tím? Věc má řešení. Místo ručního vytváření objektů `Article` si vytvoříme továrničku, tedy funkci, která bude objekty `Article` vyrábět. Když `Article` změní konstruktor, upraví se jen továrnička, nic víc. A odkud onu továrničku v našem kódu získáme? Vždyť víte… o to ať se postará někdo jiný :-)


DI kontejner a služby
---------------------

Termínem DI kontejner označujeme právě onu továrničky. Přesněji řečeno, jde o objekt obsahující libovolné množství továrniček, každou pro jinou službu. Co jsou to služby? Obyčejné objekty, jako třeba zmíněný `Article`. Jen v souvislosti s DI kontejnery jim říkáme služby. Zřejmě to vymysleli konzultanti, kteří chtějí, aby DI vypadalo složitě a oni mohli konzultovat.

Příkladem může být kontejner, který vytvoří `Article`, ale také jím požadované připojení k databázi:

/--php
class Container
{
	function createConnection()
	{
		return new Nette\Database\Connection(
			'mysql:host=localhost', 'root', '***'
		);
	}

	function createArticle()
	{
	    return new Article($this->createConnection());
	}

}
\--

Použití by vypadalo následovně:

/--php
$container = new Container;
$article = $container->createArticle();
\--

Výhoda je zřejmá, nemusíme se starat o to, jak `Article` vyrobit, to je záležitostí továrničky. Nicméně řešení má dva problémy. Nejprve: přihlašovací údaje jsou natvrdo zadrátované do kódu, proto je vyčleníme:

/--php
class Container
{
	public $params = array();

	function createConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	function createArticle()
	{
		$class = $this->params['article.class'];
		return new $class($this->createConnection());
	}

}

$container = new Container;
$container->params = array(
	'dsn' => 'mysql:host=localhost'
	'user' => 'root',
	'password' => '***',
	'article.class' => 'Article',
);
$article = $container->createArticle();
\--

Daleko větším problémem je, že vždy, když požádáme o vytvoření `Article`, vytvoří se i nové připojení k databázi. Tomu je třeba zabránit. Jednou vytvořenou službu `Connection` si proto uložíme do proměnné pro příští použití:

/--php
class Container
{
	public $params = array();

	private $services = array();

	function createConnection()
	{
		if (isset($this->services['connection'])) {
			return $this->services['connection']);
		}

		return $this->services['connection'] = new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	...
}
\--

Vidíte, že DI kontejner není nic složitého.

*TODO*



Nette\DI\Container
==================

Třída [Nette\DI\Container |api:] je pružná implementace DI kontejneru. Vlastní kontejnery můžeme vytvářet buď staticky, tj. poděděním této třídy, nebo dynamicky, kdy továrničky přidáme pomocí closures nebo callbacků.

Jednotlivé services jsou sdílené, tj. vytváří se jen jednou.


Statický kontejner
------------------

Všimněte si, že kontejner nabízí pole $params pro uživatelské parametry a také "magické settery/gettery" jakožto zkratky pro addService, getService, hasService a removeService

/--php
class MyContainer extends Nette\DI\Container
{

	protected function createServiceConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	protected function createServiceArticle()
	{
		$class = $this->params['article.class'];
		return new $class($this->getService('connection'));
	}

}

$container = new MyContainer;
$container->params = array(
	'dsn' => 'mysql:host=localhost'
	'user' => 'root',
	'password' => '***',
	'article.class' => 'Article',
);

$article = $container->article;
\--

Všechny služby v rámci kontejneru jsou trvalé, tj. při volání getService() (či získání přes proměnou) se nevytváří služba opakovaně, ale vrací se již dříve vytvořená. Jakékoliv jiné chování by bylo leda matoucí. V uvedeném příkladu by se ale hodilo, kdyby kontejner pokaždé vygeneroval nový objekt `Nette\Mail\Article`. Toho lze dosáhnout snadno: namísto služby `article` vytvoříme obyčejnou metodu `createArticle`:

/--php
class MyContainer extends Nette\DI\Container
{

	function createServiceConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	function createArticle()
	{
		$class = $this->params['article.class'];
		return new $class($this->getService('connection'));
	}

}

$container = new MyContainer;
$container->params = array(
	'dsn' => 'mysql:host=localhost'
	'user' => 'root',
	'password' => '***',
	'article.class' => 'Article',
);

$article = $container->createArticle();
\--

Z kódu `$xyz = $container->createXyz()` je zřejmé, že se vytváří pokaždé nový objekt. Jde tedy o konvenci na straně programátora.

Kontejner je možné zmrazit a poté ho již nelze měnit:

/--php
$container->freeze();
$container->addService(...); // vyhodí výjimku
\--

Rozmrazíme jej vytvořením klonu, viz níže.


Dynamický kontejner
-------------------

/--php
$container = new Nette\DI\Container;

$container->addService('connection', function($container) {
	return new Nette\Database\Connection(
		$container->params['dsn'],
		$container->params['user'],
		$container->params['password']
	);
});

$container->addService('article', function($container) {
	$class = $container->params['article.class'];
	return new $class($container->connection);
});

// nastavíme parametry
$container->params = array(
	'dsn' => 'mysql:host=localhost'
	'user' => 'root',
	'password' => '***',
	'article.class' => 'Article',
);

// a nyní kontejner použijeme pro vytvoření objektu emailu:
$article = $container->article; // zkratka pro $container->getService('article')
\--

Pokud místo callbacku předáme řetězec s názvem třídy, vytvoří se objekt ServiceBuilder, jehož úkolem je později třídu instancovat. Metoda addService onen builder vrací. Pokud bychom tedy vytvořili builder s metodami jako addArgument nebo addMethodCall, bylo by možné uvedený příklad zapsat třeba takto:

/--php
$container->addService('connection', new AnotherBuilder('Nette\Database\Connection'))
	->addArgument('%dsn%')
	->addArgument('%user%')
	->addArgument('%password%');

$container->addService('article', new AnotherBuilder('%article.class%'))
	->addArgument('@mailer');

$container->params = array(
	'dsn' => 'mysql:host=localhost'
	'user' => 'root',
	'password' => '***',
	'article.class' => 'Article',
);
\--

/--comment
Zdůrazňujeme, že AnotherBuilder v Nette přímo není, jeho kód by vypadal cca takto:

 /--php
class AnotherBuilder extends Nette\DI\ServiceBuilder
{
	private $args = array();
	private $calls = array();

	public function addArgument($arg)
	{
		$this->args[] = $arg;
		return $this;
	}

	public function addMethodCall($method)
	{
		$this->calls[] = func_get_args();
		return $this;
	}

	public function createService(Nette\DI\IContainer $container)
	{
		$class = $container->expand($this->class);
		try {
			$type = new Nette\Reflection\ClassType($class);
		} catch (\ReflectionException $e) {
			throw new Nette\InvalidStateException("Cannot instantiate service, class '$class' not found.");
		}

		$expander = function(& $val) use ($container) {
			$val = $val[0] === '@' ? $container->getService(substr($val, 1)) : $container->expand($val);
		};
		$args = $this->args;
		array_walk_recursive($args, $expander);
		$service = $type->newInstanceArgs($args);
		foreach ($this->calls as $call) {
			array_walk_recursive($call, $expander);
			call_user_func_array(array($service, array_shift($call)), $call);
		}
		return $service;
	}


}
 \--
\--


Aliasování
----------

Vytvářejte aliasy pro služby jen tehdy, je-li to skutečně nutné:

/--php
$container->addService('alias', $container->getService('originalName'));
\--

Pochopitelně tímto způsobem můžeme kopírovat služby mezi jednotlivými kontejnery.

Pokud chceme zachovat lazy-loading, tj. kopírovat služby, které zatím nejsou vytvořené, uděláme to následovně:

/--php
$container->addService('alias', function($container) {
	return $container->getService('originalName');
});
\--

Nebo mezi dvěma kontejnery:

/--php
$containerDest->addService('connection', function() use ($containerSrc) {
	return $containerSrc->getService('connection');
});
\--

Kontejner je také možné klonovat. Klon obsahuje všechny služby jako vzor a pochopitelně lze do něj přidávat nové.

/--php
$dolly = clone $container;
\--


Auto-wiring
-----------

Autowire je pokročilejší technika, umožňující při vytváření služby automaticky předávat do konstruktoru další služby dle typu. Vytvoříme si k tomu nový ServiceBuilder:

/--php
class AutowireServiceBuilder extends Nette\DI\ServiceBuilder
{

	public function createService(Nette\DI\IContainer $container)
	{
		try {
			$type = new Nette\Reflection\ClassType($this->class);
		} catch (\ReflectionException $e) {
			throw new Nette\InvalidStateException("Cannot instantiate service, class '$this->class' not found.");
		}
		$args = array();
		if ($type->hasMethod('__construct')) {
			foreach ($type->getMethod('__construct')->getParameters() as $param) {
				if ($param->isDefaultValueAvailable()) {
					$args[] = $param->getDefaultValue();
				} elseif ($param->getClass()) {
					$args[] = $container->getServiceByType($param->getClass()->getName());
				} else {
					$args[] = $param->isArray() && !$param->allowsNull() ? array() : NULL;
				}
			}
		}
		return $type->newInstanceArgs($args);
	}

}


// přidáme službu, která se sestaví auto-wiringem
$cont->addService('article', new AutowireServiceBuilder('Article'));
\--


Klíčem je metoda kontejneru `getServiceByType()`, která vrátí službu podle daného typu (třída, interface). Taková služba musí být v kontejneru právě jedna, jinak se vyhodí výjimka.

Pokud přidáváme službu pomocí továrny, není její typ pochopitelně znám. Můžeme ho proto "napovědět" třetím parametrem metody addService:

/--php
$cont->addService('connection', function($cont) { ... }, 'Nette\Database\Connection');
\--

K ověření typu služby slouží metoda checkServiceType():

/--php
if (!$cont->checkServiceType('connection', 'Nette\Database\Connection')) {
	...
}
\--


Tagování
--------

Při uložení jakéhokoliv objektu můžeme u něj uvést doplňující metainformace, tzv. tagy:

/--php
$container->addService('connection', ..., array('tag1', 'tag2'));
\--

A poté můžeme v kontejneru vyhledat všechny služby (resp. jejich jména), které mají daný tag:

/--php
$list = $container->getServiceNamesByTag('tag1')
\--

Tag nemusí být je řetězec, ale může obsahovat další libovolné atributy:

/--php
$container->addService('connection', ..., array(
	'tag1' => array('id' => 'mx', 'priority' => 12),
	'tag2' => array('...'),
));

$list = $container->getServiceNamesByTag('tag1')
// vrací pole array('connection' => array('id' => 'mx', 'priority' => 12))
\--
