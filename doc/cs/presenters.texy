MVC aplikace & presentery
*************************

/--div .[perex]
Seznámíme se s tím, jak se vlastně v Nette Framework tvoří aplikace. Po přečtení budete znát:

- MVC, adresářovou strukturu a soubor `bootstrap.php`
- co jsou to presentery a akce
- jak se používají šablony
- co jsou persistentní parametry
\--


Model-View-Controller (MVC)
===========================

Model-View-Controller je softwarová architektura, která vznikla z potřeby oddělit u aplikací s grafickým rozhraním kód obsluhy (controller) od kódu aplikační logiky (model) a od kódu zobrazujícího data (view). Tím jednak aplikaci zpřehledňuje, usnadňuje budoucí vývoj a umožňuje testování jednotlivých části zvlášť.

Model
-----

Model je datový a zejména funkční základ celé aplikace. Je v něm obsažena aplikační logika. Jakákoliv akce uživatele (přihlášení, vložení zboží do košíku, změna hodnoty v databázi) představuje akci modelu. Model si spravuje svůj vnitřní stav a ven nabízí pevně dané rozhraní. Voláním funkcí tohoto rozhraní můžeme zjišťovat či měnit jeho stav. Model o existenci view nebo controlleru neví.

.[note]
Pojem *Model* představuje celou vrstvu, nikoliv samostatnou třídu.


View
----

View, tedy pohled, je vrstva aplikace, která má na starost zobrazení výsledku požadavku. Obvykle používá šablonovací systém a ví, jak se má zobrazit ta která komponenta nebo výsledek získaný z modelu.


Controller
----------

Řadič, který zpracovává požadavky uživatele a na jejich základě pak volá patřičnou aplikační logiku (tj. model) a poté požádá view o vykreslení dat. Obdobou kontrolerů v Nette Framework jsou [presentery |glossary#presenter].



Adresářová struktura
====================

Když se po stažení distribuce Nette Framework podíváte do adresáře `sandbox`, uvidíte doporučovanou adresářovou strukturu:

/--pre
<b>sandbox/</b>
	<b>app/</b>                  ← adresář s aplikací
		<b>models/</b>           ← modelová vrstva a její třídy
		<b>presenters/</b>       ← třídy presenterů
			<b>HomepagePresenter.php</b>  ← třída presenteru Homepage

		<b>templates/</b>        ← adresář se šablonami
			<b>@layout.latte</b> ← šablona společného layoutu
			<b>Homepage/</b>     ← šablony presenteru Homepage
				<b>default.latte</b>  ← šablona akce default

		<b>config.neon</b>       ← konfigurační soubor aplikace
		<b>bootstrap.php</b>     ← zaváděcí soubor aplikace

	<b>libs/</b>                 ← adresář na knihovny (např. třetích stran)
		<b>Nette/</b>            ← oblíbený framework
		...

	<b>log/</b>                  ← obsahuje logy, error logy atd.
	<b>temp/</b>                 ← pro dočasné soubory, cache, ...
	<b>www/</b>                  ← veřejný adresář, document root projektu
		<b>.htaccess</b>         ← pravidla pro mod_rewrite
		<b>index.php</b>         ← který spouští aplikaci
		<b>images/</b>           ← další adresáře, třeba pro obrázky
\--

Krom toho se v některých složkách nacházejí soubory `.htaccess` resp. `web.config`, které zakazují přístup z prohlížeče (pro Apache resp. IIS). Ujistěte se, že to funguje a že se skutečně z prohlížeče do složky `app/` nebo `libs/` nedostanete.

.[note]
Adresářům `log/` a `temp/` nezapomeňte nastavit práva pro zápis (`chmod 0777`).


index.php & bootstrap.php
-------------------------

Všechny požadavky posílá prohlížeč přes jediný PHP soubor, který se ve veřejném adresáři `www/` nachází, a tím je soubor `index.php`. V jeho těle se neděja takřka nic. Definujeme zde pouze konstanty popisující adresářovou strukturu aplikace (`WWW_DIR`, `APP_DIR`, `LIBS_DIR` a `TEMP_DIR`) a předává řízení do aplikace (tj. do adresáře `app/`) zaváděcímu souboru `bootstrap.php`.

.[note]
Nette Framework používá jednotný řád pro cesty k adresářům, které se vždy zapisují a ukládají v proměnných bez pravostranného lomítka.

Výše uvedená adresářová struktura je tak skutečně jen doporučená, protože ji můžeme snadno jakkoliv změnit nebo složky přejmenovat a bude stačit pouze přenastavit konstanty v souboru `index.php`.

Soubor `bootstrap.php` nejprve načte Nette Framework:

/--php
use Nette\Diagnostics\Debugger;

require LIBS_DIR . '/Nette/loader.php';
\--

Aktivujeme [debugger a logger |debugging] ve striktním režimu:

/--php
Debugger::$strictMode = TRUE;
Debugger::enable();
\--

A vytvoříme tzv. [DI kontext |configuring] načtením konfiguračního souboru `config.neon`. Od něj se bude odvíjet všechno další.

/--php
$configurator = new Nette\Configurator;
$container = $configurator->loadConfig(__DIR__ . '/config.neon');
\--

Nastavíme pravidla pro [routování |routing], aby bylo možné překládat URL adresy na [akce presenterů |#zpracovani-akce-presenteru]. Uvedené pravidla mimojiné říká, že vychozí akcí presenteru bude `Homepage:default`.

/--php
$container->addService('router', function() {
	$router = new RouteList;
	$router[] = new Route('index.php', 'Homepage:default', Route::ONE_WAY);
	$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default');
	return $router;
});
\--

Nastavíme parametry aplikace, např. error-presenter, který se bude v produkčním prostředí starat o zobrazování hlášek při výskytu chyby:

/--php
$application = $container->application;
$application->errorPresenter = 'Error';
\--

Pokud bychom chtěli provést nějaké další úlohy, jako je třeba připojení k databázi, je vhodné to přidat do události `onStartup` aplikace: (pozn.: připojení k databázi je obecně lepší řešit pomocí [DI kontejneru |configuring]).

/--php
$application->onStartup[] = function() {
	... připojíme se k databázi ...
};
\--

A aplikaci spustíme:

/--php
$application->run();
\--

To je vše.


Moduly
------

U složitějších aplikací můžeme složky s presentery a šablonami rozčlenit do podadresářů, kterým říkáme moduly. Pokud by naše aplikace obsahovala například moduly `Front` a `Admin`, její struktura by mohla vypadat takto:

/--pre
<b>sandbox/</b>
	<b>app/</b>                ← adresář s aplikací
		<b>models/</b>         ← modelová vrstva a její třídy
		<b>AdminModule/</b>    ← modul Admin
			<b>presenters/</b> ← a jeho presentery
			<b>templates/</b>  ← a šablony

		<b>FrontModule/</b>    ← modul Front
			<b>presenters/</b> ← a jeho presentery
			<b>templates/</b>  ← a šablony

		<b>config.neon</b>    ← konfigurační soubor aplikace
		<b>bootstrap.php</b>  ← zaváděcí soubor aplikace
	...
\--


Moduly nemusí tvořit jen plochou strukturu, lze vytvářet i submoduly atd.




Zpracování akce presenteru
==========================

Nyní prosím zbystřete. Každý požadavek na naši aplikaci se dostane přes soubory `index.php` a `bootstap.php` do objektu `$application`. Ten ale HTTP požadavkům nerozumí, proto požádá [router |routing], aby mu ho přeložil do řeči, které rozumí. Tedy aby mu řekl, pro který **presenter** je požadavek určen a kterou **akci** s ním chce vykonat. Router kupříkladu odpoví, že uživatel chce akci `show` presenteru `Product` (je dobrý zvykem to zapisovat jako `Product:show`) a dále předává parametr `id = 123`. Česky by se řeklo: uživatele chce zobrazit produkt s id=123.

Tomu už `$application` rozumí a přistoupí k plnění přání. Vyrobí objekt třídy `ProductPresenter`, která reprezentuje presenter `Product`. (Abychom byli zcela přesní, o výrobu objektu presenteru požádá službu `presenterFactory`). A pak presenter požádá o provedení akce (`show` a parametrem `id`).

Presenter je objekt, který vezme požadavek přeložený routerem a vymyslí odpověď. Odpovědí může být HTML stránka, obrázek, XML dokument, soubor na disku, JSON, přesměrování nebo cokoliv vymyslíte. Konkrétně ProductPresenter požádá model o data a ty poté předá do šablony k vykreslení. Tohle se zpravidla odehraje v metodě `renderShow`, kde slovo `Show` odpovídá názvu akce a parametr požadavku `id` bude předán jako parametr této funkce:

/--php
class ProductPresenter extends Nette\Application\UI\Presenter
{
	function renderShow($id)
	{
		// získáme data z modelu a předáme do šablony
		$this->template->product = $this->model->getProduct($id);
	}
}
\--


Šablony
-------

Následně automaticky přistoupí presenter k vykreslení šablony. Cestu k souboru se šablonou odvodí podle jednoduché logiky. Pro presenter `Product` a akci `show` zkusí, zda existuje jeden z těchto souborů:

/--
- templates/Product/show.latte
- templates/Product.show.latte
- templates/Product/show.phtml
- templates/Product.show.phtml
\--

Taktéž se pokusí dohledat layout (ten je nepovinný):

/--
- templates/Product/@layout.latte
- templates/Product.@layout.latte
- templates/Product/@layout.phtml
- templates/Product.@layout.phtml
- templates/@layout.latte layout společný pro více presenterů
- templates/@layout.phtml layout společný pro více presenterů
\--

Presentery a jejich komponenty předávají do šablon několik užitečných proměnných automaticky:

- `$basePath` je absolutní URL cesta ke kořenovému adresáři (např. `/CD-collection`)
- `$baseUrl` je absolutní URL ke kořenovému adresáři (např. `http://localhost/CD-collection`)
- `$user` je objekt [reprezentující uživatele |security]
- `$presenter` je aktuální presenter
- `$control` je aktuální komponenta nebo presenter
- `$flashes` pole zpráv zaslaných funkcí `flashMessage()`

O vykreslování šablon podrobněji v [samostatné kapitole |templating].

Ono to vlastně není nic těžkého! Pokud požaduji akci například `Homepage:default`, tak se

1) vytvoří objekt třídy `HomepagePresenter`
2) zavolá se metoda `renderDefault()` (existuje-li, ale nemusí)
3) vykreslí se šablona např. `templates/Homepage/default.latte` s layoutem např. `templates/@layout.latte`

a v šabloně pak můžeme [vytvořit odkaz |#Vytváření odkazů] na zmíněný `Product:show($id)`, zhruba takto:

/--html
<a n:href="Product:show $productId">detail produktu</a>
\--

Nechci to zakřiknout, ale tvorba aplikací v Nette bude pohodička.

(Způsob dohledávání šablon můžeme změnit přepsáním metod [formatTemplateFiles |api:Nette\Application\UI\Presenter::formatTemplateFiles()] nebo [formatLayoutTemplateFiles |api:Nette\Application\UI\Presenter::formatLayoutTemplateFiles()]).


Moduly
------

U složitějších aplikací, které presentery rozčleňují do modulů, funguje vše velmi podobně. Opět dejme tomu, že  naše aplikace obsahuje modul `Front`, jehož součástí je presenter `Product`. Akce `show` se pak zapíše jako `Front:Product:show` a třída `ProductPresenter` se umístí do jmenného prostoru `FrontModule`:

/--php
namespace FrontModule;

class ProductPresenter extends Nette\Application\UI\Presenter
{
	...
\--



Vytváření odkazů
================

Vytvoření odkazů patří mezi nejsilnější místa Nette Frameworku. Ukážeme si:

Díky [obousměrnému routování | routing] není potřeba do šablon či kódu natvrdo zapisovat URL nebo je komplikovaně skládat. Stačí se odkazovat na akce presenterů, předávat jim parametry a framework už URL vygeneruje sám. Vytvořit odkaz je pak stejně snadné, jako zavolat funkci. To se vám bude tuze líbit!

Během programování a vytváření šablon nás nemusí zajímat tvar URL adres, budeme se totiž odkazovat přímo na akci presenteru, tj. například na již zmíněnou `Product:show`.


Odkazy v šablonách
------------------

Nejčastěji vytváříme odkazy v šablonách. Aby to bylo co nejjednodušší, nabízí nám framework hned tři makra. Nejšikovnější z jich je makro `n:href`

/--html
<a n:href="Product:show $productId">detail produktu</a>
\--

Všimněte si, že místo HTML atributu `href` jsme použili [n:makra |templating#n-makra] `n:href`. Jeho hodnotou pak není URL, jak by tomu bylo v případě atributu `href`, ale rovnou akce presenteru. Tam má tvar

/--
[Presenter:]action [,] [arg1] [, arg2] [, ...]
\--

Po kliknutí na odkaz se dostane ke slovu metoda `ProductPresenter::renderShow()` a jako parametr `$id` ji bude předána hodnota proměnné `$productId`. Parametrů bychom mohli předat i víc, stejně jako když voláme metodu. Šlo by to udělat snadněji?

.[note]
Je lepší dodržovat konvenci velkého písmenka pro název presenteru a malého pro akci. Jako oddělovat slouží právě jedna dvojtečka.

Kromě toho je možné předávat i pojmenované parametry. Následující odkaz předává parametr `lang` s hodnotou `cs`:

/--html
<a n:href="Product:show $productId, lang => cs">detail produktu</a>
\--

Ačkoliv metoda `renderShow` nemá `$lang` ve své hlavičce, může hodnotu parametru zjistit voláním `$lang = $this->getParam('lang')`.

Máme-li všechny parametry v poli, můžeme jej rozvinout operátorem `(expand)`:

/--html
{var $args = [$productId, lang => cs]}
<a n:href="Product:show (expand) $args">detail produktu</a>
\--

Pokud je šablona, ve které vytváříme odkaz, také součástí `Product` presenteru, můžeme název presenteru vynechat a psát přímo `n:href="show $productId"`. Nebo obráceně, vede-li odkaz na akci nazvanou `default`, lze tuto vynechat a napsat `n:href="Product: $id"` (nezapomeňte na dvojtečku).

Odkazy mohou také směřovat do jiných [modulů |#moduly]. Zde se rozlišuje, zda se odkazujeme "relativně" do zanořeného submodulu, nebo "absolutně" do jiného modulu - pak cesta začne dvojtečkou. Pro ukázku předpokládejme, že aktuální presenter je součástí modul `Front`, potom zapíšeme:

/--html
<a n:href="Shop:Product:show">odkaz na Front:Shop:Product:show</a>
<a n:href=":Admin:Product:show">odkaz na Admin:Product:show</a>
\--

Speciálním případem je odkaz na sebe sama, kdy jako cíl uvedeme `this`.

Vygenerovaný odkaz má podobu absolutní cesty, pokud chceme vygenerovat absolutní odkaz včetně domény např. `http://example.com`, přidáme na začátek dvě lomítka `n:href="//show $productId"`.

Odkazovat můžeme na určitou část na stránce přes tzv. fragment za znakem křížky `#`:

/--html
<a n:href="show#comments">odkaz na Product:show a fragment #comments</a>
\--

Makro `n:href` je velmi šikovné, pokud vytváříme HTML značku `<a>`. Pokud chceme odkaz vypsat jinde, například v textu šablony, použijeme makro `{link}` se stejnou vnitřní syntaxí:

/--html
Adresa je: {link Product:show $productId}
\--

Přečtěte si další podrobnosti o syntaxi [Latte šablon |#templating#latte].


Persistentní parametry
----------------------

Krom klasických parametrů, které jsme používali nyní, existují i tzv. perzistentní parametry. Ty se liší v jediné avšak zásadní věci: **přenášejí se automaticky.** To znamená, že je nemusíme v odkazech explicitně uvádět, ale přesto se přenesou.

Pokud má vaše aplikace dvě jazykové mutace, bylo by neskutečně únavné v každém odkazu přenášet i aktuální jazyk. To není s Nette Framework potřeba. Prostě si parametr `$lang` označíme jako persistentní a to tímto způsobem:


/--php
class ProductPresenter extends Presenter
{
    /** @persistent */
    public $lang;

    ...
\--


Pokud aktuální hodnota parametru `$lang` bude `'en'`, tak do odkazu

/--html
<a n:href="Product:show $productId">detail produktu</a>
\--

se automaticky doplní i `lang => en`. Paráda!

Samozřejmě můžeme `lang` uvést a jeho hodnotu změnit:

/--html
<a n:href="Product:show $productId, lang => cs">detail v češtině</a>
\--

Zároveň v proměnné třídy `$lang` objektu `ProductPresenter` budeme mít hodnotu parameteru k dispozici, můžeme k ní přistoupit přes `$this->lang`. Můžeme v definici třídy uvést i výchozí hodnotu persistentního parametru. Bude-li mít parametr tuto výchozí hodnotou, pak nebude přenášen v URL.

.[note]
Persistetní proměnná musí být deklarovaná jako public.

Perzistence zohledňuje hierarchii tříd presenterů, tzn. že každý potomek má tytéž perzistentní parametry jako rodič. A přenáší si je mezi sebou.




Šablony komponent
-----------------

Odkazy v šabloně komponenty se chovají jinak. Nemíří totiž na jiné akce presenterů, ale na [signály komponent |#Signál neboli subrequest].

.[caution]
Rozdíl se projeví v šablonách komponent, kde zápis `{link Home:default}` nevygeneruje odkaz, ale signál na komponentu, zatímco `{plink Home:default}` vygeneruje platný odkaz na presenter, se kterým je spárována.

Nicméně i v šabloně komponenty je možné odkazovat na jiné presentery použitím makra `{plink ...}`. Makro používejte s rozvahou, může jít proti znovupoužitelnosti komponenty.



Odkazování v presenteru
-----------------------

Presenter a [komponenta | api:Nette\Application\UI\PresenterComponent] disponují metodou `link()`, pomocí které lze vytvářet odkazy podobně jako v šabloně. Prvním parametrem je cílová akce presenteru, následují předávané argumenty:

/--php
$url = $this->link(destination [,arg [,arg ...]]);
\--

Ty lze předat také pomocí pole. Příklady:

/--php
$url = $this->link('Product:show', $productId);

$url = $this->link('Product:show', array($productId, 'lang' => 'en'));
\--



Neplatné odkazy
---------------

Může se stát, že vytvoříme neplatný odkaz - buď proto, že vede na neexistující presenter, protože předává víc parametrů, než které cílová metoda přijímá ve své definici nebo když pro cílovou akci nelze vygenerovat URL. Jak naložit s neplatnými odkazy určuje statická proměnná `Presenter::$invalidLinkMode`. Ta může nabývat těchto hodnot (konstant):

- `Presenter::INVALID_LINK_SILENT` - tichý režim, jako URL se vrátí znak #
- `Presenter::INVALID_LINK_WARNING` - vizuální varování, viz dále
- `Presenter::INVALID_LINK_EXCEPTION` - vyhodí se výjimka InvalidLinkException

Výchozí nastavení je INVALID_LINK_SILENT v produkčním režimu a INVALID_LINK_WARNING ve vývojovém. INVALID_LINK_WARNING pracuje tak, že jako URL vrátí chybovou zprávu, která začíná znaky `error:`. Aby takové odkazy byly na první pohled patrné, doplníme si do CSS:

/--code css
a[href^="error:"] {
	background: red;
	color: white;
}
\--




Životní cyklus presenteru
=========================


Už víme, že tzv. akce presenteru způsobí zavolání metody `render<Akce>`, tedy například `renderShow`. Ale to není zdaleka jediná metoda, která se volá.

.[note]
Přesnější by bylo říci, že si budeme povídat o životním cyklu třídy [api:Nette\Application\UI\Presenter], ze které se presentery dědí nejčastěji. Obecně je totiž presenter jakákoliv třída implementující trivální rozhraní [api:Nette\Application\IPresenter] a jeden takový alternativní používá [Mikro-framework | micro-framework].

[* lifecycle2.gif *] *** *Životní cyklus presenteru* .<>


`startup()`
---------

Ihned po vytvoření presenteru se zavolá metoda `startup()`. Ta inicializuje proměnné nebo oveří uživatelská oprávnění.

.[note]
Pokud si píšete vlastní metodu `startup()`, nezapomeňte zavolat předka `parent::startup()`.

`action<Action>()`
------------------

Obdoba metody `render<View>()`. Jsou situace, kdy presenter provede určitý úkon (přihlásí uživatele, zapíše data do databáze) a poté přesměruje jinam. Dávat název `render` metodě, která nic nekreslí, by bylo nepěkné, proto existuje alternativa s názvem `action`.

Důležité je vědět, že `action<Action>()` se volá dříve, než metoda `render<View>()`. Může tedy i rozhodnout, že se zavolá jiná `render` metoda pomocí příkazu `$this->setView('jineView')` -> zavolá `renderJineView()`.

`handle<Signal>()`
-------------------------

Metoda zpracovává tzv. [signály |#Signál neboli subrequest] neboli subrequesty. Určeno pro uživatelskou interakci a zpracování AJAXových požadavků. Povíme si o tom později.

`beforeRender()`
-----------------

Metoda `beforeRender`, jak už název napovídá, se volá před nám známou metodou `render<View>()` a může obsahovat například společné nastavení šablony, předání proměnných společných pro více view a podobně.

`render{View}()`
----------------

Obvykle nasype do šablony potřebná data.


`shutdown()`
-----------------

Je vyvolána při ukončení životního cyklu presenteru.


Ukončení presenteru
-------------------

Presenter můžeme během jeho životního cyklu kdykoliv ukončit (ano, je to jistý eufemismus). Obvykle tak učiníme proto, že chceme zamezit vykreslování šablony nebo chceme někam přesměrovat.

- presenter ukončíme metodou `$presenter->terminate()`
- presenter ukončíme a přejdeme rovnou k renderování šablony: `$presenter->sendTemplate()`
- presenter ukončíme a odešleme payload: `$presenter->sendPayload()` (pro AJAX)
- presenter ukončíme a odešleme vlastní odpověď: `$presenter->sendResponse($response)`
- přejdeme na jiný presenter pomocí: `$presenter->forward('Presenter:action')`
- přesměrujeme na jiný presenter pomocí: `$presenter->redirect('Presenter:action')`
- přesměrujeme na jiné URL mimo naši aplikaci:  `$presenter->redirectUrl('http://nette.org')`

Důvodem ukončení může být i chybový stav:
- stránka neexistuje, vyhodíme výjimku `Nette\Application\BadRequestException` (chyba 404)
- uživatel nemá oprávnění stránku vidět, vyhodíme výjimku `Nette\Application\ForbiddenRequestException` (chyba 403)


Přesměrování
------------

Fungují `redirect()` a `forward()`, které přesměrují na novou akci presenteru, mají velmi podobnou syntax jako zmíněná funkce [link() |#Odkazování v presenteru]. Takže například po odeslání formuláře a zápisu dat do databáze zavoláme:

/--php
$this->redirect('Product:show', $id);
\--

Zatímco `forward()` přejde na novou akci bez přesměrování, metoda redirect() přesměruje prohlížeč HTTP kódem 302 nebo 303. Chceme-li zvolit jiný kód, uvedeme jej ještě před názvem akce presenteru:

/--php
$this->redirect(301, 'Product:show', $id);
\--

Na jinou URL mimo rozsah aplikace lze přesměrovat metodou redirectUrl()

/--php
$this->redirectUrl('http://nette.org');
\--

Přesměrování okamžitě ukončí činnost presenteru vyhození tzv. ukončovací výjimky `Nette\Application\AbortException`.

Před přesměrováním si občas chceme odeslat tzv. flash message, tedy zprávu, která se objeví po přesměrování v šabloně. Jak na to se dočtete v kapitole o [komponentách |components#toc-flash-zpravy].



Signál neboli subrequest
======================

Signál (aneb subrequest) je komunikace se serverem pod prahem normálního view, tedy akce, které se dějí, aniž by se změnilo view. View může měnit pouze presenter, proto komponenty pracují vždy pod tímto prahem, tudíž `$component->link()` vede na signál, `$presenter->link()` obvykle na view (nebo signál, je-li označen vykřičníkem přidaným na konec). Pro úplnost, i komponenta může volat `$this->presenter->link('view')`.

Signál způsobí znovunačtení stránky úplně stejně jako při původním požadavku (kromě případu, kdy je volán AJAXem) a vyvolá metodu `signalReceived($signal)`, jejíž výchozí implementace ve třídě *PresenterComponent* se pokusí zavolat metodu složenou ze slov `handle{signal}`.
 Další zpracování je na daném objektu. Objekty, které dědí od `PresenterComponent` (tzn. `Control` a `Presenter`) reagují tak, že se snaží zavolat metodu `handle{signal}` s příslušnými parametry.
 Jinými slovy: vezme se definice funkce `handle{signal}` a všechny parametry, které přišly s požadavkem, a k argumentům se podle jména dosadí parametry z URL a pokusí se danou metodu zavolat. Např. jako prametr `$id` se předá hodnota z parametru `id` v URL, jako `$something` se předá `something` z URL, atd.
 Pokud metoda neexistuje, metoda `signalReceived` vyvolá výjimku.

.[note]
Signál může přijímat jakákoliv komponenta, presenter nebo objekt, který implementuje rozhraní `ISignalReceiver`.

Mezi hlavní příjemce signálů budou patřit `Presentery` a vizuální komponenty dědící od `Control` (a ty se při přijetí signálu **automaticky invalidují**, což je důležité pro AJAX).
 Signál má sloužit jako znamení pro objekt, že má něco udělat – anketa si má započítat hlas od uživatele, blok s novinkami se má rozbalit a zobrazit dvakrát tolik novinek, formulář byl odeslán a má zpracovat data a podobně.

.[note]
Signál se vždy volá na aktuálním presenteru a view, tudíž není možné jej směřovat jinam.

URL pro signál vytváříme pomocí metody `PresenterComponent::link()`. Jako parametr `$destination` předáme řetězec `{signal}!` a jako `$args` pole argumentů, které chceme signálu předat. Signál se vždy volá na aktuální view s aktuálními parametry, parametry signálu se jen přidají. Navíc se přidává hned na začátku **parametr `?do`, který určuje signál**.

Jeho formát je buď `{signal}`, nebo `{signalReceiver}-{signal}`. `{signalReceiver}` je název komponenty v presenteru. Proto nemůže být v názvu komponenty pomlčka – používá se k oddělení názvu komponenty a signálu.

/--comment
http://forum.nette.org/cs/893-obsluzne-handlery-zo-sticky
\--
Metoda `isSignalReceiver()` ověří, zda je komponenta (první argument) příjemcem signálu (druhý argument). Druhý argument můžeme vynechat – pak zjišťuje, jestli je komponenta příjemcem jakéhokoliv signálu. Experimentálně lze jako druhý parametr uvést `TRUE` a tím ověřit, jestli je příjemcem nejen uvedená komponenta, ale také kterýkoliv její potomek.

V kterékoliv fázi předcházející `handle{signal}` můžeme vykonat signál manuálně zavoláním metody `$this->processSignal()`, která si bere na starosti vyřízení signálu – vezme komponentu, která se určila jako příjemce signálu (pokud není určen příjemce signálu, je to presenter samotný) a pošle jí signál.


**Příklad:**

/--php
if ($this->isSignalReceiver($this, 'paging') || $this->isSignalReceiver($this, 'sorting')) {
    $this->processSignal();
}
\--

Tím je signál provedený a už se nebude znovu volat.


Subrequest vs. request
----------------------

Rozdíly mezi signálem a požadavkem:
- subrequest přenáší všechny komponenty
- request přenáší označené (perzistentní) komponenty



Presenter a komponenty
======================

Bavíme-li se o presenterech, tak pod pojmem komponenty obvykle myslíme potomky třídy [Control |api:Nette\Application\UI\Control]. Přesnější by tedy bylo používat termín „controls“ (tj. ovládací prvky), ale „kontrola“ má v češtině zcela jiný význam a spíš se ujaly „komponenty“.

Sám presenter `Nette\Application\UI\Presenter` je přitom potomkem třídy Control, takže je tu velká podobnost mezi komponentami a presenterem. Především však `UI\Control` (a tím pádem i `UI\Presenter`) je tzv. komponent container, což znamená, že do něj lze vkládat další komponenty. Podobně, jako třeba do komponenty [formuláře |forms] vkládáme formulářové prvky (textové políčko, tlačítko, ...). A stejně jako u formulářů lze k prvkům přistupovat přes hranaté závorky:

/--php
// připojíme komponentu do presenteru
$presenter['mymenu'] = new MenuControl;

// získáme komponentu z presenteru a vykreslíme
$presenter['mymenu']->render();
\--

Připojením komponenty do presenteru (jejich svázáním) získáte možnost:
- používat v komponentě perzistentní parametry
- používat signály
- volat na komponentě funkce závislé na přítomnosti presenteru (`link`, `redirect`)

Pokud nic z toho nepotřebujeme (nebo nechceme), není potřeba komponentu s presenterem vázat.


Továrničky na komponenty
------------------------

Továrna na komponenty představuje elegantní způsob, jak komponenty vytvářet teprve ve chvíli, kdy jsou skutečně potřeba (lazy / on demand). Celé kouzlo spočívá v implementaci metody s názvem `createComponent<Name>()`, kde `<Name>` je název vytvářené komponenty, a která komponentu vytvoří a vrátí. Komponenta je následně připojena k presenteru. Metodě `createComponent<Name>` je předáván volitelný parametr s názvem komponenty, kterou vytváří.

/--php
class DefaultPresenter extends Nette\Application\UI\Presenter
{
	public function renderDefault()
	{
		$menu = $this['menu']; // přistoupíme ke komponentě
		// a pokud to bylo poprvé, zavolá se createComponentMenu()
		...
	}

	protected function createComponentMenu()
	{
		// vytvoříme a nakonfigurujeme komponentu
		$menu = new MenuControl;
		$menu->items = $this->item;
		// a vrátíme ji
		return $menu;
	}
}
\--

.[note]
Názvy komponent začínají vždy malým písmenem, přestože se v názvu továrničky píší s velkým.


Díky tomu, že jsou všechny komponenty vytvářeny v samostatné metodě, získává kód na přehlednosti.

Továrničky nikdy nevoláme přímo, zavolá se sama ve chvíli, kdy komponentu poprvé použijeme. Díky tomu je komponenta vytvořena ve správný okamžik a pouze v případě, když je skutečně potřeba. Pokud komponentu nepoužijeme (třeba při AJAXovém požadavku, kdy se přenáší jen část stránky, nebo při cachování šablony), nevytvoří se vůbec a ušetříme výkon serveru.

V šabloně je možné získat a vykreslit komponentu pomocí [makra {control} |default-macros#toc-vykreslovani-komponent]. Není proto potřeba manuálně komponenty předávat do šablony.

/--html
<h2>Editační formulář</h2>

{control editForm}
\--


Podrobnější informace o komponentách najdete na [této stránce |components].



Persistentní komponenty
------------------------

Také komponenty mohou být perzistentní. Perzistentní komponenty musí být správně anotované, subkomponenty uvnitř komponent není třeba nijak značit, jsou perzistentní samy o sobě:


/--php
/**
 * @persistent(game, abc, xyz)
 */
class DefaultPresenter extends Presenter
{
    public function actionDefault()
    {
        $fifteen = new FifteenControl($this, 'game');
        $fifteen->onGameOver[] = array($this, 'GameOver');

        $this->template->fifteen = $fifteen;
    }

    ...
}
\--


Stav perzistentních komponent se přenáší při přechodu na jiný Presenter podobně, jako v případě [perzistentních parametrů | #toc-obycejne-a-persistentni-parametry].

Proč je to nutné? V podstatě z technického důvodu. Mezi presentery se předávají jen data, která jsou jim společná, tedy která jsou deklarována na úrovni společných předků. Ale jak zjistit, že komponentu `game` deklarovala právě metoda třídy `DefaultPresenter` a ne nějaký její předek nebo potomek? To zjistit nelze. Lze ale zjistit, která třída deklarovala proměnnou `fifteen` a toho se právě využívá.

Tedy při subrequestu, při zavolání signálu jsou komponenty perzistentní samy o sobě. Je ale nutné, aby na vstupním a cílovém presenteru byla tatáž komponenta zařazená ve stromu pod stejným jménem. Tudíž nemá smysl, aby to fungovalo pro předem neznámé komponenty, ale jen pro komponenty s presenterem nějak pevně svázané.

.[note]
Subrequest přenáší všechny komponenty, request přenáší označené komponenty.

Situace se komplikuje v případě, že jsou ve hře komponenty, které mají zpracovat signály. Příkladem této komponenty může být třída [Form | api:Nette\Application\UI\Form]. Je totiž nutné zajistit, aby komponeta přijímající signál existovala předtím, než se zpracovávají signály komponent. V případě že příjemce signálu v tomto místě neexistuje, skončí aplikace výjimkou o neexistujícím příjemci signálu. Příkladem této chyby je vytvoření komponenty až metodách `render` jiným způsobem než továrničkou.

**Příklad správné registrace komponenty v metodách `action`:**
/--php
class DefaultPresenter extends Nette\Application\UI\Presenter
{
    public function actionDefault()
    {
        $fifteen = new FifteenControl;
        $fifteen->onGameOver[] = array($this, 'GameOver');
        $fifteen->useAjax = TRUE;

        $this['game'] = $fifteen; // zaregistrování komponenty
        // nyní je komponenta schopna správně přijímat signály
    }

    ...
}
\--


Kde mohu získat komponenty?
---------------------------

Na stránkách http://addons.nette.org/cs/ můžete najít open-source komponenty, které sem umístili dobrovolníci z komunity okolo Nette Framework. Nette Foundation za ně neručí.

{{themeicon: icon-house.png}}

{{tags: nette\application}}
