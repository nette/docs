Latte Macros
************

.[perex]
Summary and description of all Latte built-in macros.

.[table-latte-summary]
| Variable and expression printing ||
|---------------------------
| `{$variable}`                  | [prints an escaped variable |#Variable printing]
| `{$variable\|noescape}`        | [prints a variable without escaping |#Variable printing]
| `{expression}`                 | [prints an escaped expression |#Variable printing]
| `{expression\|noescape}`       | [prints an expression without escaping |#Variable printing]
|---------------------------
| Conditions ||
|---------------------------
| `{if $cond} … {elseif $cond} … {else} … {/if}`         | [if condition |#Conditions]
| `{$cond ? $value1 : $value2}`                          | [ternary operator |#Conditions]
| `{$cond ? $value}`                                     | [abbreviated "ternary" operator |#Conditions]
| `{$a ?: $default}`                                     | prints `$a`, if is empty prints `$default`
| `{ifset $var} … {elseifset $var} … {/ifset}`           | [if (isset()) condition |#Conditions]
| `{switch $var} … {case value} … {default} … {/switch}` | [choice by value |#Conditions]
|---------------------------
| Loops ||
|---------------------------
| `{foreach $arr as $item} … {/foreach}` | [foreach loop |#Loops]
| `{for expr; expr; expr} … {/for}`      | [for loop |#Loops]
| `{while expr} … {/while}`      | [while loop |#Loops]
| `{continueIf $cond}`           | [conditional jump to the next iteration |#Loops]
| `{breakIf $cond}`              | [conditional loop break |#Loops]
| `{first} … {/first}`           | [prints if first iteration |#Loops]
| `{last} … {/last}`             | [prints if last iteration |#Loops]
| `{sep} … {/sep}`               | [separator |#Loops]
|---------------------------
| Variables ||
|---------------------------
| `{var $foo = value}`           | [variable creation |#Variable declaration]
| `{default $foo = value}`       | [default value when variable isn't declared |#Variable declaration]
| `{capture $var} … {/capture}`  | [captures a section to a variable |#Capturing to variables]
|---------------------------
| Other ||
|---------------------------
| `{spaceless} … {/spaceless}`   | removes unnecessary whitespace, same as [strip |filters#strip] filter
| `{include 'file.latte'}`       | [includes a template from other file |#File including]
| `{php expression}`             | [evaluates an expression without printing it |#Code evaluation]
| `{* comment text *}`           | a comment (removed from evaluation)
| `{syntax mode}`                | [switches the syntax at runtime |#Syntax switching]
| `{l}` or `{r}`                 | prints { and } characters, respectively
| `{contentType $type}`          | [switches the escaping mode and sends HTTP header |#header-contenttype]
| `{debugbreak $cond}`           | [sets breakpoint to the code |#debugbreak]
|---------------------------
| HTML tag attributes ||
|---------------------------
| `n:class`                      |  [smart class attribute |#n-class]
| `n:attr`                       |  [smart HTML attributes |#n-attr]
| `n:ifcontent`                  |  [Omit empty HTML tag |#n-ifcontent]
| `n:tag-if`                     |  Omit HTML tag if condition is false
|---------------------------
| Blocks, layouts, template inheritance ||
|---------------------------
| `{block block}`                | [block definition and immediate print out |#blocks]
| `{define block}`               | [block defintion for future use |#blocks]
| `{include block}`              | [inserts a block |#block including]
| `{include mytemplate.latte}`   | [inserts a template |#block including]
| `{import 'file.latte'}`  | [loads blocks from external template |#template expansion inheritance]
| `{layout 'file.latte'}`        | [specifies a layout file |#template expansion inheritance]
| `{extends 'file.latte'}`       | [alias for `{layout}` |#template expansion inheritance]
| `{ifset #block} … {/ifset}`    | [condition if block is defined |#blocks]
|---------------------------
| Operators ||
|---------------------------
| `(expand)`                     | [expansion of arrays |#(expand)]


Available only in Nette Framework
---------------------------------

.[wide]
| Links ||
|---------------------------
| `n:href`                            | [link in `<a>` HTML elements |doc:presenters#links-in-templates]
| `{link Presenter:action}`           | [generates a link |doc:presenters#links-in-templates]
| `{plink Presenter:action}`          | [generates a link to a presenter |doc:presenters#links-in-templates]
| `{ifCurrent $link} … {/ifCurrent}`  | [deprecated, use n:class="$presenter->isLinkCurrent($link) ? ..."|doc:presenters#links-in-templates]
|---------------------------
| Controls and forms ||
|---------------------------
| `{control loginForm}`          | [prints a component |#Component rendering]
| `{form formName} … {/form}`    | [prints a form element |#forms]
| `{label fieldName} … {/label}` | [prints a form input label |#forms]
| `{input fieldName}`            | [prints a form input element |#forms]
| `{inputError fieldName}`       | [prints error message for form input element|#forms]
| `n:name`                       | [activates an HTML input element |#forms]
|---------------------------
| AJAX ||
|---------------------------
| `{snippet name} … {/snippet}`  | [a template snippet that can be sent by AJAX |doc:ajax#makro-snippet]
| `{snippetArea name}`           | snippets envelope
|---------------------------
| Translations ||
|---------------------------
| `{_}Text{/_}`                  | [translates a text |#localization]
| `{_expression}`                | [translates an expression and prints it with escaping |#localization]
|---------------------------
| Other ||
|---------------------------
| `{dump $variable}`             | [dumps variables to the Debugger Bar |#variable-dumping]
| `{cache $key} … {/cache}`      | [caches a template section |doc:caching#caching-in-templates]



Variable and expression printing `{expression}` .{toc: Variable printing}
-------------------------------------------------------------------------

**With escaping:** (eliminates the [Cross Site Scripting |doc:vulnerability-protection#cross-site-scripting-xss] vulnerability):

/--html
Full Name: {$name} {$surname}<br>
Age: {date('Y') - $birth}<br>
\--

**Without escaping** by using the `|noescape` modifier (an exclamation mark was used in older Nette versions):

/--html
<div class="article">
	{$content|noescape}
	{nl2br($notes)|noescape}
</div>
\--

Alternatively you can use notations with equals sign `{=expression}`.

With technology of [Context-Aware Escaping |guide#Context-aware escaping] it is also possible to use PHP variables inside the JavaScript safely:

/--html
<script>
var arr = {$arr};
var name = {$name}; // quotes are automatically added!
</script>
\--



Conditions `{if $cond} … {/if}`, `{$cond ? … : …}` .{toc: Conditions}
---------------------------------------------------------------------

Conditions behave exactly the same way as their PHP counterparts:

/--html
{if $stock}
	In stock
{elseif $onWay}
	On the way
{else}
	Not available
{/if}
\--

You can also use `{ifset}` macro which checks variable existence and corresponds to the `if (isset($var))` PHP code. `{ifset}` macro can check for [block |#blocks] existence as well.


Expression in the `{if}` condition can be placed in the closing macro which is useful in situations when we don't know the expression at the time of opening the condition block:

/--html
{if}
	<h1>Printing rows from the database</h1>

	{foreach $database->table as $row} ... {/foreach}
{/if $row}
\--

Block `{if}` with condition in a closing tag does not support `{elseif}` macro. Macro `{else}` can be used.

/--html
availability: {$stock ? 'In stock' : 'Not in stock'}

shortly: {$stock ? 'In stock'}
\--

Repetitive expression in condition could be shortened by `{switch}` and `{case}` macros. Those are expanded to series of `if ($var === 'value')` conditions, i.e. works differently than PHP. `break` is omitted.
/--html
{switch $transport}
	{case train}
		By train
	{case plane}
		By plane
	{default}
		Differently
{/switch}
\--



Loops `{foreach}`, `{for}`, `{while}`  .{toc: Loops}
----------------------------------------------------

`foreach`, `for` and `while` loops behave exactly the same as their PHP counterparts.

/--html
{foreach $result as $row}
	<span>{$row->title}</span>
{/foreach}
\--

/--html
{while $row = $result->fetch()}
	<span>{$row->title}</span>
{/while}
\--

/--html
{for $i = 0; $i < 10; $i++}
	<span>Item #{$i}</span>
{/for}
\--

Inside the `foreach` loop the `$iterator` variable is initialized. It holds important information about the current loop. [Its API |api:Latte\Runtime\CachingIterator] features iteration counter and methods identifying odd, even, first and last iteration:

- `isFirst()` - is this the first iteration?
- `isLast()` - is this the last iteration?
- `getCounter()` - iteration counter, starts from 1
- `isOdd()` - is this iteration odd?
- `isEven()` - is this iteration even?

Object behind the `$iterator` variable has [Nette\SmartObject trait characteristics |doc:smartobject#properties-getters-and-setters], that's why you can write `$iterator->first` instead of `$iterator->isFirst()` and alike. For example:

/--html
{foreach $rows as $row}
	{if $iterator->first}<table>{/if}

	<tr id="row-{$iterator->counter}">
		<td>{$row->name}</td>
		<td>{$row->email}</td>
	</tr>

	{if $iterator->last}</table>{/if}
{/foreach}
\--

`{if $iterator->first}<table>{/if}` can be replaced with `{first}<table>{/first}`. Similarly, the condition with `last` can be also written as `{last}</table>{/last}`.

/--html
{foreach $rows as $row}
	{first}<table>{/first}
		{first 5}<tr>{/first} {* new row each 5 items *}
			<td>{$row->value}</td>
		{last 5}</tr>{/last}
	{last}</table>{/last}
{/foreach}
\--

Finally, the equivalent of `{if !$iterator->last} … {/if}` notation (ie. not the last item) is `{sep} … {/sep}` macro. Usually it marks the separator between items – comma, for example. This way the redundant right comma won't print:

/--html
{foreach $items as $item} {$item} {sep}, {/sep} {/foreach}
\--

There are two special macros you can use inside the loop - `{continueIf ?}` and `{breakIf ?}` which jump to the next iteration and end the loop, respectively, if the conditions are met:

/--html
{foreach $rows as $row}
	{continueIf $row->parent == null}
	...
{/foreach}
\--

The cycle definition can be merged with the HTML definition as follows: (lists the `div` element for each row)
/--html
<div n:foreach="$rows as $row">
	...
</div>
\--
Or, use the inner loop to repeat only the inside of the element: (`ul` is displayed once, `li` for each line)
/--html
<ul n:inner-foreach="$rows as $row">
	<li>
	...
	</li>
</ul>
\--



Variable declaration `{var}` and `{default}` .{toc: Variable declaration}
-------------------------------------------------------------------------

We can declare variables directly in the template by using `{var}` macro:

/--html
{var $name = 'John Smith'}
{var $age = 27}

{* Multiple declaration *}
{var $name = 'John Smith', $age = 27}
\--

Macro `{default}` does the same thing, except it only sets the value to nonexistent variables:

/--html
{default $lang = 'cs'}
\--



Capturing to variables `{capture}` .{toc: Capturing to variables}
-----------------------------------------------------------------

By using `{capture}` macro you can capture the output to a variable:

/--html
{capture $var}
<ul>
	<li>Hello World</li>
</ul>
{/capture}

<p>Captured: {$var}</p>
\--

If you want to capture the output only for a [filter |guide#filters] to be applied it is easier to use the filter on the `{block}` instead:

/--html
{block|strip}
<ul>
	<li>Hello World</li>
</ul>
{/block}
\--



File including `{include}` .{toc: File including}
-------------------------------------------------

You can include other templates into the current template. The included file has access to the global variables of the current template. Additionally, we can also pass other variables listed in the macro:

/--html
{include 'basket.latte'}

{include 'menu.latte', level => 3, data => $menu}
\--

.[note]
In addition to including files the `{include}` macro is also used to [include blocks |#block including].



Code evaluation `{php expression}` .{toc: Code evaluation}
----------------------------------------------------------

This macro evaluates the code written inside but it does't print it.



Header `{contentType}`
----------------------

Switches [Context-Aware Escaping |guide#context-aware-escaping] to the context determined by the parameter so that when printing, the variables are escaped using the rules of the context. For example `{contentType xml}` would switch to the XML escaping mode, meanwhile `{contentType text}` disables escaping completely.


If the parameter is a complete MIME type the correct HTTP header is sent to the browser:

/--html
{contentType application/xml}
<?xml version="1.0"?>
<rss version="2.0">
	<channel>
		<title>RSS feed</title>
		<item>
			...
		</item>
	</channel>
</rss>
\--



Break point `{debugbreak}` .{toc: debugbreak}
---------------------------------------------

Specifies the place where code execution will break. It is used for debugging purposes for the programmer to inspect the runtime environment and to ensure the code runs as expected. It supports [Xdebug |http://xdebug.org] and [PhpEd |http://www.nusphere.com/products/php_debugger.htm]. Additionally, you can specify a condition when the code should break.

/--html
{debugbreak} {* breaks the program *}

{debugbreak $counter == 1}  {* breaks the program if the condition is met *}
\--




Syntax switching `{syntax}` .{toc: Syntax switching}
----------------------------------------------------

Macros don't have to be enclosed by simple braces only, we can also use other delimiters, even at runtime. That's the function of `{syntax …}` macro where we can use following parameters:

- latte: `{...}`
- double: `{{...}}`
- off: completely disables macro evaluation

Note: asp and python syntaxes were removed in 2.4.0.

By using the n:macro notation we can disable Latte for a JavaScript block only:

/--html
<script n:syntax="off">
	var obj = {var: 123}; // this isn't a macro
</script>
\--

Latte mode can easily be used in JavaScript, you just have to avoid the notation above by writing a space after the opening brace `{ var: 123}` or by using quotes around the identifier `{'var': 123}`.

If you turn off Latte with `{syntax off}` (ie macro syntax, not n: macro), remember that you can not turn it back on using `{syntax}`. No parentheses are processed, so neither the syntax exception termination tag.


n:class
-------

In a typical situation we could be trying to print an unknown amount of entries from the database as `<li>` elements and mark the last entry and every odd item with corresponding CSS classes for further styling. In case the last line is odd as well, we will require both classes, but we want to avoid empty classes like `<li class=" ">`.

By using `n:class` macro the problem is rather trivial:

/--html
<ul>
	{foreach $data as $item}
	<li n:class="$iterator->odd ? alt, $iterator->last ? last">{$item}</li>
	{/foreach}
</ul>
\--

Or do you need to mark the current menu link with 'current' class?

/--html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:*') ? current">
\--

Amazing, huh?

If you need more accurate URL detection, the `isLinkCurrent()` method can also pass the expected parameter

/--html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:action', 'slug') ? current">
\--



n:attr
------

`n:attr` macro is able to generate any HTML attribute similarly to the [n:class |#n:class]. It's mostly suitable in cases when we don't know which attributes we want to print and which not to.

/--html
<input type="checkbox" n:attr="value => $value, checked => $checked">
\--

Depending on the values of the variables `$value` and `$checked` this will print:

/--html
<input type="checkbox">

{* $value = 'Hello' *}
<input type="checkbox" value="Hello">

{* $checked = true *}
<input type="checkbox" value="Hello" checked>
\--

n:ifcontent
-----------

`n:ifcontent` macro removes empty tag

/--html
<div>
	<div class="error" n:ifcontent>{$error}</div>
</div>
\--

Depending on the values of the variable `$error` this will print:

/--html
{* $error = '' *}
<div>
</div>

{* $error = 'Required' *}
<div>
	<div class="error">Required</div>
</div>
\--





Blocks `{block}` and `{define}`  .{toc: Blocks}
-----------------------------------------------

Block selects a region of the template, for example to apply a filter (see [example |#Capturing to variables]) or to name it and reinsert it elsewhere in the template.

/--html
{block sidebar}
	<h3>Menu</h3>
	...
{/block}
\--

We can nest the blocks and of course we can write them in `n:macro` notation:

/--html
{block sidebar}
	<h3>Menu</h3>
	...

	<ul n:block="menulist">
		...
	</ul>
{/block}
\--

A block is immediately printed. In case we want to define the block only without printing it we can use `{define}` macro instead of `{block}`.

As for the name of the block it is allowed to specify it by a variable too: `{block $var} … {/block}`.

Every block can see the variables of its surroundings. But alternation of the value inside the block will be visible only in the block (and in nested blocks of course).

Existence of a block can by tested with `{ifset #block}` macro.



Block and template inclusion `{include block}` or `{include 'mytemplate.latte'}`  .{toc: Block including}
---------------------------------------------------------------------------------------------------------

Block and template inclusion is performed using `{include}` macro.

/--html
{include sidebar}
\--

Analogically for templates:

/--html
{include 'sidebar.latte'}
\--

It is also possible to pass additional parameters:

/--html
{include sidebar, id => 123, name => $value}
\--

We can include a block by specifying the block name stored in a variable as well (to differentiate from including a file we use the hash sign before the block name):

/--html
{include #$block$name}
\--


Blocks can also include themselves which is suitable when rendering a tree structured menu.

/--html
{block menu}
<ul>
	{foreach $menu as $item}
	<li>{if is_array($item)}
		{include menu, menu => $item}
	{else}
		{$item}
	{/if}</li>
	{/foreach}
</ul>
{/block}
\--

Instead of `{include menu, ...}` we can write `{include this, ...}` where #this points to the current block.


If you need to add some code to the previously defined block (e.g. add a link to a new stylesheet), you don't need to redeclare and copy whole block. Use `{include parent}` instead.

/--html
{block styles}
	{include parent}
	<link href="http://url.to.styles.css" rel="stylesheet">
{/block}
\--


Template expansion/inheritance `{layout}` .{toc: Template expansion/inheritance}
--------------------------------------------------------------------------------

Template expansion (also called inheritance) is a powerful tool which enables us to create even very complicated layouts effectively and with no code repetition.

Let's say we have two simple pages. The first one:

/--html
<html>
	<head>
		<title>First page | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Lorem Gypsum...</p>
		</div>
	</body>
</html>
\--

and the second:

/--html
<html>
	<head>
		<title>Second page | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Proin eu sem purus. Donec bibendum
			vestibulum...</p>
		</div>
	</body>
</html>
\--

The pages vary only by `<title>` and `<div#content>` elements, so we'll create a layout file which contains all common parts and specifies placeholders, which are nothing more but blocks:

File `@layout.latte`:
/--html
<html>
	<head>
		<title>{block title}{/block} | My web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">{block content}{/block}</div>
	</body>
</html>
\--

In the actual templates we'll point to the layout by using the `{layout}` macro, so we can minimize the template content by only defining the two blocks:

/--html
{layout '@layout.latte'}

{block title}First page{/block}

{block content}<p>Lorem Gypsum...</p>{/block}
\--

The other page will look similar.

Also, there are no limits to the number of levels, there can be as many layers as you want.




Component rendering `{control …}` .{toc: Component rendering}
-------------------------------------------------------------

`{control}` macro renders the presenter component. For better understanding it's good to know how the macro is compiled to PHP code.

/--html
{control cartControl}		renders whole cart on the page
{control cartControl:small}	renders small sidebar cart summary
\--

This compiles to:

/--php
$control->getComponent('cartControl')->render();
$control->getComponent('cartControl')->renderSmall();
\--

`getComponent()` method returns the `cartControl` component and then the `render()` or `renderSmall()` method, respectively, is called on it.

We can also add parameters which will be passed to the render method, for example:

/--html
{control cartControl, $maxItems, $showSummary}
{control cartControl, maxItems => 5, showSummary => true}
{control cartControl, [maxItems => 5, showSummary => true]}
{control cartControl:small, $maxItems, $showSummary}
\--

compiles to:

/--php
$control->getComponent('cartControl')->render($maxItems, $showSummary);
$control->getComponent('cartControl')->render(['maxItems' => 5, 'showSummary' => true]);
$control->getComponent('cartControl')->render([['maxItems' => 5, 'showSummary' => true]]);
$control->getComponent('cartControl')->renderSmall($maxItems, $showSummary);
\--

.[caution]
If anywhere in the parameter part **`=>`** is used, all parameters will be wrapped with an array and passed as the first argument.

Rendering of sub-component:

/--html
{control cartControl-someForm}
\--

compiles to:

/--php
$control->getComponent("cartControl-someForm")->render();
\--



Forms `{form}`, `{input}`, `{inputError}`, `{label}` .{toc: Forms}
------------------------------------------------------------------

Macros for rendering [forms |doc:forms] and their elements:

/--html
{form myForm}
<table>
<tr n:foreach="$form->controls as $name => $field">
	<th>{label $name /}<th>
	<td>{input $name}</td>
	<td n:ifcontent>{inputError $name}</td>
</tr>
</table>
{/form}
\--

`{input}` macro renders any element including select boxes and textareas. `{label}` is optionally paired macro, ie. `{label}Age{/label}`, in that case the text is translated too. Macro `{inputError}` prints error message for form input.

It's also possible to "breathe life" into a raw HTML input with `n:name` attribute macro, which links it with the form input using its identification:

/--html
<form n:name=myForm>
	<p>Name: <input size="50" n:name="name"></p>
	<p>Password: <input size="30" n:name="password"></p>
</form>
\--



Localization `{_expression}` .{toc: Localization}
-------------------------------------------------

Macro which helps with automated translating in templates. For proper functionality a translator has to be set, see [localization |doc:localization#template-translation]:

/--php
$latte->addFilter('translate', new MyTranslator);
\--

At this point every expression written in this macro will be automatically translated:

/--html
{_$variable}
\--

You can also use an alternative pair notation for chunks of text within a template:

/--html
{_}Text to be translated{/_}
\--



Variable dumping `{dump}` .{toc: Variable dumping}
--------------------------------------------------

Requires [Tracy|tracy:].

/--html
{dump $name} {* inspects the $name variable *}

{dump}       {* inspects all the defined variables *}
\--



Array expansion operator `(expand)` .{toc: (expand)}
----------------------------------------------------

The `(expand)` operator allows you to use a array where multiple arguments are expected. This is the equivalent of the [`...` operator from PHP |http://php.net/manual/en/functions.arguments.php#functions.variable-arg-list.new], but it retaining the keys.

It can be used, for example, to pass arguments into blocks or included templates if we have them in the array.


/--html
{include 'foobar.latte' (expand) $args}          {* arguments for include macro *}
\--

{{composer: latte/latte}}
