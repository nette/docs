Estado global y singletons
**************************

.[perex]
Advertencia: Las siguientes construcciones son un signo de c√≥digo mal dise√±ado:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` o `static::$var`

¬øAparece alguna de estas construcciones en su c√≥digo? Entonces tiene la oportunidad de mejorarlo. Quiz√°s piense que son construcciones comunes que ve incluso en soluciones de ejemplo de varias bibliotecas y frameworks. Si es as√≠, entonces el dise√±o de su c√≥digo no es bueno.

Ahora definitivamente no estamos hablando de alg√∫n tipo de pureza acad√©mica. Todas estas construcciones tienen una cosa en com√∫n: utilizan estado global. Y eso tiene un impacto destructivo en la calidad del c√≥digo. Las clases mienten sobre sus dependencias. El c√≥digo se vuelve impredecible. Confunde a los programadores y reduce su eficiencia.

En este cap√≠tulo explicaremos por qu√© es as√≠ y c√≥mo evitar el estado global.


Acoplamiento global
-------------------

En un mundo ideal, un objeto deber√≠a poder comunicarse solo con los objetos que le han sido [pasados directamente |passing-dependencies]. Si creo dos objetos `A` y `B` y nunca paso una referencia entre ellos, entonces ni `A` ni `B` pueden acceder al otro objeto o cambiar su estado. Esta es una propiedad muy deseable del c√≥digo. Es similar a tener una bater√≠a y una bombilla; la bombilla no se encender√° hasta que la conecte a la bater√≠a con un cable.

Pero esto no se aplica a las variables globales (est√°ticas) o singletons. El objeto `A` podr√≠a acceder *inal√°mbricamente* al objeto `C` y modificarlo sin pasar ninguna referencia, llamando a `C::changeSomething()`. Si el objeto `B` tambi√©n toma el `C` global, entonces `A` y `B` pueden influenciarse mutuamente a trav√©s de `C`.

El uso de variables globales introduce en el sistema una nueva forma de acoplamiento *inal√°mbrico* que no es visible desde el exterior. Crea una cortina de humo que complica la comprensi√≥n y el uso del c√≥digo. Para que los desarrolladores comprendan realmente las dependencias, deben leer cada l√≠nea del c√≥digo fuente. En lugar de simplemente familiarizarse con la interfaz de las clases. Adem√°s, es un acoplamiento completamente innecesario. El estado global se usa porque es f√°cilmente accesible desde cualquier lugar y permite, por ejemplo, escribir en la base de datos a trav√©s del m√©todo global (est√°tico) `DB::insert()`. Pero como mostraremos, la ventaja que esto aporta es insignificante, mientras que las complicaciones que causa son fatales.

.[note]
Desde el punto de vista del comportamiento, no hay diferencia entre una variable global y una est√°tica. Son igualmente da√±inas.


Acci√≥n fantasmal a distancia
----------------------------

"Acci√≥n fantasmal a distancia" - as√≠ llam√≥ famosamente Albert Einstein en 1935 a un fen√≥meno de la f√≠sica cu√°ntica que le pon√≠a la piel de gallina.
Se trata del entrelazamiento cu√°ntico, cuya peculiaridad es que cuando mides informaci√≥n sobre una part√≠cula, influyes instant√°neamente en la otra part√≠cula, incluso si est√°n separadas por millones de a√±os luz. Lo cual aparentemente viola la ley fundamental del universo de que nada puede propagarse m√°s r√°pido que la luz.

En el mundo del software, podemos llamar "acci√≥n fantasmal a distancia" a una situaci√≥n en la que iniciamos un proceso que creemos que est√° aislado (porque no le pasamos ninguna referencia), pero en lugares remotos del sistema ocurren interacciones y cambios de estado inesperados de los que no ten√≠amos ni idea. Esto solo puede ocurrir a trav√©s del estado global.

Imagine que se une a un equipo de desarrolladores de un proyecto que tiene una base de c√≥digo extensa y madura. Su nuevo jefe le pide que implemente una nueva funci√≥n y usted, como buen desarrollador, comienza escribiendo una prueba. Pero como es nuevo en el proyecto, realiza muchas pruebas exploratorias del tipo "¬øqu√© pasa si llamo a este m√©todo?". E intenta escribir la siguiente prueba:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // n√∫mero de su tarjeta
	$cc->charge(100);
}
```

Ejecuta el c√≥digo, quiz√°s varias veces, y despu√©s de un tiempo nota notificaciones en su m√≥vil del banco de que cada vez que se ejecuta, se cargan 100 d√≥lares a su tarjeta de cr√©dito ü§¶‚Äç‚ôÇÔ∏è

¬øC√≥mo diablos pudo la prueba causar un cargo real de dinero? Operar con una tarjeta de cr√©dito no es f√°cil. Debe comunicarse con un servicio web de terceros, debe conocer la URL de este servicio web, debe iniciar sesi√≥n, etc. Ninguna de esta informaci√≥n est√° contenida en la prueba. Peor a√∫n, ni siquiera sabe d√≥nde est√° presente esta informaci√≥n y, por lo tanto, tampoco c√≥mo simular (mock) las dependencias externas para que cada ejecuci√≥n no resulte en que se carguen nuevamente 100 d√≥lares. ¬øY c√≥mo se supon√≠a que usted, como nuevo desarrollador, supiera que lo que estaba a punto de hacer le har√≠a 100 d√≥lares m√°s pobre?

¬°Eso es acci√≥n fantasmal a distancia!

No le queda m√°s remedio que rebuscar durante mucho tiempo en un mont√≥n de c√≥digo fuente, preguntar a colegas m√°s antiguos y experimentados, antes de comprender c√≥mo funcionan las conexiones en el proyecto. Esto se debe a que al mirar la interfaz de la clase `CreditCard`, no se puede determinar el estado global que debe inicializarse. Incluso mirar el c√≥digo fuente de la clase no le dice qu√© m√©todo de inicializaci√≥n debe llamar. En el mejor de los casos, puede encontrar una variable global a la que se accede y, a partir de ella, intentar adivinar c√≥mo inicializarla.

Las clases en tal proyecto son mentirosas patol√≥gicas. La tarjeta de cr√©dito finge que basta con instanciarla y llamar al m√©todo `charge()`. En secreto, sin embargo, colabora con otra clase `PaymentGateway`, que representa la pasarela de pago. Incluso su interfaz dice que se puede inicializar por separado, pero en realidad extrae credenciales de alg√∫n archivo de configuraci√≥n, etc. Para los desarrolladores que escribieron este c√≥digo, est√° claro que `CreditCard` necesita `PaymentGateway`. Escribieron el c√≥digo de esta manera. Pero para cualquiera que sea nuevo en el proyecto, es un completo misterio y dificulta el aprendizaje.

¬øC√≥mo arreglar la situaci√≥n? F√°cilmente. **Deje que la API declare las dependencias.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Observe c√≥mo de repente las interconexiones dentro del c√≥digo son obvias. Al declarar el m√©todo `charge()` que necesita `PaymentGateway`, no tiene que preguntar a nadie c√≥mo est√° interconectado el c√≥digo. Sabe que debe crear su instancia, y cuando intenta hacerlo, se da cuenta de que debe proporcionar los par√°metros de acceso. Sin ellos, el c√≥digo ni siquiera se ejecutar√≠a.

Y lo m√°s importante, ahora puede simular (mock) la pasarela de pago, para que no se le cobren 100 d√≥lares cada vez que ejecute la prueba.

El estado global hace que sus objetos puedan acceder en secreto a cosas que no est√°n declaradas en su API y, como resultado, convierten sus API en mentirosos patol√≥gicos.

Quiz√°s no lo hab√≠a pensado as√≠ antes, pero cada vez que usa estado global, est√° creando canales de comunicaci√≥n inal√°mbricos secretos. La acci√≥n fantasmal a distancia obliga a los desarrolladores a leer cada l√≠nea de c√≥digo para comprender las interacciones potenciales, reduce la productividad de los desarrolladores y confunde a los nuevos miembros del equipo. Si usted es quien cre√≥ el c√≥digo, conoce las dependencias reales, pero cualquiera que venga despu√©s de usted est√° perdido.

No escriba c√≥digo que utilice estado global, d√© preferencia al paso de dependencias. Es decir, inyecci√≥n de dependencias.


Fragilidad del estado global
----------------------------

En el c√≥digo que utiliza estado global y singletons, nunca se sabe cu√°ndo y qui√©n cambi√≥ este estado. Este riesgo aparece ya durante la inicializaci√≥n. El siguiente c√≥digo debe crear una conexi√≥n a la base de datos e inicializar la pasarela de pago, pero constantemente lanza una excepci√≥n y encontrar la causa es extremadamente tedioso:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Debe examinar detenidamente el c√≥digo para descubrir que el objeto `PaymentGateway` accede de forma inal√°mbrica a otros objetos, algunos de los cuales requieren una conexi√≥n a la base de datos. Por lo tanto, es necesario inicializar la base de datos antes que `PaymentGateway`. Sin embargo, la cortina de humo del estado global le oculta esto. ¬øCu√°nto tiempo habr√≠a ahorrado si la API de las clases individuales no enga√±ara y declarara sus dependencias?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Un problema similar surge tambi√©n al usar acceso global a la conexi√≥n de la base de datos:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Al llamar al m√©todo `save()`, no est√° claro si ya se ha creado la conexi√≥n a la base de datos y qui√©n es responsable de su creaci√≥n. Si quisi√©ramos, por ejemplo, cambiar la conexi√≥n a la base de datos sobre la marcha, por ejemplo, para pruebas, probablemente tendr√≠amos que crear m√©todos adicionales como `DB::reconnect(...)` o `DB::reconnectForTest()`.

Consideremos un ejemplo:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

¬øD√≥nde tenemos la certeza de que al llamar a `$article->save()` se est√° utilizando realmente la base de datos de prueba? ¬øQu√© pasa si el m√©todo `Foo::doSomething()` cambi√≥ la conexi√≥n global a la base de datos? Para averiguarlo, tendr√≠amos que examinar el c√≥digo fuente de la clase `Foo` y probablemente de muchas otras clases. Sin embargo, este enfoque solo proporcionar√≠a una respuesta a corto plazo, ya que la situaci√≥n puede cambiar en el futuro.

¬øY si movemos la conexi√≥n a la base de datos a una variable est√°tica dentro de la clase `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Esto no cambia nada en absoluto. El problema es el estado global y es completamente irrelevante en qu√© clase se esconde. En este caso, al igual que en el anterior, al llamar al m√©todo `$article->save()` no tenemos ninguna pista sobre en qu√© base de datos se escribir√°. Cualquiera en el otro extremo de la aplicaci√≥n podr√≠a haber cambiado la base de datos en cualquier momento usando `Article::setDb()`. Bajo nuestras narices.

El estado global hace que nuestra aplicaci√≥n sea **extremadamente fr√°gil**.

Sin embargo, existe una forma sencilla de abordar este problema. Simplemente deje que la API declare las dependencias, lo que garantizar√° la funcionalidad correcta.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Gracias a este enfoque, desaparece la preocupaci√≥n por cambios ocultos e inesperados en la conexi√≥n a la base de datos. Ahora tenemos la certeza de d√≥nde se guarda el art√≠culo y ninguna modificaci√≥n del c√≥digo dentro de otra clase no relacionada puede cambiar la situaci√≥n. El c√≥digo ya no es fr√°gil, sino estable.

No escriba c√≥digo que utilice estado global, d√© preferencia al paso de dependencias. Es decir, inyecci√≥n de dependencias.


Singleton
---------

Singleton es un patr√≥n de dise√±o que, seg√∫n la "definici√≥n":https://en.wikipedia.org/wiki/Singleton_pattern de la conocida publicaci√≥n Gang of Four, restringe una clase a una √∫nica instancia y ofrece acceso global a ella. La implementaci√≥n de este patr√≥n generalmente se asemeja al siguiente c√≥digo:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// y otros m√©todos que cumplen las funciones de la clase dada
}
```

Desafortunadamente, singleton introduce estado global en la aplicaci√≥n. Y como hemos mostrado anteriormente, el estado global es indeseable. Por lo tanto, singleton se considera un antipatr√≥n.

No use singletons en su c√≥digo y reempl√°celos con otros mecanismos. Realmente no necesita singletons. Sin embargo, si necesita garantizar la existencia de una √∫nica instancia de una clase para toda la aplicaci√≥n, d√©jelo en manos del [contenedor DI |container]. Cree as√≠ un singleton de aplicaci√≥n, o servicio. De esta manera, la clase dejar√° de ocuparse de garantizar su propia unicidad (es decir, no tendr√° el m√©todo `getInstance()` ni la variable est√°tica) y cumplir√° solo sus funciones. As√≠ dejar√° de violar el principio de responsabilidad √∫nica.


Estado global versus pruebas
----------------------------

Al escribir pruebas, asumimos que cada prueba es una unidad aislada y que ning√∫n estado externo entra en ella. Y ning√∫n estado sale de las pruebas. Despu√©s de completar una prueba, todo el estado relacionado con la prueba deber√≠a ser eliminado autom√°ticamente por el recolector de basura. Gracias a esto, las pruebas est√°n aisladas. Por lo tanto, podemos ejecutar las pruebas en cualquier orden.

Sin embargo, si hay estados globales/singletons presentes, todas estas agradables suposiciones se desmoronan. El estado puede entrar y salir de la prueba. De repente, el orden de las pruebas puede importar.

Para poder probar los singletons, los desarrolladores a menudo tienen que relajar sus propiedades, por ejemplo, permitiendo que la instancia sea reemplazada por otra. Tales soluciones son, en el mejor de los casos, un hack que crea c√≥digo dif√≠cil de mantener y comprender. Cada prueba o m√©todo `tearDown()` que afecte a cualquier estado global debe revertir estos cambios.

¬°El estado global es el mayor dolor de cabeza en las pruebas unitarias!

¬øC√≥mo arreglar la situaci√≥n? F√°cilmente. No escriba c√≥digo que utilice singletons, d√© preferencia al paso de dependencias. Es decir, inyecci√≥n de dependencias.


Constantes globales
-------------------

El estado global no se limita solo al uso de singletons y variables est√°ticas, sino que tambi√©n puede referirse a constantes globales.

Las constantes cuyo valor no nos aporta ninguna informaci√≥n nueva (`M_PI`) o √∫til (`PREG_BACKTRACK_LIMIT_ERROR`) est√°n claramente bien. Por el contrario, las constantes que sirven como una forma de pasar informaci√≥n *inal√°mbricamente* al c√≥digo no son m√°s que una dependencia oculta. Como `LOG_FILE` en el siguiente ejemplo. El uso de la constante `FILE_APPEND` es completamente correcto.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

En este caso, deber√≠amos declarar un par√°metro en el constructor de la clase `Foo` para que se convierta en parte de la API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Ahora podemos pasar la informaci√≥n sobre la ruta al archivo de registro y cambiarla f√°cilmente seg√∫n sea necesario, lo que facilita las pruebas y el mantenimiento del c√≥digo.


Funciones globales y m√©todos est√°ticos
--------------------------------------

Queremos enfatizar que el uso de m√©todos est√°ticos y funciones globales en s√≠ mismo no es problem√°tico. Explicamos por qu√© el uso de `DB::insert()` y m√©todos similares es inapropiado, pero siempre se trat√≥ solo de una cuesti√≥n de estado global, que se almacena en alguna variable est√°tica. El m√©todo `DB::insert()` requiere la existencia de una variable est√°tica porque la conexi√≥n a la base de datos se almacena en ella. Sin esta variable, ser√≠a imposible implementar el m√©todo.

El uso de m√©todos est√°ticos y funciones deterministas, como `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` y muchas otras, est√° en perfecta consonancia con la inyecci√≥n de dependencias. Estas funciones siempre devuelven los mismos resultados para los mismos par√°metros de entrada y, por lo tanto, son predecibles. No utilizan ning√∫n estado global.

Sin embargo, tambi√©n existen funciones en PHP que no son deterministas. Entre ellas se encuentra, por ejemplo, la funci√≥n `htmlspecialchars()`. Su tercer par√°metro `$encoding`, si no se especifica, tiene como valor predeterminado el valor de la opci√≥n de configuraci√≥n `ini_get('default_charset')`. Por lo tanto, se recomienda especificar siempre este par√°metro y evitar as√≠ un posible comportamiento impredecible de la funci√≥n. Nette lo hace consistentemente.

Algunas funciones, como `strtolower()`, `strtoupper()` y similares, en el pasado reciente se comportaron de forma no determinista y depend√≠an de la configuraci√≥n de `setlocale()`. Esto caus√≥ muchas complicaciones, m√°s com√∫nmente al trabajar con el idioma turco. Este distingue entre las letras `I` may√∫scula y min√∫scula con y sin punto. As√≠ que `strtolower('I')` devolv√≠a el car√°cter `ƒ±` y `strtoupper('i')` el car√°cter `ƒ∞`, lo que provoc√≥ que las aplicaciones comenzaran a causar una serie de errores misteriosos. Sin embargo, este problema se solucion√≥ en la versi√≥n 8.2 de PHP y las funciones ya no dependen de la configuraci√≥n regional (locale).

Este es un buen ejemplo de c√≥mo el estado global atorment√≥ a miles de desarrolladores en todo el mundo. La soluci√≥n fue reemplazarlo por inyecci√≥n de dependencias.


¬øCu√°ndo es posible usar estado global?
--------------------------------------

Existen ciertas situaciones espec√≠ficas en las que es posible utilizar el estado global. Por ejemplo, al depurar c√≥digo, cuando necesita imprimir el valor de una variable o medir la duraci√≥n de una parte espec√≠fica del programa. En tales casos, que se refieren a acciones temporales que luego se eliminar√°n del c√≥digo, es leg√≠timo utilizar un dumper o cron√≥metro globalmente disponible. Estas herramientas no forman parte del dise√±o del c√≥digo.

Otro ejemplo son las funciones para trabajar con expresiones regulares `preg_*`, que almacenan internamente las expresiones regulares compiladas en una cach√© est√°tica en memoria. Por lo tanto, cuando llama a la misma expresi√≥n regular varias veces en diferentes lugares del c√≥digo, solo se compila una vez. La cach√© ahorra rendimiento y, al mismo tiempo, es completamente invisible para el usuario, por lo que dicho uso puede considerarse leg√≠timo.


Resumen
-------

Hemos discutido por qu√© tiene sentido:

1) Eliminar todas las variables est√°ticas del c√≥digo
2) Declarar dependencias
3) Y usar inyecci√≥n de dependencias

Al pensar en el dise√±o del c√≥digo, tenga en cuenta que cada `static $foo` representa un problema. Para que su c√≥digo sea un entorno que respete DI, es esencial erradicar por completo el estado global y reemplazarlo mediante inyecci√≥n de dependencias.

Durante este proceso, puede descubrir que es necesario dividir la clase porque tiene m√°s de una responsabilidad. No tenga miedo de eso; esfu√©rcese por el principio de responsabilidad √∫nica.

*Me gustar√≠a agradecer a Mi≈°ko Hevery, cuyos art√≠culos, como [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], son la base de este cap√≠tulo.*
