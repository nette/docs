Що таке "впровадження залежностей"?
***********************************

.[perex]
Ця глава знайомить вас з основними практиками програмування, яких слід дотримуватися при написанні будь-якої програми. Це основи, необхідні для написання чистого, зрозумілого та зручного для супроводу коду.

Якщо ви вивчите і будете дотримуватися цих правил, Nette буде поруч з вами на кожному кроці. Вона виконуватиме рутинні завдання за вас і зробить так, щоб вам було максимально комфортно, щоб ви могли зосередитися на самій логіці.

Принципи, які ми покажемо тут, досить прості. Вам немає про що турбуватися.


Пам'ятаєте свою першу програму? .[#toc-remember-your-first-program]
-------------------------------------------------------------------

Ми не знаємо, якою мовою ви її написали, але якщо це був PHP, то вона, ймовірно, виглядала б приблизно так:

```php
function addition(float $a, float $b): float
{
	return $a + $b;
}

echo addition(23, 1); // відбитки 24
```

Кілька тривіальних рядків коду, але в них заховано стільки ключових понять. Що є змінні. Що код розбивається на менші одиниці, які є функціями, наприклад. Що ми передаємо їм вхідні аргументи, а вони повертають результати. Не вистачає лише умов та циклів.

Те, що ми передаємо функції вхідні дані, а вона повертає результат, - це цілком зрозуміла концепція, яка використовується в інших галузях, наприклад, у математиці.

Функція має сигнатуру, яка складається з її імені, списку параметрів та їх типів і, нарешті, типу значення, що повертається. Як користувачів, нас цікавить сигнатура; зазвичай нам не потрібно нічого знати про внутрішню реалізацію.

Тепер уявіть, що сигнатура функції має такий вигляд:

```php
function addition(float $x): float
```

Додавання з одним параметром? Дивно... А як щодо цього?

```php
function addition(): float
```

Це дійсно дивно, чи не так? Як ви думаєте, як використовується ця функція?

```php
echo addition(); // що він друкує?
```

Дивлячись на такий код, ми розгублюємося. Його не зрозуміє не тільки новачок, але навіть досвідчений програміст не розбереться в такому коді.

Вам цікаво, як така функція виглядатиме всередині? Куди б вона виводила доданки? Напевно, вона брала б їх *якимось чином* сама, ось так:

```php
function addition(): float
{
	$a = Input::get('a');
	$b = Input::get('b');
	return $a + $b;
}
```

Виявляється, в тілі функції є приховані зв'язки з іншими функціями (або статичними методами), і щоб з'ясувати, звідки насправді беруться доданки, треба копати далі.


Але не сюди! .[#toc-not-this-way]
---------------------------------

Дизайн, який нам щойно показали, є сутністю багатьох негативних рис:

- сигнатура функції робила вигляд, що їй не потрібні доданки, що збивало нас з пантелику
- ми поняття не маємо, як змусити функцію обчислювати з двома іншими числами
- довелося зазирнути в код, щоб подивитися, звідки він бере доданки
- ми виявили приховані зв'язки
- щоб повністю зрозуміти, нам потрібно дослідити ці прив'язки також

І чи взагалі функція додавання повинна отримувати вхідні дані? Звичайно, ні.  Її обов'язок - лише додавати.


Ми не хочемо зустрічатися з таким кодом, і ми точно не хочемо його писати. Вихід простий: поверніться до основ і просто використовуйте параметри:


```php
function addition(float $a, float $b): float
{
	return $a + $b;
}
```


Правило №1: Нехай передадуть вам .[#toc-rule-1-let-it-be-passed-to-you]
-----------------------------------------------------------------------

Найважливішим правилом є: **всі дані, які потрібні функціям або класам, повинні бути передані їм**.

Замість того, щоб вигадувати приховані механізми, які допоможуть їм якось дістатися до них самостійно, просто передайте параметри. Ви заощадите час, необхідний для вигадування прихованого способу, який точно не покращить ваш код.

Якщо ви будете дотримуватися цього правила завжди і всюди, ви на шляху до коду без прихованих прив'язок. До коду, який зрозумілий не тільки автору, але й будь-кому, хто його потім прочитає. Де все зрозуміло з сигнатур функцій і класів і не потрібно шукати приховані секрети в реалізації.

Ця техніка має професійну назву **впровадження залежностей**. А дані називаються **залежностями.** Але це проста передача параметрів, не більше того.

.[note]
Будь ласка, не плутайте ін'єкцію залежностей, яка є шаблоном проектування, з "контейнером для ін'єкції залежностей", який є інструментом, це зовсім різні речі. Про контейнери ми поговоримо пізніше.


Від функцій до класів .[#toc-from-functions-to-classes]
-------------------------------------------------------

А як до цього відносяться класи? Клас є більш складною сутністю, ніж проста функція, але правило №1 застосовується і тут. Просто є [більше способів передачі аргументів |passing-dependencies]. Наприклад, так само, як і у випадку з функцією:

```php
class Math
{
	public function addition(float $a, float $b): float
	{
		return $a + $b;
	}
}

$math = new Math;
echo $math->addition(23, 1); // 24
```

Або за допомогою інших методів, або безпосередньо конструктором:

```php
class Addition
{
	public function __construct(
		private float $a,
		private float $b,
	) {
	}

	public function calculate(): float
	{
		return $this->a + $this->b;
	}

}

$addition = new Addition(23, 1);
echo $addition->calculate(); // 24
```

Обидва приклади повністю відповідають принципам ін'єкції залежностей.


Приклади з реального життя .[#toc-real-life-examples]
-----------------------------------------------------

У реальному світі ви не будете писати класи для додавання чисел. Давайте перейдемо до реальних прикладів.

Нехай у нас є клас `Article`, що представляє статтю в блозі:

```php
class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		// зберегти статтю в базі даних
	}
}
```

а використання буде наступним:

```php
$article = new Article;
$article->title = '10 Things You Need to Know About Losing Weight';
$article->content = 'Every year millions of people in ...';
$article->save();
```

Метод `save()` зберігає статтю в таблиці бази даних. Реалізувати це за допомогою [Nette Database |database:] було б дуже просто, якби не одна заковика: звідки `Article` має отримати з'єднання з базою даних, тобто об'єкт класу `Nette\Database\Connection`?

Здається, у нас є багато варіантів. Він може взяти його звідкись зі статичної змінної. Або успадкувати його від класу, який буде забезпечувати з'єднання з базою даних. Або скористатися [синглетоном |global-state#Singleton]. Або так званими фасадами, які використовуються в Laravel:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public int $id;
	public string $title;
	public string $content;

	public function save(): void
	{
		DB::insert(
			'INSERT INTO articles (title, content) VALUES (?, ?)',
			[$this->title, $this->content],
		);
	}
}
```

Чудово, ми вирішили проблему.

Чи ні?

Згадаймо [правило №1: Нехай передадуть вам |#rule #1: Let It Be Passed to You]: всі залежності, які потрібні класу, повинні бути передані йому. Тому що якщо ми цього не зробимо і порушимо це правило, то станемо на шлях брудного коду, повного прихованих прив'язок, незрозумілості, і в результаті отримаємо додаток, який буде складно підтримувати і розвивати.

Користувач класу `Article` поняття не має, де метод `save()` зберігає статтю. У таблиці бази даних? В якій саме, виробничій чи розробницькій? І як це можна змінити?

Щоб знайти застосування методу `save()`, користувачеві доводиться дивитися, як реалізовано метод `DB::insert()`. Отже, він повинен шукати далі, щоб дізнатися, як цей метод забезпечує з'єднання з базою даних. А приховані зв'язки можуть утворювати досить довгий ланцюжок.

Приховані зв'язки, фасади Laravel або статичні змінні ніколи не присутні в чистому, добре спроектованому коді. У чистому і добре спроектованому коді передаються аргументи:

```php
class Article
{
	public function save(Nette\Database\Connection $db): void
	{
		$db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

Ще більш практичним, як ми побачимо далі, є використання конструктора:

```php
class Article
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function save(): void
	{
		$this->db->query('INSERT INTO articles', [
			'title' => $this->title,
			'content' => $this->content,
		]);
	}
}
```

.[note]
Якщо ви досвідчений програміст, ви можете подумати, що `Article` взагалі не повинен мати методу `save()`, це має бути чистий компонент даних, а про зберігання має дбати окремий репозиторій. Це має сенс. Але це вивело б нас далеко за межі теми, якою є ін'єкція залежностей, і спроби навести прості приклади.

Якщо ви збираєтеся написати клас, якому для роботи потрібна база даних, наприклад, не вигадуйте, звідки її взяти, а просто передайте її вам. Можливо, як параметр до конструктора або іншого методу. Оголосіть залежності. Розкрийте їх в API вашого класу. Ви отримаєте зрозумілий і передбачуваний код.

Як щодо цього класу, який реєструє повідомлення про помилки:

```php
class Logger
{
	public function log(string $message)
	{
		$file = LOG_DIR . '/log.txt';
		file_put_contents($file, $message . "\n", FILE_APPEND);
	}
}
```

Як ви думаєте, чи дотримувалися ми [правила №1: Нехай передадуть вам |#rule #1: Let It Be Passed to You]?

Не дотрималися.

Ключова інформація, директорія лог-файлу, *отримується* класом з константи.

Дивіться приклад використання:

```php
$logger = new Logger;
$logger->log('The temperature is 23 °C');
$logger->log('The temperature is 10 °C');
```

Не знаючи реалізації, чи могли б ви відповісти на питання, куди записуються повідомлення? Чи припускаєте ви, що існування константи LOG_DIR є необхідним для її роботи? І чи змогли б ви створити другий екземпляр, який би писав в інше місце? Звичайно, ні.

Давайте виправимо клас:

```php
class Logger
{
	public function __construct(
		private string $file,
	) {
	}

	public function log(string $message): void
	{
		file_put_contents($this->file, $message . "\n", FILE_APPEND);
	}
}
```

Клас тепер набагато зрозуміліший, легше налаштовується і, отже, більш корисний.

```php
$logger = new Logger('/path/to/log.txt');
$logger->log('The temperature is 15 °C');
```


Але мені все одно! .[#toc-but-i-don-t-care]
-------------------------------------------

*"Коли я створюю об'єкт Article і викликаю save(), я не хочу мати справу з базою даних, я просто хочу, щоб він був збережений до тієї, яку я встановив у конфігурації. "*

*"Коли я використовую Logger, я просто хочу, щоб повідомлення було записано, і не хочу розбиратися з тим, куди. Дозвольте використовувати глобальні налаштування. "*

Це правильні зауваження.

Для прикладу візьмемо клас, який розсилає розсилки і записує в журнал, як це відбувалося:

```php
class NewsletterDistributor
{
	public function distribute(): void
	{
		$logger = new Logger(/* ... */);
		try {
			$this->sendEmails();
			$logger->log('Emails have been sent out');

		} catch (Exception $e) {
			$logger->log('An error occurred during the sending');
			throw $e;
		}
	}
}
```

Вдосконалений `Logger`, який більше не використовує константу `LOG_DIR`, вимагає в конструкторі шлях до файлу. Як це вирішити? Класу `NewsletterDistributor` все одно, куди писати повідомлення, він просто хоче їх писати.

Рішення знову ж таки полягає в [правилі №1: Нехай передадуть вам |#rule #1: Let It Be Passed to You]: передайте йому всі дані, які потрібні класу.

Отже, ми передаємо шлях до логу конструктору, який потім використовуємо для створення об'єкта `Logger`?

```php
class NewsletterDistributor
{
	public function __construct(
		private string $file, // НЕ СЮДИ!
	) {
	}

	public function distribute(): void
	{
		$logger = new Logger($this->file);
```

Ні, не так! Тому що шлях **не** належить до даних, які потрібні класу `NewsletterDistributor`; йому потрібен `Logger`. Класу потрібен сам логгер. І це те, що ми передамо:

```php
class NewsletterDistributor
{
	public function __construct(
		private Logger $logger, // ✅
	) {
	}

	public function distribute(): void
	{
		try {
			$this->sendEmails();
			$this->logger->log('Emails have been sent out');

		} catch (Exception $e) {
			$this->logger->log('An error occurred during the sending');
			throw $e;
		}
	}
}
```

Тепер з сигнатур класу `NewsletterDistributor` зрозуміло, що ведення логів є частиною його функціоналу. І задача заміни логгера на інший, можливо, з метою тестування, є досить тривіальною.
Більше того, якщо буде змінено конструктор класу `Logger`, то це ніяк не вплине на наш клас.


Правило №2: Бери своє .[#toc-rule-2-take-what-is-yours]
-------------------------------------------------------

Не вводьте себе в оману і не дозволяйте передавати вам параметри ваших залежностей. Передавайте залежності безпосередньо.

Це зробить код, що використовує інші об'єкти, повністю незалежним від змін у їхніх конструкторах. Його API буде більш коректним. І найголовніше, буде тривіально поміняти ці залежності на інші.


Новий член родини .[#toc-a-new-member-of-the-family]
----------------------------------------------------

Команда розробників вирішила створити другий логгер, який записуватиметься до бази даних. Тому ми створюємо клас `DatabaseLogger`. Отже, у нас є два класи, `Logger` і `DatabaseLogger`, один пише у файл, інший - в базу даних... Вам не здається, що в цій назві є щось дивне?
Чи не краще було б перейменувати `Logger` в `FileLogger`? Звичайно, краще.

Але давайте зробимо це розумно. Ми створимо інтерфейс під оригінальною назвою:

```php
interface Logger
{
	function log(string $message): void;
}
```

...який будуть реалізовувати обидва логери:

```php
class FileLogger implements Logger
// ...

class DatabaseLogger implements Logger
// ...
```

Таким чином, у решті коду, де використовується логгер, нічого не потрібно буде змінювати. Наприклад, конструктор класу `NewsletterDistributor`, як і раніше, буде щасливий отримати в якості параметра `Logger`. І від нас буде залежати, який саме екземпляр ми йому передамо.

**Ось чому ми ніколи не додаємо до імен інтерфейсів суфікс `Interface` або префікс `I`.** Інакше неможливо було б так гарно розробляти код.


Х'юстон, у нас проблема .[#toc-houston-we-have-a-problem]
---------------------------------------------------------

У той час як у всьому додатку ми можемо задовольнитися одним екземпляром логгера, будь то файл або база даних, і просто передавати його скрізь, де щось реєструється, у випадку з класом `Article` все зовсім інакше. Фактично, ми створюємо його екземпляри за потребою, можливо, декілька разів. Як працювати з прив'язкою до бази даних у його конструкторі?

Як приклад, ми можемо використати контролер, який повинен зберігати статтю в базі даних після відправлення форми:

```php
class EditController extends Controller
{
	public function formSubmitted($data)
	{
		$article = new Article(/* ... */);
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

Прямо пропонується можливе рішення: передати об'єкт бази даних у конструкторі за адресою `EditController` і використовувати `$article = new Article($this->db)`.

Як і у попередньому випадку з `Logger` та шляхом до файлу, це не є правильним підходом. База даних є залежністю не від `EditController`, а від `Article`. Тому передача бази даних суперечить [правилу №2: Бери своє |#rule #2: take what is yours]. Коли змінюється конструктор класу `Article` (додається новий параметр), код у всіх місцях, де створюються екземпляри, також потрібно буде модифікувати. Уффф.

Х'юстон, що ти пропонуєш?


Правило №3: Нехай завод розбирається з цим .[#toc-rule-3-let-the-factory-handle-it]
-----------------------------------------------------------------------------------

Видаляючи приховані прив'язки і передаючи всі залежності в якості аргументів, ми отримуємо більш гнучкі та конфігуровані класи. А отже, нам потрібно щось інше для створення та налаштування цих більш гнучких класів. Назвемо це фабриками.

Емпіричне правило: якщо клас має залежності, залиште створення їх екземплярів фабриці.

Фабрики є розумнішою заміною оператору `new` у світі ін'єкції залежностей.

.[note]
Будь ласка, не плутайте з паттерном проектування *factory method*, який описує специфічний спосіб використання фабрик і не має відношення до цієї теми.


Фабрика .[#toc-factory]
-----------------------

Фабрика - це метод або клас, який створює та налаштовує об'єкти. Ми називаємо `Article` виробляючий клас `ArticleFactory` і це може виглядати так:

```php
class ArticleFactory
{
	public function __construct(
		private Nette\Database\Connection $db,
	) {
	}

	public function create(): Article
	{
		return new Article($this->db);
	}
}
```

Його використання у контролері буде наступним:

```php
class EditController extends Controller
{
	public function __construct(
		private ArticleFactory $articleFactory,
	) {
	}

	public function formSubmitted($data)
	{
		// дозволити фабриці створити об'єкт
		$article = $this->articleFactory->create();
		$article->title = $data->title;
		$article->content = $data->content;
		$article->save();
	}
}
```

У цей момент, коли сигнатура конструктора класу `Article` змінюється, єдиною частиною коду, яка повинна відреагувати, є сама фабрика `ArticleFactory`. Будь-який інший код, що працює з об'єктами `Article`, наприклад, `EditController`, не буде зачеплений.

Можливо, ви зараз постукуєте себе по лобі, задаючись питанням, чи допомогли ми собі взагалі. Кількість коду зросла, і все це починає виглядати підозріло складним.

Не хвилюйтеся, скоро ми дійдемо до контейнера Nette DI. І він має кілька козирів у рукаві, які зроблять створення додатків з використанням ін'єкції залежностей надзвичайно простим. Наприклад, замість класу `ArticleFactory` буде достатньо [написати простий інтерфейс |factory]:

```php
interface ArticleFactory
{
	function create(): Article;
}
```

Але ми забігаємо наперед, зачекайте :-)


Резюме .[#toc-summary]
----------------------

На початку цієї глави ми обіцяли показати вам спосіб проектування чистого коду. Просто дайте класам

- [залежності, які їм потрібні |#Rule #1: Let It Be Passed to You]
- [а не ті, які їм безпосередньо |#Rule #2: Take What Is Yours]не потрібні
- [і що об'єкти з залежностями краще створювати на фабриках |#Rule #3: Let the Factory Handle it]

На перший погляд може здатися, що це не так, але ці три правила мають далекосяжні наслідки. Вони призводять до радикально іншого погляду на дизайн коду. Чи варто воно того? Програмісти, які відкинули старі звички і почали послідовно використовувати ін'єкцію залежностей, вважають це поворотним моментом у своєму професійному житті. Це відкрило їм світ зрозумілих і стійких додатків.

Але що, якщо код не використовує ін'єкцію залежностей послідовно? Що, якщо він побудований на статичних методах або синглетонах? Чи виникнуть з цим проблеми? Так, [і дуже суттє |global-state]ві.
