√âtat global et singletons
*************************

.[perex]
Avertissement : Les constructions suivantes sont des sympt√¥mes d'un code mal con√ßu :

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ou `static::$var`

Rencontrez-vous l'une de ces constructions dans votre code ? Si c'est le cas, vous avez la possibilit√© de l'am√©liorer. Vous pouvez penser qu'il s'agit de constructions courantes, souvent observ√©es dans des exemples de solutions de diverses biblioth√®ques et frameworks. Si c'est le cas, la conception de leur code est d√©fectueuse.

Nous ne parlons pas ici de puret√© acad√©mique. Toutes ces constructions ont une chose en commun : elles utilisent un √©tat global. Et cela a un impact destructeur sur la qualit√© du code. Les classes sont trompeuses quant √† leurs d√©pendances. Le code devient impr√©visible. Cela perturbe les d√©veloppeurs et r√©duit leur efficacit√©.

Dans ce chapitre, nous expliquerons pourquoi c'est le cas et comment √©viter l'√©tat global.


Interconnexion globale .[#toc-global-interlinking]
--------------------------------------------------

Dans un monde id√©al, un objet ne devrait communiquer qu'avec les objets qui lui ont √©t√© [directement transmis |passing-dependencies]. Si je cr√©e deux objets `A` et `B` et que je ne leur passe jamais de r√©f√©rence, ni `A` ni `B` ne peuvent acc√©der √† l'√©tat de l'autre ou le modifier. Il s'agit d'une propri√©t√© hautement souhaitable du code. C'est un peu comme si vous aviez une batterie et une ampoule ; l'ampoule ne s'allumera pas tant que vous ne l'aurez pas reli√©e √† la batterie par un fil.

Cependant, cela n'est pas vrai pour les variables globales (statiques) ou les singletons. L'objet `A` pourrait acc√©der sans fil √† l'objet `C` et le modifier sans aucun passage de r√©f√©rence, en appelant `C::changeSomething()`. Si l'objet `B` acc√®de √©galement √† la variable globale `C`, alors `A` et `B` peuvent s'influencer mutuellement par l'interm√©diaire de `C`.

L'utilisation de variables globales introduit une nouvelle forme de couplage "sans fil" qui n'est pas visible de l'ext√©rieur. Cela cr√©e un √©cran de fum√©e qui complique la compr√©hension et l'utilisation du code. Pour vraiment comprendre les d√©pendances, les d√©veloppeurs doivent lire chaque ligne du code source, au lieu de se contenter de se familiariser avec les interfaces des classes. De plus, cet enchev√™trement n'est absolument pas n√©cessaire. L'√©tat global est utilis√© parce qu'il est facilement accessible de partout et permet, par exemple, d'√©crire dans une base de donn√©es par le biais d'une m√©thode globale (statique) `DB::insert()`. Cependant, comme nous le verrons, l'avantage qu'il offre est minime, tandis que les complications qu'il introduit sont graves.

.[note]
En termes de comportement, il n'y a pas de diff√©rence entre une variable globale et une variable statique. Elles sont tout aussi nuisibles l'une que l'autre.


L'action sinistre √† distance .[#toc-the-spooky-action-at-a-distance]
--------------------------------------------------------------------

"L'action sinistre √† distance" : c'est ainsi qu'Albert Einstein a appel√© un ph√©nom√®ne de la physique quantique qui lui a donn√© la chair de poule en 1935.
Il s'agit de l'intrication quantique, dont la particularit√© est que lorsque vous mesurez une information sur une particule, vous affectez imm√©diatement une autre particule, m√™me si elles sont distantes de millions d'ann√©es-lumi√®re.
Ce qui semble violer la loi fondamentale de l'univers selon laquelle rien ne peut voyager plus vite que la lumi√®re.

Dans le monde des logiciels, nous pouvons parler d'une "action √©trange √† distance", une situation dans laquelle nous ex√©cutons un processus que nous pensons isol√© (parce que nous ne lui avons transmis aucune r√©f√©rence), mais des interactions inattendues et des changements d'√©tat se produisent dans des endroits √©loign√©s du syst√®me dont nous n'avons pas parl√© √† l'objet. Cela ne peut se produire qu'√† travers l'√©tat global.

Imaginez que vous rejoignez une √©quipe de d√©veloppement de projet qui dispose d'une base de code importante et mature. Votre nouveau chef vous demande d'impl√©menter une nouvelle fonctionnalit√© et, comme tout bon d√©veloppeur, vous commencez par √©crire un test. Mais comme vous √™tes nouveau dans le projet, vous faites beaucoup de tests exploratoires du type "que se passe-t-il si j'appelle cette m√©thode". Et vous essayez d'√©crire le test suivant :

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // votre num√©ro de carte
	$cc->charge(100);
}
```

Vous ex√©cutez le code, peut-√™tre plusieurs fois, et apr√®s un certain temps, vous remarquez sur votre t√©l√©phone des notifications de la banque indiquant qu'√† chaque fois que vous l'ex√©cutez, 100 $ ont √©t√© d√©bit√©s sur votre carte de cr√©dit ü§¶‚Äç‚ôÇÔ∏è.

Comment diable le test a-t-il pu provoquer un d√©bit r√©el ? Il n'est pas facile d'op√©rer avec une carte de cr√©dit. Vous devez interagir avec un service web tiers, vous devez conna√Ætre l'URL de ce service web, vous devez vous connecter, et ainsi de suite.
Aucune de ces informations n'est incluse dans le test. Pire encore, vous ne savez m√™me pas o√π ces informations sont pr√©sentes, et donc comment simuler les d√©pendances externes pour que chaque ex√©cution n'entra√Æne pas une nouvelle facturation de 100 dollars. Et en tant que nouveau d√©veloppeur, comment √©tiez-vous cens√© savoir que ce que vous √©tiez sur le point de faire vous ferait perdre 100 dollars ?

C'est une action effrayante √† distance !

Vous n'avez pas d'autre choix que de fouiller dans une grande quantit√© de code source, en demandant √† des coll√®gues plus anciens et plus exp√©riment√©s, jusqu'√† ce que vous compreniez comment fonctionnent les connexions dans le projet.
Cela est d√ª au fait qu'en regardant l'interface de la classe `CreditCard`, vous ne pouvez pas d√©terminer l'√©tat global qui doit √™tre initialis√©. M√™me en regardant le code source de la classe, vous ne pourrez pas savoir quelle m√©thode d'initialisation appeler. Au mieux, vous pouvez trouver la variable globale √† laquelle on acc√®de et essayer de deviner comment l'initialiser √† partir de l√†.

Les classes d'un tel projet sont des menteurs pathologiques. La carte de paiement pr√©tend que vous pouvez simplement l'instancier et appeler la m√©thode `charge()`. Cependant, elle interagit secr√®tement avec une autre classe, `PaymentGateway`. M√™me son interface indique qu'elle peut √™tre initialis√©e de mani√®re ind√©pendante, mais en r√©alit√©, elle tire les informations d'identification d'un fichier de configuration et ainsi de suite.
Il est clair pour les d√©veloppeurs qui ont √©crit ce code que `CreditCard` a besoin de `PaymentGateway`. Ils ont √©crit le code de cette fa√ßon. Mais pour toute personne nouvelle dans le projet, c'est un myst√®re complet et cela entrave l'apprentissage.

Comment rem√©dier √† cette situation ? Facile. **Laissez l'API d√©clarer les d√©pendances.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Remarquez comment les relations au sein du code deviennent soudainement √©videntes. En d√©clarant que la m√©thode `charge()` a besoin de `PaymentGateway`, vous n'avez pas besoin de demander √† qui que ce soit comment le code est interd√©pendant. Vous savez que vous devez cr√©er une instance de cette m√©thode, et lorsque vous essayez de le faire, vous vous heurtez au fait que vous devez fournir des param√®tres d'acc√®s. Sans eux, le code ne fonctionnerait m√™me pas.

Et surtout, vous pouvez maintenant simuler la passerelle de paiement afin de ne pas √™tre factur√© 100 $ √† chaque fois que vous ex√©cutez un test.

L'√©tat global permet √† vos objets d'acc√©der secr√®tement √† des √©l√©ments qui ne sont pas d√©clar√©s dans leurs API et, par cons√©quent, fait de vos API des menteurs pathologiques.

Vous n'y avez peut-√™tre jamais pens√© de cette fa√ßon, mais chaque fois que vous utilisez l'√©tat global, vous cr√©ez des canaux de communication sans fil secrets. Les actions √† distance effrayantes obligent les d√©veloppeurs √† lire chaque ligne de code pour comprendre les interactions potentielles, r√©duisent la productivit√© des d√©veloppeurs et d√©sorientent les nouveaux membres de l'√©quipe.
Si vous √™tes celui qui a cr√©√© le code, vous connaissez les v√©ritables d√©pendances, mais tous ceux qui viennent apr√®s vous ne savent rien.

N'√©crivez pas de code qui utilise l'√©tat global, pr√©f√©rez passer les d√©pendances. C'est l'injection de d√©pendances.


La fragilit√© de l'√âtat mondial .[#toc-brittleness-of-the-global-state]
----------------------------------------------------------------------

Dans le code qui utilise un √©tat global et des singletons, on ne sait jamais avec certitude quand et par qui cet √©tat a √©t√© modifi√©. Ce risque est d√©j√† pr√©sent √† l'initialisation. Le code suivant est cens√© cr√©er une connexion √† une base de donn√©es et initialiser la passerelle de paiement, mais il continue √† lancer une exception et il est extr√™mement fastidieux d'en trouver la cause :

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Vous devez parcourir le code en d√©tail pour d√©couvrir que l'objet `PaymentGateway` acc√®de √† d'autres objets sans fil, dont certains n√©cessitent une connexion √† une base de donn√©es. Ainsi, vous devez initialiser la base de donn√©es avant `PaymentGateway`. Cependant, l'√©cran de fum√©e de l'√©tat global vous cache cela. Combien de temps gagneriez-vous si l'API de chaque classe ne mentait pas et ne d√©clarait pas ses d√©pendances ?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Un probl√®me similaire se pose lors de l'utilisation de l'acc√®s global √† une connexion de base de donn√©es :

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Lorsque l'on appelle la m√©thode `save()`, on ne sait pas si une connexion √† la base de donn√©es a d√©j√† √©t√© cr√©√©e et qui est responsable de sa cr√©ation. Par exemple, si nous voulions modifier la connexion √† la base de donn√©es √† la vol√©e, peut-√™tre √† des fins de test, nous devrions probablement cr√©er des m√©thodes suppl√©mentaires telles que `DB::reconnect(...)` ou `DB::reconnectForTest()`.

Prenons un exemple :

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Comment pouvons-nous √™tre s√ªrs que la base de donn√©es de test est r√©ellement utilis√©e lors de l'appel √† `$article->save()`? Et si la m√©thode `Foo::doSomething()` modifiait la connexion globale √† la base de donn√©es ? Pour le savoir, nous devrions examiner le code source de la classe `Foo` et probablement de nombreuses autres classes. Toutefois, cette approche ne fournirait qu'une r√©ponse √† court terme, car la situation pourrait changer √† l'avenir.

Et si nous d√©placions la connexion √† la base de donn√©es vers une variable statique √† l'int√©rieur de la classe `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Cela ne change rien du tout. Le probl√®me est un √©tat global et la classe dans laquelle il se cache n'a pas d'importance. Dans ce cas, comme dans le pr√©c√©dent, nous n'avons aucune id√©e de la base de donn√©es qui est √©crite lorsque la m√©thode `$article->save()` est appel√©e. N'importe qui √† l'extr√©mit√© distante de l'application pourrait changer la base de donn√©es √† tout moment en utilisant `Article::setDb()`. Sous nos yeux.

L'√©tat global rend notre application **extr√™mement fragile**.

Cependant, il existe un moyen simple de r√©soudre ce probl√®me. Il suffit de faire en sorte que l'API d√©clare des d√©pendances pour garantir une bonne fonctionnalit√©.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Cette approche √©limine le souci de modifications cach√©es et inattendues des connexions √† la base de donn√©es. Maintenant, nous sommes s√ªrs de l'endroit o√π l'article est stock√© et aucune modification du code dans une autre classe sans rapport ne peut plus changer la situation. Le code n'est plus fragile, mais stable.

N'√©crivez pas de code qui utilise l'√©tat global, pr√©f√©rez le passage des d√©pendances. Ainsi, l'injection de d√©pendances.


Singleton .[#toc-singleton]
---------------------------

Le singleton est un mod√®le de conception qui, selon la [d√©finition de |https://en.wikipedia.org/wiki/Singleton_pattern] la c√©l√®bre publication Gang of Four, limite une classe √† une seule instance et lui offre un acc√®s global. L'impl√©mentation de ce patron ressemble g√©n√©ralement au code suivant :

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// et d'autres m√©thodes qui ex√©cutent les fonctions de la classe
}
```

Malheureusement, le singleton introduit un √©tat global dans l'application. Et comme nous l'avons montr√© ci-dessus, l'√©tat global n'est pas souhaitable. C'est pourquoi le singleton est consid√©r√© comme un anti-mod√®le.

N'utilisez pas les singletons dans votre code et remplacez-les par d'autres m√©canismes. Vous n'avez vraiment pas besoin de singletons. Toutefois, si vous devez garantir l'existence d'une seule instance d'une classe pour l'ensemble de l'application, confiez cette t√¢che au [conteneur DI |container].
Ainsi, cr√©ez un singleton d'application, ou service. Cela emp√™chera la classe de fournir sa propre unicit√© (c'est-√†-dire qu'elle n'aura pas de m√©thode `getInstance()` et de variable statique) et n'ex√©cutera que ses fonctions. Ainsi, elle cessera de violer le principe de responsabilit√© unique.


√âtat global versus tests .[#toc-global-state-versus-tests]
----------------------------------------------------------

Lorsque nous √©crivons des tests, nous supposons que chaque test est une unit√© isol√©e et qu'aucun √©tat externe n'y entre. Et aucun √©tat ne quitte les tests. Lorsqu'un test se termine, tout √©tat associ√© au test devrait √™tre supprim√© automatiquement par le ramasse-miettes. Cela rend les tests isol√©s. Par cons√©quent, nous pouvons ex√©cuter les tests dans n'importe quel ordre.

Cependant, si des √©tats/singletons globaux sont pr√©sents, toutes ces belles hypoth√®ses s'effondrent. Un √©tat peut entrer et sortir d'un test. Soudainement, l'ordre des tests peut avoir de l'importance.

Pour tester les singletons, les d√©veloppeurs doivent souvent assouplir leurs propri√©t√©s, peut-√™tre en permettant √† une instance d'√™tre remplac√©e par une autre. De telles solutions sont, au mieux, des bidouillages qui produisent un code difficile √† maintenir et √† comprendre. Tout test ou m√©thode `tearDown()` qui affecte un √©tat global doit annuler ces changements.

L'√©tat global est le plus gros casse-t√™te des tests unitaires !

Comment rem√©dier √† cette situation ? Facile. N'√©crivez pas de code qui utilise des singletons, pr√©f√©rez passer des d√©pendances. C'est-√†-dire l'injection de d√©pendances.


Constantes globales .[#toc-global-constants]
--------------------------------------------

L'√©tat global ne se limite pas √† l'utilisation des singletons et des variables statiques, mais peut √©galement s'appliquer aux constantes globales.

Les constantes dont la valeur ne nous fournit aucune information nouvelle (`M_PI`) ou utile (`PREG_BACKTRACK_LIMIT_ERROR`) sont clairement OK.
√Ä l'inverse, les constantes qui servent √† faire passer des informations *sans fil* √† l'int√©rieur du code ne sont rien d'autre qu'une d√©pendance cach√©e. Comme `LOG_FILE` dans l'exemple suivant.
L'utilisation de la constante `FILE_APPEND` est parfaitement correcte.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Dans ce cas, nous devons d√©clarer le param√®tre dans le constructeur de la classe `Foo` pour qu'il fasse partie de l'API :

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Nous pouvons maintenant transmettre des informations sur le chemin d'acc√®s au fichier de journalisation et le modifier facilement si n√©cessaire, ce qui facilite les tests et la maintenance du code.


Fonctions globales et m√©thodes statiques .[#toc-global-functions-and-static-methods]
------------------------------------------------------------------------------------

Nous tenons √† souligner que l'utilisation de m√©thodes statiques et de fonctions globales n'est pas probl√©matique en soi. Nous avons expliqu√© le caract√®re inappropri√© de l'utilisation de `DB::insert()` et de m√©thodes similaires, mais il s'agissait toujours d'un √©tat global stock√© dans une variable statique. La m√©thode `DB::insert()` n√©cessite l'existence d'une variable statique car elle stocke la connexion √† la base de donn√©es. Sans cette variable, il serait impossible de mettre en ≈ìuvre la m√©thode.

L'utilisation de m√©thodes et de fonctions statiques d√©terministes, telles que `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` et bien d'autres, est parfaitement compatible avec l'injection de d√©pendances. Ces fonctions renvoient toujours les m√™mes r√©sultats √† partir des m√™mes param√®tres d'entr√©e et sont donc pr√©visibles. Elles n'utilisent pas d'√©tat global.

Cependant, il existe des fonctions en PHP qui ne sont pas d√©terministes. C'est le cas, par exemple, de la fonction `htmlspecialchars()`. Son troisi√®me param√®tre, `$encoding`, s'il n'est pas sp√©cifi√©, prend par d√©faut la valeur de l'option de configuration `ini_get('default_charset')`. Il est donc recommand√© de toujours sp√©cifier ce param√®tre pour √©viter un √©ventuel comportement impr√©visible de la fonction. C'est ce que fait syst√©matiquement Nette.

Certaines fonctions, telles que `strtolower()`, `strtoupper()`, et autres, ont eu un comportement non d√©terministe dans un pass√© r√©cent et ont d√©pendu du param√®tre `setlocale()`. Cela a caus√© de nombreuses complications, le plus souvent en travaillant avec la langue turque.
En effet, la langue turque fait la distinction entre les majuscules et les minuscules `I` avec et sans point. Ainsi, `strtolower('I')` renvoyait le caract√®re `ƒ±` et `strtoupper('i')` renvoyait le caract√®re `ƒ∞`, ce qui conduisait les applications √† provoquer un certain nombre d'erreurs myst√©rieuses.
Toutefois, ce probl√®me a √©t√© corrig√© dans la version 8.2 de PHP et les fonctions ne d√©pendent plus de la locale.

C'est un bel exemple de la mani√®re dont l'√©tat global a tourment√© des milliers de d√©veloppeurs dans le monde. La solution a √©t√© de le remplacer par l'injection de d√©pendances.


Quand est-il possible d'utiliser l'√©tat global ? .[#toc-when-is-it-possible-to-use-global-state]
------------------------------------------------------------------------------------------------

Dans certaines situations sp√©cifiques, il est possible d'utiliser l'√©tat global. Par exemple, lorsque vous d√©boguez un code et que vous avez besoin d'extraire la valeur d'une variable ou de mesurer la dur√©e d'une partie sp√©cifique du programme. Dans de tels cas, qui concernent des actions temporaires qui seront ult√©rieurement supprim√©es du code, il est l√©gitime d'utiliser un dumper ou un chronom√®tre disponible globalement. Ces outils ne font pas partie de la conception du code.

Un autre exemple est celui des fonctions permettant de travailler avec des expressions r√©guli√®res `preg_*`, qui stockent en interne les expressions r√©guli√®res compil√©es dans un cache statique en m√©moire. Lorsque vous appelez la m√™me expression r√©guli√®re plusieurs fois dans diff√©rentes parties du code, elle n'est compil√©e qu'une seule fois. Le cache permet de gagner en performance et est totalement invisible pour l'utilisateur, de sorte qu'une telle utilisation peut √™tre consid√©r√©e comme l√©gitime.


R√©sum√© .[#toc-summary]
----------------------

Nous avons montr√© pourquoi il est logique

1) Supprimer toutes les variables statiques du code
2) D√©clarer les d√©pendances
3) Et utiliser l'injection de d√©pendances

Lorsque vous envisagez la conception d'un code, gardez √† l'esprit que chaque `static $foo` repr√©sente un probl√®me. Pour que votre code soit un environnement respectueux de l'injection de d√©pendances, il est essentiel d'√©radiquer compl√®tement l'√©tat global et de le remplacer par l'injection de d√©pendances.

Au cours de ce processus, vous constaterez peut-√™tre que vous devez diviser une classe parce qu'elle a plus d'une responsabilit√©. Ne vous en pr√©occupez pas ; efforcez-vous de respecter le principe de la responsabilit√© unique.

*Je tiens √† remercier Mi≈°ko Hevery, dont les articles tels que [Flaw : Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] constituent la base de ce chapitre*.
