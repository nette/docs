Функции Latte
*************

.[perex]
В дополнение к обычным функциям PHP, вы можете использовать их в шаблонах.

.[table-latte-filters]
| `clamp` | [зажимает значение в диапазон |#clamp]
| `divisibleBy`| [проверяет, делится ли переменная на число |#divisibleBy]
| `even` | [проверяет, является ли данное число четным |#even]
| `first` | [возвращает первый элемент массива или символ строки |#first]
| `last` | [возвращает последний элемент массива или символ строки |#last]
| `odd` | [проверяет, является ли данное число нечетным |#odd]
| `slice` | [извлекает фрагмент массива или строки |#slice]


Использование .[#toc-usage]
===========================

Функции используются так же, как и обычные функции PHP, и могут быть использованы во всех выражениях:

```latte
<p>{clamp($num, 1, 100)}</p>

{if odd($num)} ... {/if}
```

[Пользовательские функции |extending-latte#Functions] могут быть зарегистрированы таким образом:

```php
$latte = new Latte\Engine;
$latte->addFunction('shortify', fn(string $s, int $len = 10) => mb_substr($s, 0, $len));
```

Мы используем его в шаблоне следующим образом:

```latte
<p>{shortify($text)}</p>
<p>{shortify($text, 100)}</p>
```


Функции .[#toc-functions]
=========================


clamp(int|float $value, int|float $min, int|float $max): int|float .[method]{data-version:2.9}
----------------------------------------------------------------------------------------------
Возвращает значение, зажатое во включительно диапазоне min и max.

```latte
{=clamp($level, 0, 255)}
```

См. также [зажим фильтра |filters#clamp]:


divisibleBy(int $value, int $by): bool .[method]{data-version:2.10.2}
---------------------------------------------------------------------
Проверяет, делится ли переменная на число.

```latte
{if divisibleBy($num, 5)} ... {/if}
```


even(int $value): bool .[method]{data-version:2.10.2}
-----------------------------------------------------
Проверяет, является ли заданное число четным.

```latte
{if even($num)} ... {/if}
```


first(string|array $value): mixed .[method]{data-version:2.10.2}
----------------------------------------------------------------
Возвращает первый элемент массива или символ строки:

```latte
{=first([1, 2, 3, 4])}    {* outputs 1 *}
{=first('abcd')}          {* outputs 'a' *}
```

См. также [last |#last], [filter first |filters#first].


last(string|array $value): mixed .[method]{data-version:2.10.2}
---------------------------------------------------------------
Возвращает последний элемент массива или символ строки:

```latte
{=last([1, 2, 3, 4])}    {* outputs 4 *}
{=last('abcd')}          {* outputs 'd' *}
```

См. также [first |#first], [filter last |filters#last].


odd(int $value): bool .[method]{data-version:2.10.2}
----------------------------------------------------
Проверяет, является ли заданное число нечетным.

```latte
{if odd($num)} ... {/if}
```


slice(string|array $value, int $start, int $length=null, bool $preserveKeys=false): string|array .[method]{data-version:2.10.2}
-------------------------------------------------------------------------------------------------------------------------------
Извлекает фрагмент массива или строки.

```latte
{=slice('hello', 1, 2)}           {* outputs 'el' *}
{=slice(['a', 'b', 'c'], 1, 2)}   {* outputs ['b', 'c'] *}
```

Фильтр срезов работает как функция `array_slice` PHP для массивов и `mb_substr` для строк с возвратом к `iconv_substr` в режиме UTF-8.

Если start неотрицательно, то последовательность начнется с этого начала в переменной. Если start отрицательно, то последовательность начнется на таком-то расстоянии от конца переменной.

Если задана длина и она положительна, то последовательность будет содержать до этого количества элементов. Если переменная короче длины, то будут присутствовать только доступные элементы переменной. Если длина задана и отрицательна, то последовательность остановится на столько элементов от конца переменной. Если длина не указана, то последовательность будет содержать все элементы от смещения до конца переменной.

Filter по умолчанию переупорядочивает и сбрасывает ключи целочисленного массива. Это поведение можно изменить, установив preserveKeys в true. Строковые ключи всегда сохраняются, независимо от этого параметра.
