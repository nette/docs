Словник термінів
****************


AJAX
----
Asynchronous JavaScript and XML - технологія обміну інформацією між клієнтом і сервером за допомогою протоколу HTTP без необхідності перезавантаження всієї сторінки при кожному запиті. Хоча з назви може здатися, що дані надсилаються лише у форматі XML, зазвичай використовується також формат [#JSON].


Дія presenter'а
---------------
Логічна частина presenter'а, яка виконує одну дію. Наприклад, відображає сторінку продукту, виходить з системи користувача тощо. Один presenter може мати кілька дій.


BOM
---
Так звана *byte order mark* - це спеціальний перший символ у файлі, який використовується як індикатор порядку байтів у кодуванні. Деякі редактори вставляють його у файли. Він практично невидимий, але спричиняє проблеми з надсиланням виводу та заголовків з PHP. Для масового видалення можна використовувати [Code Checker|code-checker:].


Controller
----------
Контролер, який обробляє запити користувача і на їх основі викликає відповідну логіку програми (тобто [#модель]) і потім запитує [#представлення] для відображення даних. Аналогом контролерів у Nette Framework є [presenter'и |#Presenter].


Cross-Site Scripting (XSS)
--------------------------
Cross-Site Scripting - це метод порушення веб-сайтів, що використовує необроблені вихідні дані. Зловмисник може вставити свій власний код на сторінку, тим самим змінивши її або навіть отримавши конфіденційні дані відвідувачів. Захиститися від XSS можна лише послідовною та коректною обробкою всіх рядків.

Nette Framework пропонує революційну технологію [Context-Aware Escaping |latte:safety-first#Контекстно-залежне екранування], яка назавжди позбавить вас ризику Cross-Site Scripting. Вона автоматично обробляє всі вихідні дані, тому кодер не може щось забути.


Cross-Site Request Forgery (CSRF)
---------------------------------
Атака Cross-Site Request Forgery полягає в тому, що зловмисник заманює жертву на сторінку, яка непомітно виконує запит у браузері жертви до сервера, на якому жертва авторизована, і сервер вважає, що запит був виконаний жертвою за власним бажанням. Таким чином, під ідентичністю жертви виконується певна дія, про яку вона не знає. Це може бути зміна або видалення даних, надсилання повідомлення тощо.

Nette Framework **автоматично захищає форми та сигнали в presenter'ах** від цього типу атак. Це робиться шляхом запобігання їх надсиланню або виклику з іншого домену.


Dependency Injection
--------------------
Dependency Injection (DI) - це патерн проектування, який визначає, як відокремити створення об'єктів від їхніх залежностей. Тобто клас не відповідає за створення або ініціалізацію своїх залежностей, а натомість ці залежності надаються йому зовнішнім кодом (це може бути [DI-контейнер |#Dependency Injection контейнер]). Перевага полягає в тому, що це забезпечує більшу гнучкість коду, кращу зрозумілість та легше тестування програми, оскільки залежності легко замінюються та ізолюються від інших частин коду. Більше в розділі [Що таке Dependency Injection? |dependency-injection:introduction]


Dependency Injection контейнер
------------------------------
Dependency Injection контейнер (також DI-контейнер або IoC-контейнер) - це інструмент, який забезпечує створення та керування залежностями в додатку (або [сервісами |#Сервіс]). Контейнер зазвичай має конфігурацію, яка визначає, які класи залежать від інших класів, які конкретні реалізації залежностей слід використовувати та як ці залежності мають створюватися. Потім контейнер створює ці об'єкти та надає їх класам, які їх потребують. Більше в розділі [Що таке DI-контейнер? |dependency-injection:container]


Екранування
-----------
Екранування - це перетворення символів, що мають спеціальне значення в даному контексті, на інші відповідні послідовності. Приклад: у рядок, обмежений лапками, ми хочемо записати лапки. Оскільки лапки мають спеціальне значення в контексті рядка, і їх просте написання було б розцінено як завершення рядка, їх потрібно записати іншою відповідною послідовністю. Якою саме, визначають правила контексту.


Фільтр (раніше helper)
----------------------
У шаблонах під терміном [фільтр |latte:syntax#Фільтри] зазвичай розуміють функцію, яка допомагає змінити або переформатувати дані до кінцевого вигляду. Шаблони мають кілька [стандартних фільтрів |latte:filters].


Інвалідація
-----------
Повідомлення [сніпету |#Сніпет] про необхідність перемалювання. В іншому значенні також видалення вмісту кешу.


JSON
----
Формат обміну даними, що базується на синтаксисі JavaScript (є його підмножиною). Точну специфікацію можна знайти на сторінці www.json.org.


Компонент
---------
Повторно використовувана частина програми. Це може бути візуальна частина сторінки, як описано в розділі [Пишемо компоненти |application:components], або під терміном компонент також розуміють клас [Component |component-model:] (такий компонент не обов'язково має бути візуальним).


Керуючі символи
---------------
Керуючі символи - це невидимі символи, які можуть зустрічатися в тексті та іноді спричиняти проблеми. Для їх масового видалення з файлів можна використовувати [Code Checker|code-checker:], а для видалення зі змінної - функцію [Strings::normalize() |utils:strings#normalize].


Події (události)
----------------
Подія - це очікувана ситуація в об'єкті, при настанні якої викликаються так звані обробники (handler), тобто callback-функції, що реагують на подію ("приклад":https://gist.github.com/dg/332cdd51bdf7d66a6d8003b134508a38). Подією може бути, наприклад, відправка форми, вхід користувача тощо. Події є формою *Inversion of Control*.

Наприклад, вхід користувача відбувається в методі `Nette\Security\User::login()`. Об'єкт `User` має публічну змінну `$onLoggedIn`, яка є масивом, до якого будь-хто може додати callback. У момент входу користувача метод `login()` викликає всі callback-функції в масиві. Назва змінної у форматі `onXyz` є конвенцією, що використовується у всьому Nette.


Latte
-----
Одна з найпрогресивніших [систем шаблонів |latte:].


Модель
------
Модель - це дані та, перш за все, функціональна основа всієї програми. Вона містить всю логіку програми (також використовується термін бізнес-логіка). Це **M** з **M**VC або MVP. Будь-яка дія користувача (вхід, додавання товару в кошик, зміна значення в базі даних) є дією моделі.

Модель керує своїм внутрішнім станом і надає зовнішньому світу фіксований інтерфейс. Викликаючи функції цього інтерфейсу, ми можемо дізнаватися або змінювати її стан. Модель не знає про існування [#представлення] або [контролера |#Controller].


Model-View-Controller
---------------------
Архітектура програмного забезпечення, яка виникла з потреби відокремити код обробки ([контролер |#Controller]) від коду логіки програми ([#модель]) та коду відображення даних ([#представлення]) у програмах з графічним інтерфейсом. Це робить програму зрозумілішою, полегшує майбутню розробку та дозволяє тестувати окремі частини окремо.


Model-View-Presenter
--------------------
Архітектура, що базується на [#Model-View-Controller].


Модуль
------
Модуль представляє логічну частину програми. У типовій структурі це група presenter'ів та шаблонів, які вирішують певну область функціональності. Модулі розміщуються в [окремих каталогах |application:directory-structure#Presenter и та шаблони], таких як `Front/`, `Admin/` або `Shop/`.

Наприклад, інтернет-магазин ми розділимо на:
- Фронтенд (`Shop/`) для перегляду товарів та здійснення покупок
- Клієнтську секцію (`Customer/`) для керування замовленнями
- Адміністрацію (`Admin/`) для оператора

Технічно це звичайні каталоги, але завдяки чіткому поділу вони допомагають масштабувати програму. Presenter `Admin:Product:List` фізично буде розташований, наприклад, у каталозі `app/Presentation/Admin/Product/List/` (див. [мапінг presenter'ів |application:directory-structure#Мапінг presenter ів]).


Namespace
---------
Простір імен, частина мови PHP з версії 5.3 та деяких інших мов програмування, що дозволяє використовувати класи, які мають однакові назви в різних бібліотеках, без конфліктів імен. Див. [документацію PHP |https://www.php.net/manual/en/language.namespaces.rationale.php].


Presenter
---------
Presenter - це об'єкт, який приймає [запит |api:Nette\Application\Request], перетворений маршрутизатором з HTTP-запиту, і генерує [відповідь |api:Nette\Application\Response]. Відповіддю може бути HTML-сторінка, зображення, XML-документ, файл на диску, JSON, перенаправлення або будь-що, що ви придумаєте.

Зазвичай під терміном presenter розуміють нащадка класу [api:Nette\Application\UI\Presenter]. Залежно від вхідних запитів він запускає відповідні [дії |application:presenters#Життєвий цикл презентера] та рендерить шаблони.


Маршрутизатор
-------------
Двосторонній перекладач між HTTP-запитом / URL та дією presenter'а. Двосторонній означає, що з HTTP-запиту можна визначити [дію presenter'а |#Дія presenter а], але також навпаки, для дії можна згенерувати відповідний URL. Більше в розділі про [маршрутизацію URL |application:routing].


SameSite cookie
---------------
SameSite cookies надають механізм для розпізнавання того, що призвело до завантаження сторінки. Може мати три значення: `Lax`, `Strict` та `None` (останній вимагає HTTPS). Якщо запит на сторінку надходить безпосередньо з веб-сайту, або користувач відкриває сторінку, вводячи її безпосередньо в адресний рядок або клацаючи на закладку, браузер надсилає серверу всі файли cookie (тобто з прапорцями `Lax`, `Strict` та `None`). Якщо користувач переходить на веб-сайт за посиланням з іншого веб-сайту, серверу передаються файли cookie з прапорцями `Lax` та `None`. Якщо запит виникає іншим чином, наприклад, надсиланням POST-форми з іншого веб-сайту, завантаженням усередині iframe, за допомогою JavaScript тощо, надсилаються лише файли cookie з прапорцем `None`.


Сервіс
------
У контексті Dependency Injection сервісом називається об'єкт, який створюється та керується DI-контейнером. Сервіс може бути легко замінений іншою реалізацією, наприклад, для тестування або для зміни поведінки програми, без необхідності змінювати код, який використовує сервіс.


Сніпет
------
Фрагмент, частина сторінки, яку можна окремо перемалювати під час AJAX-запиту.


Представлення
-------------
Представлення (View) - це шар програми, який відповідає за відображення результату запиту. Зазвичай він використовує систему шаблонів і знає, як відобразити той чи інший компонент або результат, отриманий з моделі.





{{leftbar: www:@menu-common}}
{{priority: -2}}
