Маршрутизация
*************

<div class=perex>

Маршрутизатор позаботится обо всём, что связано с URL-адресами, так что вам больше не придется о них думать. Давайте покажем:

- как настроить маршрутизатор так, чтобы URL-адреса были такими, какими вы хотите их видеть
- как настроить SEO и перенаправления
- как написать свой собственный маршрутизатор

</div>


Более человеческие URL (или крутые или красивые URL) более удобны для использования, лучше запоминаются и положительно влияют на SEO. Nette учитывает это и полностью удовлетворяет желания разработчиков. Вы можете разработать структуру URL для вашего приложения именно так, как вы хотите.
Вы можете даже разработать ее после того, как приложение будет готово, поскольку это можно сделать без каких-либо изменений кода или шаблона. Она определяется элегантным образом в [одном единственном месте |#Integration], в маршрутизаторе, и не разбросана в виде аннотаций по всем презентаторам.

Маршрутизатор в Nette особенный, потому что он **двунаправленный**, он может как декодировать URL HTTP-запросов, так и создавать ссылки. Поэтому он играет важную роль в [Nette Application |how-it-works#Nette-Application],
поскольку он решает, какой ведущий и действие будут выполнять текущий запрос, а также используется для [генерации URL |creating-links] в шаблоне и т.д.

Однако маршрутизатор не ограничивается этим применением, вы можете использовать его в приложениях, где ведущие вообще не используются, для REST API и т.д. Подробнее в разделе [раздельное использование|#separated-usage].


Коллекция маршрутов .[#toc-route-collection]
============================================

Наиболее приятным способом определения URL-адресов в приложении является класс [api:Nette\Application\Routers\RouteList]. Определение состоит из списка так называемых маршрутов, то есть масок URL-адресов и связанных с ними презентеров и действий с помощью простого API. Нам не нужно называть маршруты.

```php
$router = new Nette\Application\Routers\RouteList;
$router->addRoute('rss.xml', 'Feed:rss');
$router->addRoute('article/<id>', 'Article:view');
// ...
```

В примере говорится, что если мы откроем `https://any-domain.com/rss.xml` в браузере, то будет отображен презентер `Feed` с действием `rss` и т. д. Если подходящий маршрут не найден, приложение Nette отвечает исключением [BadRequestException |api:Nette\Application\BadRequestException], которое отображается для пользователя как страница ошибки 404 Not Found.


Порядок маршрутов .[#toc-order-of-routes]
-----------------------------------------

Порядок, в котором перечислены маршруты, **очень важен**, потому что они оцениваются последовательно сверху вниз. Правило заключается в том, что мы объявляем маршруты **от конкретных к общим**:

```php
// ОШИБКА: 'rss.xml' соответствует первому маршруту и неправильно воспринимает его как <slug>.
$router->addRoute('<slug>', 'Article:view');
$router->addRoute('rss.xml', 'Feed:rss');

// ПОДРОБНЕЕ
$router->addRoute('rss.xml', 'Feed:rss');
$router->addRoute('<slug>', 'Article:view');
```

Маршруты также оцениваются сверху вниз при генерации ссылок:

```php
// ОШИБКА: генерирует ссылку на 'Feed:rss' как 'admin/feed/rss'
$router->addRoute('admin/<presenter>/<action>', 'Admin:default');
$router->addRoute('rss.xml', 'Feed:rss');

// ПОДРОБНЕЕ
$router->addRoute('rss.xml', 'Feed:rss');
$router->addRoute('admin/<presenter>/<action>', 'Admin:default');
```

Мы не будем скрывать от вас, что для правильного построения списка требуется определенный навык. Пока вы не научитесь, панель [routing panel |#Debugging-Router] будет полезным инструментом.


Маска и параметры .[#toc-mask-and-parameters]
---------------------------------------------

Маска описывает относительный путь, основанный на корне сайта. Самая простая маска — это статический URL:

```php
$router->addRoute('products', 'Products:default');
```

Часто маски содержат так называемые **параметры**. Они заключены в угловые скобки (например, `<year>`) и передаются в целевой презентер, например, в метод `renderShow(int $year)` или в постоянный параметр `$year`:

```php
$router->addRoute('chronicle/<year>', 'History:show');
```

В примере говорится, что если мы откроем `https://any-domain.com/chronicle/2020` в браузере, презентер `History` и действие `show` с параметром `year: 2020` будет отображаться.

Мы можем указать значение по умолчанию для параметров непосредственно в маске, и таким образом она становится необязательной:

```php
$router->addRoute('chronicle/<year=2020>', 'History:show');
```

Теперь маршрут будет принимать URL `https://any-domain.com/chronicle/`, который снова отобразит `History:show` с параметром `year`: 2020`.

Конечно, имя презентера и действие также могут быть параметрами. Например:

```php
$router->addRoute('<presenter>/<action>', 'Homepage:default');
```

Этот маршрут принимает, например, URL в форме `/article/edit` и `/catalog/list` соответственно, и переводит их в презентеры и действия `Article:edit` и `Catalog:list` соответственно.

Он также придает параметрам `presenter` и `action` значения по умолчанию `Homepage` и `default` и поэтому они являются необязательными. Поэтому маршрут также принимает URL `/article` и переводит его как `Article:default`. Или наоборот, ссылка на `Product:default` генерирует путь `/product`, ссылка на стандартную `Homepage:default` генерирует путь `/`.

Маска может описывать не только относительный путь, основанный на корне сайта, но и абсолютный путь, если он начинается со слэша, или даже весь абсолютный URL, если он начинается с двух слэшей:

```php
// относительный путь к корню приложения
$router->addRoute('<presenter>/<action>', /* ... */);

// абсолютный путь, относительно имени хоста сервера
$router->addRoute('/<presenter>/<action>', /* ... */);

// абсолютный URL, включая имя хоста (относительно схемы)
$router->addRoute('//<lang>.example.com/<presenter>/<action>', /* ... */);

// абсолютный URL, включая схему
$router->addRoute('https://<lang>.example.com/<presenter>/<action>', /* ... */);
```


Валидационные выражения .[#toc-validation-expressions]
------------------------------------------------------

Для каждого параметра можно задать условие проверки с помощью [регулярного выражения |https://www.php.net/manual/en/reference.pcre.pattern.syntax.php]. Например, давайте зададим `id` только числовым, используя `\d+` regexp:

```php
$router->addRoute('<presenter>/<action>[/<id \d+>]', /* ... */);
```

По умолчанию регулярным выражением для всех параметров является `[^/]+`, то есть всё, кроме слэша. Если параметр должен соответствовать также косой черте, мы задаем регулярное выражение `.+`.

```php
// принимает https://example.com/a/b/c, path — 'a/b/c'
$router->addRoute('<path .+>', /* ... */);
```


Необязательные последовательности .[#toc-optional-sequences]
------------------------------------------------------------

Квадратные скобки обозначают необязательные части маски. Любая часть маски может быть задана как необязательная, включая те, которые содержат параметры:

```php
$router->addRoute('[<lang [a-z]{2}>/]<name>', /* ... */);

// Принимаемые URL-адреса:  Параметры:
//   /en/download           lang => en, name => download
//   /download              lang => null, name => download
```

Конечно, когда параметр является частью необязательной последовательности, он также становится необязательным. Если у него нет значения по умолчанию, он будет равен null.

Необязательные части также могут быть в домене:

```php
$router->addRoute('//[<lang=en>.]example.com/<presenter>/<action>', /* ... */);
```

Последовательности могут быть свободно вложены и объединены:

```php
$router->addRoute(
	'[<lang [a-z]{2}>[-<sublang>]/]<name>[page-<page=0>]',
	'Homepage:default',
);

// Принимаемые URL-адреса:
//   /ru/hello
//   /en-us/hello
//   /hello
//   /hello/page-12
```

Генератор URL старается сделать URL как можно короче, поэтому то, что можно опустить, опускается. Поэтому, например, маршрут `index[.html]` генерирует путь `/index`. Вы можете изменить это поведение, написав восклицательный знак после левой квадратной скобки:

```php
// принимает /hello и /hello.html, генерирует /hello
$router->addRoute('<name>[.html]', /* ... */);

// принимает /hello и /hello.html, генерирует /hello.html
$router->addRoute('<name>[!.html]', /* ... */);
```

Необязательные параметры (т. е. параметры, имеющие значение по умолчанию) без квадратных скобок ведут себя так, как если бы они были обернуты таким образом:

```php
$router->addRoute('<presenter=Homepage>/<action=default>/<id=>', /* ... */);

// equals to:
$router->addRoute('[<presenter=Homepage>/[<action=default>/[<id>]]]', /* ... */);
```

Чтобы изменить способ генерации самой правой косой черты, т. е. вместо `/homepage/` получить `/homepage`, настройте маршрут таким образом:

```php
$router->addRoute('[<presenter=Homepage>[/<action=default>[/<id>]]]', /* ... */);
```


Символы подстановки .[#toc-wildcards]
-------------------------------------

В маске абсолютного пути мы можем использовать следующие подстановочные знаки, чтобы избежать, например, необходимости записывать в маску домен, который может отличаться в среде разработки и производственной среде:

- `%tld%` = домен верхнего уровня, например, `com` или `org`
- `%sld%` = домен второго уровня, например, `example`
- `%domain%` = домен без поддоменов, например, `example.com`
- `%host%` = весь хост, например, `www.example.com`
- `%basePath%` = путь к корневому каталогу

```php
$router->addRoute('//www.%domain%/%basePath%/<presenter>/<action>', /* ... */);
$router->addRoute('//www.%sld%.%tld%/%basePath%/<presenter>/<action', /* ... */);
```


Расширенная нотация .[#toc-advanced-notation]
---------------------------------------------

Второй параметр маршрута, который мы часто пишем в формате `Presenter:action`, является аббревиатурой, которую мы также можем написать в виде поля, где мы непосредственно указываем значения (по умолчанию) отдельных параметров:

```php
$router->addRoute('<presenter>/<action>[/<id \d+>]', [
	'presenter' => 'Homepage',
	'action' => 'default',
]);
```

Или мы можем использовать эту форму, обратите внимание на переписывание регулярного выражения проверки:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>[/<id>]', [
	'presenter' => [
		Route::Value => 'Homepage',
	],
	'action' => [
		Route::Value => 'default',
	],
	'id' => [
		Route::Pattern => '\d+',
	],
]);
```

Эти более подробные форматы полезны для добавления дополнительных метаданных.


Фильтры и переводы .[#toc-filters-and-translations]
---------------------------------------------------

Хорошей практикой является написание исходного кода на английском языке, но что если вам нужно, чтобы URL вашего сайта был переведен на другой язык?

```php
$router->addRoute('<presenter>/<action>', 'Homepage:default');
```

будет генерировать английские URL, такие как `/product/123` или `/cart`. Если мы хотим, чтобы презентеры и действия в URL были переведены на немецкий язык (например, `/produkt/123` или `/einkaufswagen`), мы можем использовать словарь переводов. Чтобы добавить его, нам уже нужен «более понятный» вариант второго параметра:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>', [
	'presenter' => [
		Route::Value => 'Homepage',
		Route::FilterTable => [
			// строка в URL => ведущий
			'produkt' => 'Product',
			'einkaufswagen' => 'Cart',
			'katalog' => 'Catalog',
		],
	],
	'action' => [
		Route::Value => 'default',
		Route::FilterTable => [
			'liste' => 'list',
		],
	],
]);
```

Для одного и того же презентера можно использовать несколько ключей словаря. Они будут создавать для него различные псевдонимы. Последний ключ считается каноническим вариантом (т. е. тот, который будет в сгенерированном URL).

Таблица перевода может быть применена к любому параметру таким образом. Однако если перевода не существует, берется исходное значение. Мы можем изменить это поведение, добавив `Route::FilterStrict => true`, и тогда маршрут будет отклонять URL, если значение отсутствует в словаре.

В дополнение к словарю перевода в виде массива можно задать собственные функции перевода:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => [
		Route::Value => 'Homepage',
		Route::FilterIn => function (string $s): string { /* ... */ },
		Route::FilterOut => function (string $s): string { /* ... */ },
	],
	'action' => 'default',
	'id' => null,
]);
```

Функция `Route::FilterIn` осуществляет преобразование между параметром в URL и строкой, которая затем передается презентеру, функция `FilterOut` обеспечивает преобразование в обратном направлении.

Параметры `presenter`, `action` и `module` уже имеют предопределенные фильтры, которые конвертируют между PascalCase, camelCase и kebab-case соответственно, используемые в URL. Значение параметров по умолчанию уже записано в преобразованной форме, поэтому, например, в случае с презентером мы пишем `<presenter=ProductEdit>` вместо `<presenter=product-edit>`.


Общие фильтры .[#toc-general-filters]
-------------------------------------

Помимо фильтров для конкретных параметров, вы также можете определить общие фильтры, получающие ассоциативный массив всех параметров, которые они могут изменять любым способом, а затем возвращать. Общие фильтры определяются по ключу `null`.

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>', [
	'presenter' => 'Homepage',
	'action' => 'default',
	null => [
		Route::FilterIn => function (array $params): array { /* ... */ },
		Route::FilterOut => function (array $params): array { /* ... */ },
	],
]);
```

Общие фильтры дают вам возможность настроить поведение маршрута абсолютно любым способом. Мы можем использовать их, например, для изменения параметров на основе других параметров. Например, перевод `<presenter>` и `<action>` на основе текущего значения параметра `<lang>`.

Если для параметра определен пользовательский фильтр и одновременно существует общий фильтр, пользовательский `FilterIn` выполняется перед общим, и наоборот, общий `FilterOut` выполняется перед пользовательским. Таким образом, внутри общего фильтра находятся значения параметров `presenter` и `action` соответственно, написанное на языке PascalCase и camelCase соответственно.


Флаг OneWay .[#toc-oneway-flag]
-------------------------------

Односторонние маршруты используются для сохранения функциональности старых URL, которые приложение больше не генерирует, но всё ещё принимает. Мы отмечаем их флагом `OneWay`:

```php
// старый URL /product-info?id=123
$router->addRoute('product-info', 'Product:detail', $router::ONE_WAY);
// новый URL /product/123
$router->addRoute('product/<id>', 'Product:detail');
```

При обращении к старому URL-адресу презентер автоматически перенаправляет на новый URL-адрес, чтобы поисковые системы не индексировали эти страницы дважды (см. [SEO и канонизация|#seo-and-canonization]).


Модули .[#toc-modules]
----------------------

Если у нас есть несколько маршрутов, принадлежащих одному модулю, мы можем использовать `withModule()` для их группировки:

```php
$router = new RouteList;
$router->withModule('Forum') // следующие маршрутизаторы входят в состав модуля Forum
	->addRoute('rss', 'Feed:rss') // презентер Forum:Feed
	->addRoute('<presenter>/<action>')

	->withModule('Admin') // следующие маршрутизаторы являются частью модуля Forum:Admin
		->addRoute('sign:in', 'Sign:in');
```

Альтернативой является использование параметра `module`:

```php
// URL manage/dashboard/default отображается на ведущего Admin:Dashboard
$router->addRoute('manage/<presenter>/<action>', [
	'module' => 'Admin',
]);
```


Субдомены .[#toc-subdomains]
----------------------------

Коллекции маршрутов могут быть сгруппированы по поддоменам:

```php
$router = new RouteList;
$router->withDomain('example.com')
	->addRoute('rss', 'Feed:rss')
	->addRoute('<presenter>/<action>');
```

Вы также можете использовать [Символы подстановки |#Wildcards] в своем доменном имени:

```php
$router = new RouteList;
$router->withDomain('example.%tld%')
	// ...
```


Префикс пути .[#toc-path-prefix]
--------------------------------

Коллекции маршрутов могут быть сгруппированы по пути в URL:

```php
$router = new RouteList;
$router->withPath('eshop')
	->addRoute('rss', 'Feed:rss') // соответствует URL /eshop/rss
	->addRoute('<presenter>/<action>'); //  соответствует URL /eshop/<presenter>/<action>
```


Комбинации .[#toc-combinations]
-------------------------------

Вышеуказанные варианты использования можно комбинировать:

```php
$router = (new RouteList)
	->withDomain('admin.example.com')
		->withModule('Admin')
			->addRoute(/* ... */)
			->addRoute(/* ... */)
		->end()
		->withModule('Images')
			->addRoute(/* ... */)
		->end()
	->end()
	->withDomain('example.com')
		->withPath('export')
			->addRoute(/* ... */)
			// ...
```


Параметры запроса .[#toc-query-parameters]
------------------------------------------

Маски также могут содержать параметры запроса (параметры после знака вопроса в URL). Они не могут определить выражение проверки, но они могут изменить имя, под которым они передаются презентеру:

```php
// используем параметр запроса 'cat' в качестве 'categoryId' в приложении
$router->addRoute('product ? id=<productId> & cat=<categoryId>', /* ... */);
```


Параметры Foo .[#toc-foo-parameters]
------------------------------------

Теперь мы идем глубже. Параметры Foo — это, по сути, неименованные параметры, которые позволяют сопоставить регулярное выражение. Следующий маршрут соответствует `/index`, `/index.html`, `/index.htm` и `/index.php`:

```php
$router->addRoute('index<? \.html?|\.php|>', /* ... */);
```

Также можно явно задать строку, которая будет использоваться для генерации URL. Строка должна располагаться непосредственно после знака вопроса. Следующий маршрут похож на предыдущий, но генерирует `/index.html` вместо `/index`, потому что строка `.html` установлена как «генерируемое значение».

```php
$router->addRoute('index<?.html \.html?|\.php|>', /* ... */);
```


Интеграция .[#toc-integration]
==============================

Чтобы подключить наш маршрутизатор к приложению, мы должны сообщить о нем контейнеру DI. Самый простой способ - это подготовить фабрику, которая будет создавать объект маршрутизатора, и сообщить конфигурации контейнера, чтобы она его использовала. Допустим, мы напишем для этого метод `App\Router\RouterFactory::createRouter()`:

```php
namespace App\Router;

use Nette\Application\Routers\RouteList;

class RouterFactory
{
	public static function createRouter(): RouteList
	{
		$router = new RouteList;
		$router->addRoute(/* ... */);
		return $router;
	}
}
```

Затем мы пишем в [configuration |dependency-injection:services]:

```neon
services:
	- App\Router\RouterFactory::createRouter
```

Любые зависимости, такие как подключение к базе данных и т.д., передаются методу фабрики в качестве параметров с помощью [autowiring |dependency-injection:autowiring]:

```php
public static function createRouter(Nette\Database\Connection $db): RouteList
{
	// ...
}
```


SimpleRouter
============

Гораздо более простым маршрутизатором, чем коллекция маршрутов, является [SimpleRouter |api:Nette\Application\Routers\SimpleRouter]. Его можно использовать, когда нет необходимости в определенном формате URL, когда `mod_rewrite` (или альтернативы) недоступен или когда мы просто не хотим пока возиться с удобными для пользователя URL.

Генерирует адреса примерно такой формы:

```
http://example.com/?presenter=Product&action=detail&id=123
```

Параметром конструктора `SimpleRouter` является презентер и действие по умолчанию, т. е. действие, которое будет выполнено, если мы откроем, например, `http://example.com/` без дополнительных параметров.

```php
// используем презентер 'Homepage' и действие 'default'
$router = new Nette\Application\Routers\SimpleRouter('Homepage:default');
```

Мы рекомендуем определять SimpleRouter непосредственно в [конфигурации |dependency-injection:services]:

```neon
services:
	- Nette\Application\Routers\SimpleRouter('Homepage:default')
```


SEO и канонизация .[#toc-seo-and-canonization]
==============================================

Фреймворк улучшает SEO, предотвращая дублирование контента на разных URL. Если несколько адресов ссылаются на одно и то же место назначения, например `/index` и `/index.html`, фреймворк определяет первый из них как основной (канонический) и перенаправляет на него остальные с помощью HTTP-кода 301. Благодаря этому поисковые системы не будут индексировать страницы дважды и не нарушат их страничный рейтинг.

Этот процесс называется канонизацией. Канонический URL — это URL, сгенерированный маршрутизатором, т. е. первым подходящим маршрутом в [коллекции |#Route-Collection] без флага OneWay. Поэтому в коллекции мы перечисляем **первичные маршруты первыми**.

Канонизация осуществляется презентером, подробнее в главе [Канонизация |presenters#canonization].


HTTPS
=====

Для того чтобы использовать протокол HTTPS, необходимо активировать его на хостинге и настроить сервер.

Перенаправление всего сайта на HTTPS должно быть выполнено на уровне сервера, например, с помощью файла .htaccess в корневом каталоге нашего приложения, с HTTP-кодом 301. Настройки могут отличаться в зависимости от хостинга и выглядят примерно так:

```
<IfModule mod_rewrite.c>
	RewriteEngine On
	...
	RewriteCond %{HTTPS} off
	RewriteRule .* https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
	...
</IfModule>
```

Маршрутизатор генерирует URL с тем же протоколом, по которому была загружена страница, поэтому нет необходимости задавать что-либо ещё.

Однако, если нам исключительно нужно, чтобы разные маршруты работали под разными протоколами, мы поместим это в маску маршрута:

```php
// Сгенерирует HTTP адрес
$router->addRoute('http://%host%/<presenter>/<action>', /* ... */);

// Сгенерирует HTTPS адрес
$router->addRoute('https://%host%/<presenter>/<action>', /* ... */);
```


Отладчик маршрутизации .[#toc-debugging-router]
===============================================

Полоса маршрутизации, показанная в [Tracy Bar |tracy:], является полезным инструментом, который отображает список маршрутов, а также параметры, которые маршрутизатор получил из URL.

Зеленая полоса с символом ✓ представляет маршрут, который соответствует текущему URL, синие полосы с символами ≈ указывают на маршруты, которые также соответствовали бы URL, если бы зеленый цвет не обогнал их. Далее мы видим текущего ведущего и действия.

[* routing-debugger.webp *]

В то же время, если происходит неожиданное перенаправление из-за [каноникализации |#seo-and-canonization], полезно заглянуть в панель *redirect*, чтобы узнать, как маршрутизатор изначально понял URL и почему он перенаправил.

.[note]
При отладке маршрутизатора рекомендуется открыть Developer Tools в браузере (Ctrl+Shift+I или Cmd+Option+I) и отключить кэш в панели Network, чтобы перенаправления не сохранялись в нем.


Производительность .[#toc-performance]
======================================

Количество маршрутов влияет на скорость маршрутизатора. Их количество, конечно, не должно превышать нескольких десятков. Если ваш сайт имеет слишком сложную структуру URL, вы можете написать [Пользовательский маршрутизатор|#custom-router].

Если маршрутизатор не имеет зависимостей, например, от базы данных, и его фабрика не имеет аргументов, мы можем сериализовать его скомпилированную форму непосредственно в DI-контейнер и тем самым сделать приложение немного быстрее.

```neon
routing:
	cache: true
```


Пользовательский маршрутизатор .[#toc-custom-router]
====================================================

Следующие строки предназначены для очень опытных пользователей. Вы можете создать свой собственный маршрутизатор и, естественно, добавить его в коллекцию маршрутов. Маршрутизатор представляет собой реализацию интерфейса [Router |api:Nette\Routing\Router] с двумя методами:

```php
use Nette\Http\IRequest as HttpRequest;
use Nette\Http\UrlScript;

class MyRouter implements Nette\Routing\Router
{
	public function match(HttpRequest $httpRequest): ?array
	{
		// ...
	}

	public function constructUrl(array $params, UrlScript $refUrl): ?string
	{
		// ...
	}
}
```

Метод `match` обрабатывает текущий [$httpRequest |http:request], из которого может быть извлечен не только URL, но и заголовки и т.д., в массив, содержащий имя ведущего и его параметры. Если он не может обработать запрос, то возвращает null.
При обработке запроса мы должны вернуть как минимум ведущего и действие. Имя ведущего является полным и включает любые модули:

```php
[
	'presenter' => 'Front:Homepage',
	'action' => 'default',
]
```

Метод `constructUrl`, с другой стороны, генерирует абсолютный URL из массива параметров. Он может использовать информацию из параметра `$refUrl`, который является текущим URL.

Чтобы добавить пользовательский маршрутизатор в коллекцию маршрутов, используйте `add()`:

```php
$router = new Nette\Application\Routers\RouteList;
$router->add(new MyRouter);
$router->addRoute(/* ... */);
// ...
```


Раздельное использование .[#toc-separated-usage]
================================================

Под раздельным использованием подразумевается использование возможностей маршрутизатора в приложении, которое не использует приложение Nette и презентеры. К нему применимо почти всё, что мы показали в этой главе, со следующими отличиями:

- для коллекций маршрутов мы используем класс [api:Nette\Routing\RouteList].
- как класс простого маршрутизатора [api:Nette\Routing\SimpleRouter].
- поскольку нет пары `Presenter:action`, мы используем [Расширенная нотация|#advanced-notation].

Итак, мы снова добавим метод, который будет создавать, например, маршрутизатор:

```php
namespace App\Router;

use Nette\Routing\RouteList;

class RouterFactory
{
	public static function createRouter(): RouteList
	{
		$router = new RouteList;
		$router->addRoute('rss.xml', [
			'controller' => 'RssFeedController',
		]);
		$router->addRoute('article/<id \d+>', [
			'controller' => 'ArticleController',
		]);
		// ...
		return $router;
	}
}
```

Если вы используете DI-контейнер, как мы рекомендуем, добавьте метод в конфигурацию ещё раз, а затем получите маршрутизатор вместе с HTTP-запросом из контейнера:

```php
$router = $container->getByType(Nette\Routing\Router::class);
$httpRequest = $container->getByType(Nette\Http\IRequest::class);
```

Или мы будем создавать объекты напрямую:

```php
$router = App\Router\RouterFactory::createRouter();
$httpRequest = (new Nette\Http\RequestFactory)->fromGlobals();
```

Теперь нужно дать маршрутизатору поработать:

```php
$params = $router->match($httpRequest);
if ($params === null) {
	// не найден совпадающий маршрут, отправим ошибку 404
	exit;
}

// обрабатываем полученные параметры
$controller = $params['controller'];
// ...
```

И наоборот, мы будем использовать маршрутизатор для создания ссылки:

```php
$params = ['controller' => 'ArticleController', 'id' => 123];
$url = $router->constructUrl($params, $httpRequest->getUrl());
```


{{composer: nette/router}}
