Dependency Injection
********************

/--div .[perex]
Podstatou Dependency Injection (DI) je odebrat třídám zodpovědnost za získávání objektů, které potřebují ke své činnosti (tzv. služeb) a místo toho jim služby předávat při vytváření. Řekneme si:

- co je principem Dependency Injection?
- jak vytvářet dynamické a statické DI kontejnery
- jak na lazy loading služeb
\--


Co je to Dependency Injection?
==============================

Narovinu: Dependency Injection (DI) není nic tajemného nebo nepochopitelného. Celé se dá shrnout do jedné sobecké věty: **„nic nesháněj, ať se postará někdo jiný.“** Nic víc, nic míň. Převeďme to do řeči programátorů. Máme třídu `Article` reprezentující článek na blogu:

/--php
class Article
{
	public $id;
	public $title;
	public $content;

	function save()
	{
		// uložíme do databáze
	}

}
\--

a použití bude následující:

/--php
$article = new Article;
$article->title = '10 Things You Need to Know About Losing Weight';
$article->content = 'Every year millions of people in ...';
$article->save();
\--

Metoda `save()` nám uloží článek do databázové tabulky `articles`. Implementovat ji za pomoci [Nette\Database |database] bude hračka, nebýt jedno zádrhelu: kde má `Article` vzít připojení k databázi, tj. objekt třídy Connection?

Nejspíš bychom si poradili, můžeme jej uložit někde do globální proměnné `$GLOBALS['connection']`. Říkali vám, že používání globálních proměnných je špatné a že máte raději používat statické proměnné tříd? No měli pravdu, globální proměnné jsou zlo, jenže statické proměnné tříd jsou zcela totéž. To je jako říci: „Nejezte hamburgery, tloustne se po nich, dejte si raději cheeseburger.“

Kde tedy seženeme připojení k databázi? DI má odpověď: „nic nesháněj, ať se postará někdo jiný.“ Jinými slovy, pokud potřebuji databázi, ať mi ji někdo dodá, já to řešit nehodlám. Cha, to je vychytralé, milé DI! Tak do toho:

/--php
class Article
{
	public $id;
	public $title;
	public $content;
	private $connection;

	function __construct(Nette\Database\Connection $connection)
	{
		$this->connection = $connection;
	}

	function save()
	{
		$this->connection->table('articles')->insert(array(
			'title' => $this->title,
			'content' => $this->content,
		));
	}

}
\--

Použití třídy `Article` se pochopitelně trošku změní:

/--php
$article = new Article($connection);
$article->title = ...
$article->content = ...
$article->save();
\--

Ptáte se, kde tento kód vezme `$connection`? DI dává jasnou odpověď: „ať se postará někdo jiný“. Databázové spojení zkrátka dodá ten, kdo volá uvedený kód. A tak dále, a tak dále. Jistě si říkáte, že přece nelze delegovat zodpovědnost do nekonečna. Že musí být nějaký počátek všehomíra. A máte pravdu. Úplně na začátku je *stvořitel*, který už nic nedeleguje a objekty tvoří. Říká se mu **systémový kontejner.** A je mu věnovaná [samostatná kapitola |configuring].


Proč jsou globální proměnné zlo?
--------------------------------

Dobrá otázka. Zvídavému programátorovi nestačí si přečíst, že to či ono je zlo, chce znát důvod. Třída `Article` tak jako tak databázové připojení potřebuje. Jenže z prvního příkladu užití není vůbec patrné, odkud a jak ho získá. Uživatel takové kódu může být až překvapen, že se vůbec článek uloží, a ptá se „kam se vlastně uložil?“ Naopak v druhém příkladu používajícím DI je kód samovysvětlující.

Představte si, že zkoumáte nějakou knihovnu pro platební brány a napíšete si příklad:

/--php
$cc = new CreditCard('4461510140804839', 12, 2013);
$cc->pay(1000, CreditCard::DOLLARS);
\--

Kód spustíte, s číslem své karty, a po nějaké době zjistíte, že vám to skutečně z účtu strhlo peníze! Šokovaný zíráte na výpis a lamentujete: „kde jsou mé peníze, jak je to mohlo strhnout, vždyť jsem to s žádnou platební bránou nepropojil!“ Třída `CreditCard` se s ní propojila nějak sama, získala ji odněkud z globální proměnné, podobně tajemně, jako si původní `Article` získal připojení k databázi. Takovou věc z kódu nejen že nevydedukujete, ale ani nevíte, jak změnit platební bránu na jinou, třeba testovací.


DI znamená víc psaní
--------------------

Můžete namítnout, že používání DI znamená víc psaní, že kvůli vytvoření instance `Article` musíte uchovávat a předávat databázové spojení a podobně. To je pravda, nicméně nezapomeňte, že posledně vás „méně psaní“ připravilo o $1000! Ne, nechceme to zlehčovat. Připomínka je zcela korektní a my ještě přidáme jednu závažnější: časem může ve třídě `Article` vzniknout potřeba nějaká data cachovat a v souladu s DI bude požadovat předání ještě objektu představujícího úložiště cache. To by znamenalo upravit aplikaci na mnoha místech: přinejmenším všude, kde se vytváří instance `Article`.

Co s tím? Věc má řešení. Místo ručního vytváření objektů `Article` si vytvoříme továrničku, tedy funkci, která bude objekty `Article` vyrábět. Když `Article` změní konstruktor, upraví se jen továrnička, nic víc. A odkud onu továrničku v našem kódu získáme? Vždyť víte… o to ať se postará někdo jiný :-).


DI kontejner a služby
---------------------

Termínem DI kontejner označujeme právě onu továrničku. Přesněji řečeno, jde o objekt obsahující libovolné množství továrniček, každou pro jinou službu. Co jsou to služby? Obyčejné objekty, jako třeba instance zmíněné `Article`. Jen v souvislosti s DI kontejnery jim říkáme služby. Zřejmě to vymysleli konzultanti, kteří chtějí, aby DI vypadalo složitě a oni mohli konzultovat.

Příkladem může být kontejner, který vytvoří objekt `Article`, ale také jím požadované připojení k databázi:

/--php
class Container
{
	function createConnection()
	{
		return new Nette\Database\Connection('mysql:', 'root', '***');
	}

	function createArticle()
	{
	    return new Article($this->createConnection());
	}

}
\--

Použití by vypadalo následovně:

/--php
$container = new Container;
$article = $container->createArticle();
\--

Výhoda je zřejmá, nemusíme se starat o to, jak `Article` instancovat, to je záležitostí továrničky. Nicméně řešení má zatím dva nedostatky. Jednak jsou přihlašovací údaje natvrdo zadrátované do kódu, proto je vyčleníme do proměnné. Můžeme parametrem ovlivňovat i třídu, kterou továrnička vytváří:

/--php
class Container
{
	public $params = array();

	function createConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	function createArticle()
	{
		$class = $this->params['articleClass'];
		return new $class($this->createConnection());
	}

}

$container = new Container;
$container->params = array(
	'dsn' => 'mysql:',
	'user' => 'root',
	'password' => '***',
	'articleClass' => 'Article',
);
$article = $container->createArticle();
\--

Závažnějším nedostatkem je, že vždy, když požádáme o vytvoření `Article`, vytvoří se i nové připojení k databázi. Tomu je třeba zabránit. Přidáme proto metodu `getConnection`, která bude uchovávat jednou vytvořenou službu pro příští použití:

/--php
class Container
{
	public $params = array();

	private $services = array();

	function createConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	function getConnection()
	{
		if (!isset($this->services['connection'])) {
			$this->services['connection'] = $this->createConnection();
		}
		return $this->services['connection'];
	}

	function createArticle()
	{
		$class = $this->params['articleClass'];
		return new $class($this->getConnection());
	}

}
\--

Jak vidíte, napsat DI kontejner není nic složitého. Za připomenutí stojí, že služby neví, že je vytváří nějaký kontejner, tím pádem je možné takto vytvářet jakýkoliv objekt v PHP.



Nette\DI\Container
==================

Třída [Nette\DI\Container |api:] je pružná implementace DI univerzálního kontejneru. Automaticky zajišťuje, že instance služby se vytváří jen napoprvé a pak vrací stále týž objekt.

Vlastní kontejnery můžeme vytvářet buď staticky, tj. poděděním této třídy, nebo dynamicky, kdy továrničky přidáme jako closury nebo callbacky.


Statický kontejner
------------------

Názvy továrních funkcí dodržují jednotnou konvenci, jsou tvořeny předponou `createService` + názvem služby začínajícím velkým písmenem. Pokud nemají být dostupné zvenčí, lze jim viditelnost snížit na protected. Všimněte si, že kontejner už má pole `$params` pro uživatelské parametry.

/--php
class MyContainer extends Nette\DI\Container
{

	protected function createServiceConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	protected function createServiceArticle()
	{
		$class = $this->params['articleClass'];
		return new $class($this->connection);
	}

}
\--

Službu získáme metodu `getService` nebo zkratkou:

/--php
$container = new MyContainer;
$container->params = array(
	'dsn' => 'mysql:',
	'user' => 'root',
	'password' => '***',
	'articleClass' => 'Article',
);

$article = $container->getService('article');
// nebo rovnou:
$article = $container->article;
\--

Jak bylo řečeno, všechny služby v rámci kontejneru se vytváří jen jednou, nám by se ale spíš hodilo, kdyby kontejner pokaždé vygeneroval novou instanci `Article`. Toho lze dosáhnout snadno: namísto továrničky pro službu `article` vytvoříme obyčejnou metodu `createArticle`:

/--php
class MyContainer extends Nette\DI\Container
{

	function createServiceConnection()
	{
		return new Nette\Database\Connection(
			$this->params['dsn'],
			$this->params['user'],
			$this->params['password']
		);
	}

	function createArticle()
	{
		$class = $this->params['articleClass'];
		return new $class($this->connection);
	}

}

$container = new MyContainer;
$container->params = ...

$article = $container->createArticle();
\--

Z volání `$container->createArticle()` je zřejmé, že se vytváří pokaždé nový objekt. Jde tedy o konvenci na straně programátora.



Dynamický kontejner
-------------------

Skutečné výhody `Nette\DI\Container` se projeví v dynamickém přístupu, kdy továrničky (nebo rovnou služby) přidáváme pomocí metody `addService`:

/--php
$container = new Nette\DI\Container;

$container->addService('connection', function($container) {
	return new Nette\Database\Connection(
		$container->params['dsn'],
		$container->params['user'],
		$container->params['password']
	);
});

$container->addService('article', function($container) {
	$class = $container->params['articleClass'];
	return new $class($container->connection);
});
\--

Továrničky lze zapisovat jako PHP callback nebo closure. Všimněte si, že jako parametr je jim předáván samotný kontejner, mohou tak snadno přistupovat k parametrům a jiným službám.

Pokud vytvoření služby spočívá v triviálním vytvoření instance, lze metodě `addService` jako druhý parametr předat rovnou název třídy. A pokud již objekt vytvořený máme, můžeme předat přímo ho.

Kromě metody `addService` máme k dispozici ještě `hasService` ověřující existenci služby a `removeService` sloužící k jejímu odstranění. Opět včetně zkratek jako `isset($container->article)` a `unset($container->article)`.


Zmrazení
--------

Kontejner je možné zmrazit a poté ho již nelze měnit:

/--php
$container->freeze();
$container->addService(...); // vyhodí výjimku
\--

Rozmrazíme jej vytvořením klonu:

/--php
$dolly = clone $container;
\--


Aliasování
----------

Vytvářejte aliasy pro služby jen tehdy, je-li to skutečně nutné:

/--php
$container->addService('alias', $container->getService('originalName'));
\--

Tímto způsobem můžeme kopírovat služby mezi jednotlivými kontejnery.

Pokud chceme zachovat lazy-loading, tj. kopírovat služby, které zatím nejsou vytvořené, uděláme to následovně:

/--php
$container->addService('alias', function($container) {
	return $container->getService('originalName');
});
\--

Nebo mezi dvěma kontejnery:

/--php
$containerDest->addService('connection', function() use ($containerSrc){
	return $containerSrc->getService('connection');
});
\--

Kontejner je také možné klonovat. Klon obsahuje všechny služby jako vzor a pochopitelně lze do něj přidávat nové.


Auto-wiring
-----------

Autowire je pokročilejší technika, umožňující při vytváření služby automaticky předávat do konstruktoru další služby dle typu. Její implementace není přímo součástí frameworku, napíšeme si proto vlastní [api:Nette\DI\ServiceBuilder]. Jde o speciální továrnu na služby, kterou můžeme předat metodě `addService`:

/--php
$container->addService('article', new AutowireServiceBuilder('Article'));
\--

Vytvoření služby `article` bude mít nyní na starost metoda `createService` builderu. Ukažme si tedy možnou implementaci:

/--php
class AutowireServiceBuilder extends Nette\DI\ServiceBuilder
{

	public function createService(Nette\DI\IContainer $container)
	{
		try {
			$type = new Nette\Reflection\ClassType($this->class);
		} catch (\ReflectionException $e) {
			throw new Nette\InvalidStateException("Cannot instantiate service, class '$this->class' not found.");
		}

		$args = array();
		if ($type->hasMethod('__construct')) {
			foreach ($type->getMethod('__construct')->getParameters() as $param) {
				if ($param->isDefaultValueAvailable()) {
					$args[] = $param->getDefaultValue();
				} elseif ($param->getClass()) {
					$args[] = $container->getServiceByType($param->getClass()->getName());
				} else {
					$args[] = $param->isArray() && !$param->allowsNull() ? array() : NULL;
				}
			}
		}
		return $type->newInstanceArgs($args);
	}

}
\--

Klíčem je metoda kontejneru `getServiceByType`, která vrátí službu podle daného typu (třída, interface). Taková služba musí být v kontejneru právě jedna, jinak se vyhodí výjimka.

Pokud přidáváme službu pomocí továrny, není její typ pochopitelně znám. Můžeme ho proto "napovědět" třetím parametrem metody `addService`:

/--php
$container->addService('article', function() { ... }, 'Article');
\--

K ověření typu konkrétní služby slouží metoda `checkServiceType`:

/--php
if (!$container->checkServiceType('article', 'Article')) {
	...
}
\--


Tagování
--------

Při uložení jakéhokoliv objektu můžeme u něj uvést doplňující metainformace, kterým říkáme tagy:

/--php
$container->addService('name', ..., array('tag1', 'tag2'));
\--

A poté můžeme v kontejneru vyhledat všechny služby, které mají daný tag:

/--php
// vrací pole názvů služeb, tj. řetězců
$list = $container->getServiceNamesByTag('tag1')
\--

Tag nemusí být je řetězec, ale může obsahovat další libovolné atributy:

/--php
$container->addService('name', ..., array(
	'tag1' => array('priority' => 12),
	'tag2' => array('...'),
));

$list = $container->getServiceNamesByTag('tag1')
// vrací pole array('name' => array('priority' => 12))
\--
