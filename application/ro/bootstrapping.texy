Bootstrapping
*************

<div class=perex>

Bootstrapping-ul este procesul de iniÈ›ializare a mediului aplicaÈ›iei, crearea unui container de dependency injection (DI) È™i pornirea aplicaÈ›iei. Vom discuta:

- cum clasa Bootstrap iniÈ›ializeazÄƒ mediul
- cum sunt configurate aplicaÈ›iile folosind fiÈ™iere NEON
- cum sÄƒ distingem Ã®ntre modul de producÈ›ie È™i dezvoltare
- cum sÄƒ creÄƒm È™i sÄƒ configurÄƒm containerul DI

</div>


AplicaÈ›iile, fie cÄƒ sunt web sau scripturi rulate din linia de comandÄƒ, Ã®È™i Ã®ncep execuÈ›ia cu o formÄƒ de iniÈ›ializare a mediului. Ãn trecut, acest lucru era de obicei gestionat de un fiÈ™ier numit, de exemplu, `include.inc.php`, pe care fiÈ™ierul iniÈ›ial Ã®l includea. Ãn aplicaÈ›iile Nette moderne, acesta a fost Ã®nlocuit de clasa `Bootstrap`, pe care o veÈ›i gÄƒsi ca parte a aplicaÈ›iei Ã®n fiÈ™ierul `app/Bootstrap.php`. Poate arÄƒta, de exemplu, astfel:

```php
use Nette\Bootstrap\Configurator;

class Bootstrap
{
	private Configurator $configurator;
	private string $rootDir;

	public function __construct()
	{
		$this->rootDir = dirname(__DIR__);
		// Configuratorul este responsabil pentru setarea mediului aplicaÈ›iei È™i a serviciilor.
		$this->configurator = new Configurator;
		// SeteazÄƒ directorul pentru fiÈ™ierele temporare generate de Nette (de ex., È™abloane compilate)
		$this->configurator->setTempDirectory($this->rootDir . '/temp');
	}

	public function bootWebApplication(): Nette\DI\Container
	{
		$this->initializeEnvironment();
		$this->setupContainer();
		return $this->configurator->createContainer();
	}

	private function initializeEnvironment(): void
	{
		// Nette este inteligent È™i modul de dezvoltare se activeazÄƒ automat,
		// sau Ã®l puteÈ›i activa pentru o anumitÄƒ adresÄƒ IP decomentÃ¢nd urmÄƒtoarea linie:
		// $this->configurator->setDebugMode('secret@23.75.345.200');

		// ActiveazÄƒ Tracy: "briceagul elveÈ›ian" suprem pentru depanare.
		$this->configurator->enableTracy($this->rootDir . '/log');

		// RobotLoader: Ã®ncarcÄƒ automat toate clasele din directorul selectat
		$this->configurator->createRobotLoader()
			->addDirectory(__DIR__)
			->register();
	}

	private function setupContainer(): void
	{
		// ÃncarcÄƒ fiÈ™ierele de configurare
		$this->configurator->addConfig($this->rootDir . '/config/common.neon');
	}
}
```


index.php
=========

FiÈ™ierul iniÈ›ial Ã®n cazul aplicaÈ›iilor web este `index.php`, care se aflÄƒ Ã®n [directorul public |directory-structure#Director public www] `www/`. Acesta solicitÄƒ clasei Bootstrap sÄƒ iniÈ›ializeze mediul È™i sÄƒ creeze containerul DI. Apoi, obÈ›ine din acesta serviciul `Application`, care porneÈ™te aplicaÈ›ia web:

```php
$bootstrap = new App\Bootstrap;
// IniÈ›ializarea mediului + crearea containerului DI
$container = $bootstrap->bootWebApplication();
// Containerul DI creeazÄƒ obiectul Nette\Application\Application
$application = $container->getByType(Nette\Application\Application::class);
// Pornirea aplicaÈ›iei Nette È™i procesarea cererii primite
$application->run();
```

DupÄƒ cum se poate vedea, clasa [api:Nette\Bootstrap\Configurator] ajutÄƒ la setarea mediului È™i la crearea containerului de dependency injection (DI), pe care o vom prezenta acum mai detaliat.


Modul de dezvoltare vs producÈ›ie
================================

Nette se comportÄƒ diferit Ã®n funcÈ›ie de dacÄƒ ruleazÄƒ pe un server de dezvoltare sau de producÈ›ie:

ğŸ› ï¸ Modul de dezvoltare (Development):
	- AfiÈ™eazÄƒ bara de depanare Tracy cu informaÈ›ii utile (interogÄƒri SQL, timp de execuÈ›ie, memorie utilizatÄƒ)
	- Ãn caz de eroare, afiÈ™eazÄƒ o paginÄƒ de eroare detaliatÄƒ cu apelurile de funcÈ›ii È™i conÈ›inutul variabilelor
	- ReÃ®nnoieÈ™te automat cache-ul la modificarea È™abloanelor Latte, editarea fiÈ™ierelor de configurare etc.


ğŸš€ Modul de producÈ›ie (Production):
	- Nu afiÈ™eazÄƒ nicio informaÈ›ie de depanare, toate erorile sunt scrise Ã®n log
	- Ãn caz de eroare, afiÈ™eazÄƒ ErrorPresenter sau pagina genericÄƒ "Server Error"
	- Cache-ul nu se reÃ®nnoieÈ™te niciodatÄƒ automat!
	- Optimizat pentru vitezÄƒ È™i securitate


Alegerea modului se face prin autodetecÈ›ie, deci de obicei nu este necesar sÄƒ configuraÈ›i sau sÄƒ comutaÈ›i manual:

- modul de dezvoltare: pe localhost (adresa IP `127.0.0.1` sau `::1`) dacÄƒ nu este prezent un proxy (adicÄƒ antetul sÄƒu HTTP)
- modul de producÈ›ie: oriunde altundeva

DacÄƒ dorim sÄƒ activÄƒm modul de dezvoltare È™i Ã®n alte cazuri, de exemplu pentru programatorii care acceseazÄƒ de la o anumitÄƒ adresÄƒ IP, folosim `setDebugMode()`:

```php
$this->configurator->setDebugMode('23.75.345.200'); // se poate specifica È™i un array de adrese IP
```

RecomandÄƒm cu tÄƒrie combinarea adresei IP cu un cookie. Ãn cookie-ul `nette-debug` salvÄƒm un token secret, de ex. `secret1234`, È™i astfel activÄƒm modul de dezvoltare pentru programatorii care acceseazÄƒ de la o anumitÄƒ adresÄƒ IP È™i au Ã®n acelaÈ™i timp tokenul menÈ›ionat Ã®n cookie:

```php
$this->configurator->setDebugMode('secret1234@23.75.345.200');
```

Putem, de asemenea, sÄƒ dezactivÄƒm complet modul de dezvoltare, chiar È™i pentru localhost:

```php
$this->configurator->setDebugMode(false);
```

AtenÈ›ie, valoarea `true` activeazÄƒ modul de dezvoltare forÈ›at, ceea ce nu trebuie sÄƒ se Ã®ntÃ¢mple niciodatÄƒ pe un server de producÈ›ie.


Instrumentul de depanare Tracy
==============================

Pentru o depanare uÈ™oarÄƒ, vom activa È™i excelentul instrument [Tracy |tracy:]. Ãn modul de dezvoltare, vizualizeazÄƒ erorile, iar Ã®n modul de producÈ›ie, le Ã®nregistreazÄƒ Ã®n directorul specificat:

```php
$this->configurator->enableTracy($this->rootDir . '/log');
```


FiÈ™iere temporare
=================

Nette utilizeazÄƒ cache pentru containerul DI, RobotLoader, È™abloane etc. Prin urmare, este necesar sÄƒ setaÈ›i calea cÄƒtre directorul unde se va stoca cache-ul:

```php
$this->configurator->setTempDirectory($this->rootDir . '/temp');
```

Pe Linux sau macOS, setaÈ›i [permisiuni de scriere |nette:troubleshooting#Setarea permisiunilor pentru directoare] pentru directoarele `log/` È™i `temp/`.


RobotLoader
===========

De regulÄƒ, vom dori sÄƒ Ã®ncÄƒrcÄƒm automat clasele folosind [RobotLoader |robot-loader:], deci trebuie sÄƒ Ã®l pornim È™i sÄƒ Ã®l lÄƒsÄƒm sÄƒ Ã®ncarce clasele din directorul unde este plasat `Bootstrap.php` (adicÄƒ `__DIR__`), È™i din toate subdirectoarele:

```php
$this->configurator->createRobotLoader()
	->addDirectory(__DIR__)
	->register();
```

O abordare alternativÄƒ este sÄƒ lÄƒsÄƒm clasele sÄƒ fie Ã®ncÄƒrcate doar prin [Composer |best-practices:composer] respectÃ¢nd PSR-4.


Timezone
========

Prin intermediul configuratorului puteÈ›i seta fusul orar implicit.

```php
$this->configurator->setTimeZone('Europe/Prague');
```


Configurarea containerului DI
=============================

Parte a procesului de iniÈ›ializare este crearea containerului DI sau a fabricii de obiecte, care este inima Ã®ntregii aplicaÈ›ii. Este de fapt o clasÄƒ PHP, generatÄƒ de Nette È™i salvatÄƒ Ã®n directorul de cache. Fabrica produce obiectele cheie ale aplicaÈ›iei È™i, folosind fiÈ™ierele de configurare, o instruim cum sÄƒ le creeze È™i sÄƒ le seteze, influenÈ›Ã¢nd astfel comportamentul Ã®ntregii aplicaÈ›ii.

FiÈ™ierele de configurare sunt de obicei scrise Ã®n formatul [NEON |neon:format]. Ãntr-un capitol separat veÈ›i afla [ce poate fi configurat |nette:configuring].

.[tip]
Ãn modul de dezvoltare, containerul se actualizeazÄƒ automat la fiecare modificare a codului sau a fiÈ™ierelor de configurare. Ãn modul de producÈ›ie, se genereazÄƒ o singurÄƒ datÄƒ È™i modificÄƒrile nu sunt verificate pentru a maximiza performanÈ›a.

FiÈ™ierele de configurare le Ã®ncÄƒrcÄƒm folosind `addConfig()`:

```php
$this->configurator->addConfig($this->rootDir . '/config/common.neon');
```

DacÄƒ dorim sÄƒ adÄƒugÄƒm mai multe fiÈ™iere de configurare, putem apela funcÈ›ia `addConfig()` de mai multe ori.

```php
$configDir = $this->rootDir . '/config';
$this->configurator->addConfig($configDir . '/common.neon');
$this->configurator->addConfig($configDir . '/services.neon');
if (PHP_SAPI === 'cli') {
	$this->configurator->addConfig($configDir . '/cli.php');
}
```

Numele `cli.php` nu este o greÈ™ealÄƒ de tipar, configuraÈ›ia poate fi scrisÄƒ È™i Ã®ntr-un fiÈ™ier PHP, care o returneazÄƒ ca array.

De asemenea, putem adÄƒuga alte fiÈ™iere de configurare Ã®n [secÈ›iunea `includes` |dependency-injection:configuration#Includerea fiÈ™ierelor].

DacÄƒ Ã®n fiÈ™ierele de configurare apar elemente cu aceleaÈ™i chei, acestea vor fi suprascrise sau, Ã®n cazul [array-urilor, combinate |dependency-injection:configuration#Combinare]. FiÈ™ierul inclus ulterior are prioritate mai mare decÃ¢t cel anterior. FiÈ™ierul Ã®n care este specificatÄƒ secÈ›iunea `includes` are prioritate mai mare decÃ¢t fiÈ™ierele incluse Ã®n el.


Parametri statici
-----------------

Parametrii utilizaÈ›i Ã®n fiÈ™ierele de configurare pot fi definiÈ›i [Ã®n secÈ›iunea `parameters` |dependency-injection:configuration#Parametri] È™i, de asemenea, pot fi transmiÈ™i (sau suprascriÈ™i) prin metoda `addStaticParameters()` (are aliasul `addParameters()`). Este important cÄƒ valorile diferite ale parametrilor determinÄƒ generarea altor containere DI, adicÄƒ a altor clase.

```php
$this->configurator->addStaticParameters([
	'projectId' => 23,
]);
```

La parametrul `projectId` se poate face referire Ã®n configuraÈ›ie prin notaÈ›ia obiÈ™nuitÄƒ `%projectId%`.


Parametri dinamici
------------------

Ãn container putem adÄƒuga È™i parametri dinamici, ale cÄƒror valori diferite, spre deosebire de parametrii statici, nu determinÄƒ generarea de noi containere DI.

```php
$this->configurator->addDynamicParameters([
	'remoteIp' => $_SERVER['REMOTE_ADDR'],
]);
```

Astfel, putem adÄƒuga simplu, de exemplu, variabile de mediu, la care se poate face referire ulterior Ã®n configuraÈ›ie prin notaÈ›ia `%env.variable%`.

```php
$this->configurator->addDynamicParameters([
	'env' => getenv(),
]);
```


Parametri impliciÈ›i
-------------------

Ãn fiÈ™ierele de configurare puteÈ›i utiliza aceÈ™ti parametri statici:

- `%appDir%` este calea absolutÄƒ cÄƒtre directorul cu fiÈ™ierul `Bootstrap.php`
- `%wwwDir%` este calea absolutÄƒ cÄƒtre directorul cu fiÈ™ierul de intrare `index.php`
- `%tempDir%` este calea absolutÄƒ cÄƒtre directorul pentru fiÈ™iere temporare
- `%vendorDir%` este calea absolutÄƒ cÄƒtre directorul unde Composer instaleazÄƒ bibliotecile
- `%rootDir%` este calea absolutÄƒ cÄƒtre directorul rÄƒdÄƒcinÄƒ al proiectului
- `%debugMode%` indicÄƒ dacÄƒ aplicaÈ›ia este Ã®n modul de depanare
- `%consoleMode%` indicÄƒ dacÄƒ cererea a venit prin linia de comandÄƒ


Servicii importate
------------------

Acum intrÄƒm mai Ã®n profunzime. DeÈ™i scopul containerului DI este sÄƒ producÄƒ obiecte, Ã®n mod excepÈ›ional poate apÄƒrea nevoia de a introduce un obiect existent Ã®n container. Facem acest lucru definind serviciul cu flag-ul `imported: true`.

```neon
services:
	myservice:
		type: App\Model\MyCustomService
		imported: true
```

È˜i Ã®n bootstrap introducem obiectul Ã®n container:

```php
$this->configurator->addServices([
	'myservice' => new App\Model\MyCustomService('foobar'),
]);
```


Medii diferite
==============

Nu vÄƒ fie teamÄƒ sÄƒ modificaÈ›i clasa Bootstrap conform nevoilor dvs. PuteÈ›i adÄƒuga parametri metodei `bootWebApplication()` pentru a distinge proiectele web. Sau putem completa cu alte metode, de exemplu `bootTestEnvironment()`, care iniÈ›ializeazÄƒ mediul pentru testele unitare, `bootConsoleApplication()` pentru scripturile apelate din linia de comandÄƒ etc.

```php
public function bootTestEnvironment(): Nette\DI\Container
{
	Tester\Environment::setup(); // iniÈ›ializarea Nette Tester
	$this->setupContainer();
	return $this->configurator->createContainer();
}

public function bootConsoleApplication(): Nette\DI\Container
{
	$this->configurator->setDebugMode(false);
	$this->initializeEnvironment();
	$this->setupContainer();
	return $this->configurator->createContainer();
}
```
