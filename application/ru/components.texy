Интерактивные компоненты
************************

<div class=perex>

Компоненты — это отдельные объекты многократного использования, которые мы помещаем на страницы. Это могут быть формы, сетки данных, опросы, в общем, всё, что имеет смысл использовать многократно. Далее мы узнаем:

- как использовать компоненты?
- как их писать?
- что такое сигналы?

</div>

Nette имеет встроенную систему компонентов. Те, кто постарше, могут помнить нечто подобное из Delphi или ASP.NET Web Forms. React или Vue.js построены на чём-то отдаленно похожем. Однако в мире PHP-фреймворков это совершенно уникальная функция.

В то же время компоненты в корне меняют подход к разработке приложений. Вы можете составлять страницы из заранее подготовленных блоков. Нужна ли вам сетка данных в администрировании? Вы можете найти её на [Componette |https://componette.org/search/component], репозитории открытых дополнений (не только компонентов) для Nette, и просто вставить в презентер.

Вы можете включить в презентер любое количество компонентов. И вы можете вставлять другие компоненты в некоторые компоненты. Это создает дерево компонентов с презентером в качестве корня.


Фабричные методы .[#toc-factory-methods]
========================================

Как размещаются и впоследствии используются компоненты в презентере? Обычно с использованием фабричных методов.

Фабрика компонентов — это элегантный способ создавать компоненты только тогда, когда они действительно нужны (лениво / по требованию). Вся магия заключается в реализации метода `createComponent<Name>()`, где `<Name>` — имя компонента, который будет создан и возвращен.

```php .{file:DefaultPresenter.php}
class DefaultPresenter extends Nette\Application\UI\Presenter
{
	protected function createComponentPoll(): PollControl
	{
		$poll = new PollControl;
		$poll->items = $this->item;
		return $poll;
	}
}
```

Поскольку все компоненты создаются в отдельных методах, код чище и легче читается.

.[note]
Имена компонентов всегда начинаются со строчной буквы, хотя в имени метода они пишутся с заглавной.

Мы никогда не вызываем фабрики напрямую, они вызываются автоматически, когда мы впервые используем компоненты. Благодаря этому компонент создается в нужный момент, и только если он действительно необходим. Если мы не будем использовать компонент (например, при AJAX-запросе, когда мы возвращаем только часть страницы, или когда части кэшируются), он даже не будет создан, и мы сэкономим производительность сервера.

```php .{file:DefaultPresenter.php}
// мы обращаемся к компоненту, и если это было впервые,
// он вызывает createComponentPoll(), чтобы создать его
$poll = $this->getComponent('poll');
// альтернативный синтаксис: $poll = $this['poll'];
```

В шаблоне вы можете визуализировать компонент с помощью тега [{control} |#Rendering]. Поэтому нет необходимости вручную передавать компоненты в шаблон.

```latte
<h2>Проголосуйте, пожалуйста</h2>

{control poll}
```


Голливудский стиль .[#toc-hollywood-style]
==========================================

Компоненты обычно используют один классный прием, который мы любим называть голливудским стилем. Наверняка вы знаете это клише, которое актёры часто слышат на кастингах: «Не звоните нам, мы позвоним вам». И это то, о чём идёт речь.

В Nette, вместо того, чтобы постоянно задавать вопросы («была ли форма отправлена?», «была ли она действительна?», или «нажал ли кто-нибудь на эту кнопку?»), вы говорите фреймворку «когда это произойдет, вызовите этот метод» и оставьте дальнейшую работу над ним. Если вы программируете на JavaScript, вы знакомы с этим стилем программирования. Вы пишете функции, которые вызываются при наступлении определенного события. А движок передает им соответствующие параметры.

Это полностью меняет способ написания приложений. Чем больше задач вы можете делегировать фреймворку, тем меньше у вас работы. И тем меньше вы можете забыть.


Как написать компонент .[#toc-how-to-write-a-component]
=======================================================

Под компонентом мы обычно подразумеваем потомков класса [api:Nette\Application\UI\Control]. Сам презентер [api:Nette\Application\UI\Presenter] также является потомком класса `Control`.

```php .{file:PollControl.php}
use Nette\Application\UI\Control;

class PollControl extends Control
{
}
```


Рендеринг .[#toc-rendering]
===========================

Мы уже знаем, что тег `{control componentName}` используется для рисования компонента. Он фактически вызывает метод `render()` компонента, в котором мы берем на себя заботу о рендеринге. У нас есть, как и в презентере, шаблон [Latte |latte:] в переменной `$this->template`, которому мы передаем параметры. В отличие от использования в презентере, мы должны указать файл шаблона и позволить ему отрисоваться:

```php .{file:PollControl.php}
public function render(): void
{
	// мы поместим некоторые параметры в шаблон
	$this->template->param = $value;
	// и отобразим его
	$this->template->render(__DIR__ . '/poll.latte');
}
```

Тег `{control}` позволяет передавать параметры в метод `render()`:

```latte
{control poll $id, $message}
```

```php .{file:PollControl.php}
public function render(int $id, string $message): void
{
	// ...
}
```

Иногда компонент может состоять из нескольких частей, которые мы хотим отобразить отдельно. Для каждого из них мы создадим свой метод рендеринга, например, `renderPaginator()`:

```php .{file:PollControl.php}
public function renderPaginator(): void
{
	// ...
}
```

А в шаблоне мы затем вызываем его с помощью:

```latte
{control poll:paginator}
```

Для лучшего понимания полезно знать, как тег компилируется в PHP-код.

```latte
{control poll}
{control poll:paginator 123, 'hello'}
```

Это компилируется в:

```php
$control->getComponent('poll')->render();
$control->getComponent('poll')->renderPaginator(123, 'hello');
```

Метод `getComponent()` возвращает компонент `poll` и затем для него вызывается метод `render()` или `renderPaginator()` соответственно.

.[caution]
Если где-либо в части параметров используется **`=>`**, все параметры будут обернуты в массив и переданы в качестве первого аргумента:

```latte
{control poll, id => 123, message => 'hello'}
```

компилируется в:

```php
$control->getComponent('poll')->render(['id' => 123, 'message' => 'hello']);
```

Рендеринг вложенного компонента:

```latte
{control cartControl-someForm}
```

компилируется в:

```php
$control->getComponent("cartControl-someForm")->render();
```

Компоненты, как и презентеры, автоматически передают шаблонам несколько полезных переменных:

- `$basePath` — абсолютный URL путь к корневому каталогу (например, `/CD-collection`).
- `$baseUrl` — абсолютный URL к корневому каталогу (например, `http://localhost/CD-collection`)
- `$user` — это объект, [представляющий пользователя |security:authentication].
- `$presenter` — текущий презентер
- `$control` — текущий компонент
- `$flashes` список [сообщений |#flash-сообщений], отправленных методом `flashMessage()`.


Сигнал .[#toc-signal]
=====================

Мы уже знаем, что навигация в приложении Nette состоит из ссылок или перенаправления на пары `Presenter:action`. Но что если мы просто хотим выполнить действие на **текущей странице**? Например, изменить порядок сортировки столбцов в таблице; удалить элемент; переключить режим light/dark; отправить форму; проголосовать в опросе; и т. д.

Такой тип запроса называется сигналом. И как действия вызывают методы `action<Action>()` или `render<Action>()`, сигналы вызывают методы `handle<Signal>()`. В то время как понятие действия (или просмотра) относится только к презентерам, сигналы относятся ко всем компонентам. А значит и к презентерам, потому что `UI\Presenter` является потомком `UI\Control`.

```php
public function handleClick(int $x, int $y): void
{
	// ... обработка сигнала ...
}
```

Ссылка, вызывающая сигнал, создается обычным способом, т. е. в шаблоне атрибутом `n:href` или тегом `{link}`, в коде методом `link()`. Подробнее в главе [Создание ссылок URL |creating-links#Links-to-Signal].

```latte
<a n:href="click! $x, $y">нажмите сюда</a>
```

Сигнал всегда вызывается на текущем презентере и представлении, поэтому невозможно связать сигнал с другим презентером/действием.

Таким образом, сигнал вызывает перезагрузку страницы точно так же, как и в исходном запросе, только дополнительно он вызывает метод обработки сигнала с соответствующими параметрами. Если метод не существует, выбрасывается исключение [api:Nette\Application\UI\BadSignalException], которое отображается пользователю в виде страницы ошибки 403 Forbidden.


Сниппеты и AJAX .[#toc-snippets-and-ajax]
=========================================

Сигналы могут немного напомнить вам AJAX: обработчики, которые вызываются на текущей странице. И вы правы, сигналы действительно часто вызываются с помощью AJAX, и тогда мы передаем браузеру только измененные части страницы. Они называются сниппетами. Более подробную информацию можно найти на [странице об AJAX |ajax].


Флэш-сообщения .[#toc-flash-messages]
=====================================

Компонент имеет собственное хранилище флэш-сообщений, не зависящее от презентера. Это сообщения, которые, например, информируют о результате операции. Важной особенностью флэш-сообщений является то, что они доступны в шаблоне даже после перенаправления. Даже после отображения они будут оставаться живыми ещё 30 секунд — например, на случай, если пользователь непреднамеренно обновит страницу — сообщение не будет потеряно.

Отправка осуществляется методом [flashMessage |api:Nette\Application\UI\Control::flashMessage()]. Первым параметром является текст сообщения или объект `stdClass`, представляющий сообщение. Необязательный второй параметр — это его тип (ошибка, предупреждение, информация и т. д.). Метод `flashMessage()` возвращает экземпляр flash-сообщения как объект stdClass, которому можно передать информацию.

```php
$this->flashMessage('Элемент был удалён.');
$this->redirect(/* ... */); // делаем редирект
```

В шаблоне эти сообщения доступны в переменной `$flashes` как объекты `stdClass`, которые содержат свойства `message` (текст сообщения), `type` (тип сообщения) и могут содержать уже упомянутую информацию о пользователе. Мы отображаем их следующим образом:

```latte
{foreach $flashes as $flash}
	<div class="flash {$flash->type}">{$flash->message}</div>
{/foreach}
```


Постоянные параметры .[#toc-persistent-parameters]
==================================================

Часто бывает необходимо сохранить какой-либо параметр в компоненте на всё время работы с ним. Это может быть, например, номер страницы в пагинации. Этот параметр должен быть помечен как постоянный с помощью аннотации `@persistent`.

```php
class PollControl extends Control
{
	/** @persistent */
	public $page = 1;
}
```

Этот параметр будет автоматически передаваться в каждой ссылке как параметр `GET` до тех пор, пока пользователь не покинет страницу с этим компонентом.

.[caution]
Никогда не доверяйте постоянным параметрам вслепую, поскольку их можно легко подделать (путем перезаписи URL). Проверьте, например, находится ли номер страницы в правильном интервале.

В PHP 8 вы также можете использовать атрибуты для маркировки постоянных параметров:

```php
use Nette\Application\Attributes\Persistent;

class PollControl extends Control
{
	#[Persistent]
	public $page = 1;
}
```


Постоянные компоненты .[#toc-persistent-components]
===================================================

Постоянными могут быть не только параметры, но и компоненты. Их постоянные параметры также передаются между различными действиями или между различными презентерами. Мы помечаем постоянные компоненты этой аннотацией для класса презентера. Например, здесь мы помечаем компоненты `calendar` и `poll` следующим образом:

```php
/**
 * @persistent(calendar, poll)
 */
class DefaultPresenter extends Nette\Application\UI\Presenter
{
}
```

Вам не нужно помечать подкомпоненты как постоянные, они становятся постоянными автоматически.

В PHP 8 вы также можете использовать атрибуты для маркировки постоянных компонентов:

```php
use Nette\Application\Attributes\Persistent;

#[Persistent('calendar', 'poll')]
class DefaultPresenter extends Nette\Application\UI\Presenter
{
}
```


Компоненты с зависимостями .[#toc-components-with-dependencies]
===============================================================

Если для работы нашего компонента необходимы некоторые зависимости, например, `PollControl` нуждается в `PollFacade` для управления голосованием и сохранения опросов, это можно сделать, передав эти зависимости в конструктор:

```php
class PollControl extends Control
{
	public function __construct(
		private int $id, //  Id опроса, для которого создается компонент
		private PollFacade $facade,
	) {
	}

	public function handleVote(int $voteId): void
	{
		$this->facade->vote($id, $voteId);
		//...
	}
}
```

Хорошо, но как `PollFacade` помещается в конструктор `PollControl`? Для этого нам нужно написать класс-фабрику, который будет создавать экземпляры нашего компонента. Эта фабрика является сервисом, поэтому мы зарегистрируем её как сервис в контейнере DI:

```php
class PollControlFactory
{
	public function __construct(
		private PollFacade $facade,
	) {
	}

	public function create(int $id): PollControl
	{
		return new PollControl($id, $this->facade);
	}
}
```
Теперь мы регистрируем наш сервис в DI-контейнере для конфигурации:

```neon
services:
	- PollControlFactory
```

Наконец, мы будем использовать эту фабрику в нашем презентере:

```php
class PollPresenter extends Nette\UI\Application\Presenter
{
	public function __construct(
		private PollControlFactory $pollControlFactory,
	) {
	}

	protected function createComponentPollControl(): PollControl
	{
		$pollId = 1; // мы можем передать наш параметр
		return $this->pollControlFactory->create($pollId);
	}
}
```

К счастью, Nette может генерировать эти простые фабрики, поэтому мы можем написать просто интерфейс этой фабрики, а DI-контейнер сгенерирует реализацию:

```php
interface PollControlFactory
{
	public function create(int $id): PollControl;
}
```

Мы зарегистрируем этот интерфейс в конфигурации нашего контейнера:

```neon
services:
	- PollControlFactory
```

и использование в презентере такое же, как и использование предыдущей фабрики, мы получим интерфейс через DI и используем его как фабрику.

Вот и всё. Nette внутренне реализует этот интерфейс и передает его нашему презентеру, где мы можем его использовать. Он также магическим образом передает наш параметр `$id` и экземпляр класса `PollFacade` в наш компонент.

Дальнейшее использование компонентов в контексте DI [обсуждается здесь |dependency-injection:factory#component-factory].


Расширенное использование компонентов .[#toc-advanced-use-of-components]
========================================================================

[* lifecycle-component.svg *] *** *Жизненный цикл компонентов* .<>

Компоненты в основном поддаются рендерингу. Но существуют и не поддающиеся восстановлению компоненты. Некоторые компоненты могут иметь потомков, некоторые — нет. Фреймворк Nette представляет несколько классов и интерфейсов для всех этих типов компонентов.

Наследование объектов позволяет нам иметь иерархическую структуру классов, как в реальном мире. Мы можем создавать новые классы путем расширения. Эти расширенные классы являются потомками исходного класса и наследуют его параметры и методы. Расширенный класс может добавлять свои собственные параметры и методы к унаследованным.

Знание иерархии классов необходимо для правильного понимания того, как работают вещи.

```
Nette\ComponentModel\Component  { IComponent }
|
+- Nette\ComponentModel\Container  { IContainer }
	|
	+- Nette\Application\UI\Component  { SignalReceiver, StatePersistent }
		|
		+- Nette\Application\UI\Control  { Renderable }
			|
			+- Nette\Application\UI\Presenter  { IPresenter }
```


Nette\ComponentModel\IComponent .{toc: IComponent}
--------------------------------------------------

Интерфейс [api:Nette\ComponentModel\IComponent] должен быть реализован каждым компонентом. Для этого требуется метод `getName()`, возвращающий имя, и `getParent()`, возвращающий родителя. И имя, и родитель могут быть установлены с помощью метода `setParent()` — первым аргументом является родитель, а вторым — имя.


Nette\ComponentModel\Component .{toc: Component}
------------------------------------------------

[api:Nette\ComponentModel\Component] — это стандартная реализация `IComponent`. Он является общим предком всех компонентов, включая элементы формы. Он имеет несколько методов обхода:

[lookup($type)|api:Nette\ComponentModel\Component::lookup()] ищет объект заданного класса или интерфейса выше по иерархии. Например, `$component->lookup(Nette\Application\UI\Presenter::class)` возвращает презентер, если компоненты привязаны к нему (даже глубоко в иерархии).

[lookupPath($type)|api:Nette\ComponentModel\Component::lookupPath()] возвращает путь — строку, составленную путем конкатенации имен всех компонентов на пути между текущим и компонентом `$type`. Например, `$component->lookupPath(Nette\Application\UI\Presenter::class)` возвращает уникальный идентификатор компонента в направлении презентера.


Nette\ComponentModel\IContainer .{toc: IContainer}
--------------------------------------------------

Родительские компоненты реализуют не только `IComponent`, но и [api:Nette\ComponentModel\IContainer]. Интерфейс, содержащий методы для добавления, удаления, получения и итерации над компонентами. Такие компоненты могут создавать иерархию — презентеры могут содержать формы, а эти формы могут содержать входы форм. Вся древовидная иерархия компонентов создается ветвями объектов `IContainer` и листьями `IComponent`.


Nette\ComponentModel\Container .{toc: Container}
------------------------------------------------

[api:Nette\ComponentModel\Container] — это стандартная реализация интерфейса `IContainer`. Он является предком, например, формы или классов `Control` и `Presenter`.

Он предлагает методы для корректного добавления, получения и удаления объектов и, конечно, итерации над его содержимым. Попытка вызова неопределенного дочернего элемента приводит к вызову фабрики [createComponent($name)|api:Nette\ComponentModel\Container::createComponent()]. Метод `createComponent($name)` вызывает метод `createComponent<component name>` в текущем компоненте и передает имя компонента в качестве параметра. Созданный компонент затем передается в текущий компонент как его дочерний элемент. Мы называем эти компоненты фабриками, они могут быть реализованы в классах, унаследованных от `Container`.


Nette\Application\UI\Component .{toc: Component}
------------------------------------------------

Класс [api:Nette\Application\UI\Component] является предком всех компонентов, используемых в презентере. Компоненты в презентере — это объекты, которые хранятся в презентере в течение его [жизненного цикла |presenters#Life-Cycle-of-Presenter].

Они способны влиять друг на друга, сохранять свои состояния в URL и реагировать на команды (сигналы) пользователя и не обязательно должны быть визуализируемыми.


Nette\Application\UI\Control .{toc: Control}
--------------------------------------------

[Control |api:Nette\Application\UI\Control] — это рендерируемый компонент. Это многократно используемая часть веб-приложения, о которой и пойдет речь во всей этой главе. Говоря о компонентах, мы обычно имеем в виду именно этот класс. Он запоминает, какая часть должна быть отображена в [AJAX-запросе |ajax#invalidation-of-snippets], [о чём мы уже говорили|#Interactive-Components].

`Control` представляет собой не визуальный сектор веб-страницы, а её логическую часть. Его можно отображать многократно, условно и каждый раз с разным шаблоном.


Мониторинг предков .[#toc-monitoring-of-ancestors]
--------------------------------------------------

Компонентная модель в Nette предлагает очень динамичную работу с деревом (компоненты можно удалять, добавлять, перемещать). Было бы ошибкой полагаться на знание родителя (в конструкторе) при создании компонента. В большинстве случаев родитель не известен в момент создания компонента.

Как узнать, когда компонент был добавлен в дерево презентера? Наблюдения за сменой родителя недостаточно, поскольку к презентеру мог быть добавлен родитель родителя. Метод [monitor($type, $attached, $detached)|api:Nette\ComponentModel\Component::monitor()] здесь, чтобы помочь. Каждый компонент может контролировать любое количество классов и интерфейсов. Добавление или удаление сообщается вызовом обратного вызова `$attached` (`$detached` соответственно), где передается объект контролируемого класса.

Пример: Класс `UploadControl`, представляющий элемент формы для загрузки файлов в Nette Forms, должен установить атрибут формы `enctype` в значение `multipart/form-data`. Но в момент создания объекта он не должен быть привязан к какой-либо форме. Когда изменять форму? Решение простое — мы создаем запрос на мониторинг в конструкторе:

```php
class UploadControl extends Nette\Forms\Controls\BaseControl
{
	public function __construct($label)
	{
		$this->monitor(Nette\Forms\Form::class, function ($form): void {
			$form->setHtmlAttribute('enctype', 'multipart/form-data');
		});
		// ...
	}

	// ...
}
```

и когда форма будет доступна, будет вызван обратный вызов. (Раньше вместо этого использовались методы `attached` или `detached`).


Итерация над потомками .[#toc-iterating-over-children]
------------------------------------------------------

Для этого существует метод [getComponents($deep = false, $type = null)|api:Nette\ComponentModel\Container::getComponents()]. Первый параметр определяет, следует ли искать компоненты в глубину (рекурсивно). При значении `true` итерируются не только все его дочерние элементы, но и все дочерние элементы его дочерних элементов и т. д. Второй параметр серверов как дополнительный фильтр по классу или интерфейсу.

Например, так происходит внутренняя валидация форм:

```php
$valid = true;
foreach ($form->getComponents(true, Nette\Forms\IControl::class) as $control) {
	if (!$control->getRules()->validate()) {
		$valid = false;
		break;
	}
}
```


Сигналы в глубину .[#toc-signals-in-depth]
------------------------------------------

Сигнал вызывает перезагрузку страницы подобно исходному запросу (за исключением AJAX) и вызывает метод `signalReceived($signal)`, реализация которого по умолчанию в классе `Nette\Application\UI\Component` пытается вызвать метод, состоящий из слов `handle{Signal}`. Дальнейшая обработка зависит от данного объекта. Объекты, являющиеся потомками `Component` (т. е. `Control` и `Presenter`), пытаются вызвать `handle{Signal}` с соответствующими параметрами.

Другими словами: берется определение метода `handle{Signal}` и все параметры, которые были получены в запросе, сопоставляются с параметрами метода. Это означает, что параметр `id` из URL сопоставляется с параметром метода `$id`, `something` — с `$something` и так далее. А если метод не существует, то метод `signalReceived` выбрасывает [исключение |api:Nette\Application\UI\BadSignalException].

Сигнал может быть получен любым компонентом, ведущим объектом, реализующим интерфейс `SignalReceiver`, если он подключен к дереву компонентов.

Основными получателями сигналов являются презентеры и визуальные компоненты, расширяющие `Control`. Сигнал — это знак для объекта, что он должен что-то сделать — опрос засчитывает голос пользователя, ящик с новостями должен развернуться, форма была отправлена и должна обработать данные и так далее.

URL для сигнала создается с помощью метода [Component::link() |api:Nette\Application\UI\Component::link()]. В качестве параметра `$destination` передается строка `{signal}!`, а в качестве `$args` — массив аргументов, которые мы хотим передать обработчику сигнала. Параметры сигнала привязываются к URL текущего презентера/представления. **Параметр `?do` в URL определяет вызываемый сигнал.**

Его формат — `{signal}` или `{signalReceiver}-{signal}`. `{signalReceiver}` — это имя компонента в презентере. Именно поэтому дефис (неточно тире) не может присутствовать в имени компонентов — он используется для разделения имени компонента и сигнала, но можно составить несколько компонентов.

Метод [isSignalReceiver()|api:Nette\Application\UI\Presenter::isSignalReceiver()] проверяет, является ли компонент (первый аргумент) приемником сигнала (второй аргумент). Второй аргумент может быть опущен — тогда выясняется, является ли компонент приемником какого-либо сигнала. Если второй параметр равен `true`, то проверяется, является ли компонент или его потомки приемниками сигнала.

В любой фазе, предшествующей `handle{Signal}`, сигнал можно выполнить вручную, вызвав метод [processSignal()|api:Nette\Application\UI\Presenter::processSignal()], который берет на себя ответственность за выполнение сигнала. Принимает компонент-приемник (если он не установлен, то это сам презентер) и посылает ему сигнал.

Пример:

```php
if ($this->isSignalReceiver($this, 'paging') || $this->isSignalReceiver($this, 'sorting')) {
	$this->processSignal();
}
```

Сигнал выполняется преждевременно и больше не будет вызван.



/--comment
Сигнал вызывает перезагрузку страницы подобно исходному запросу (за исключением AJAX) и вызывает метод `signalReceived($signal)`, реализация которого по умолчанию в классе `Nette\Application\UI\Component` пытается вызвать метод, состоящий из слов `handle{Signal}`. Дальнейшая обработка зависит от данного объекта. Объекты, которые являются потомками `Component` (т. е. `Control` и `Presenter`) пытаются вызвать `handle{Signal}` с соответствующими параметрами.
\--
