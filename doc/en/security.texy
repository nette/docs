User authorization and privileges
*********************************

/--div .[perex]
Little to none web applications need no mechanism for user login or checking user privileges. In this chapter, we'll talk about:

- user login and logout
- verifying user privileges
- securing against vulnerabilities
- how to create custom authenticators and authorizators
- Access Control List
\--


Before we fully emerge this topic, we should note that all examples do use `user` service, which is an [api:Nette\Http\User] object. The service itself can be get from [system container |configuring] using `$user = $container->user` or `$user = $this->getUser()` inside a presenter.


Authentication
==============

Authentication means **user login**, the process during which we check whether the user is who he claims he is. It's usually proved with simple username and password combination.

Loging user in with username and password:

/--php
$user->login($username, $password);
\--

Checking if user is logged in:

/--php
echo $user->isLoggedIn() ? 'yes' : 'no';
\--

And logging him out:

/--php
$user->logout();
\--

Simple, right?

.[note]
Logging in requires users to have cookies enabled - other methods are not safe!

Besides loging user out with the `logout()` method, it can be done automatically based on specified time interval or closing the browser window. For this configuration we have to call `setExpiration()` during the login process. As an argument, it takes an relative time in seconds, UNIX timestamp, or textual interpretation of time. The second argument sets whether user should be logged out when browser is closed.

/--php
// login expires after 30 minutes of inactivity or after closing browser
$user->setExpiration('+ 30 minutes', TRUE);

// login expires after two days of inactivity
$user->setExpiration('+ 2 days', FALSE);

// login expires when a browser is closed, but not sooner (ie. without a time limit)
$user->setExpiration(0, TRUE);
\--

.[note]
Expiration must be set to equal or lower value, than [sessions]' expiration is set to.

The reason of last logout is returned by `$user->getLogoutReason()`, which yells one of these constants: `User::INACTIVITY` if time expired, `User::BROWSER_CLOSED` when user has closed the browser or `User::MANUAL` when we called the `logout()` method.

To make the example above working, we in fact have to create an object that verifies user's name and password. It's called **authenticator**. It's trivial implementation is class [api:Nette\Security\SimpleAuthenticator], which takes an hash map of usernames as indexes and passwords as values:

/--php
$authenticator = new Nette\Security\SimpleAuthenticator(array(
	'john' => 'IJ^%4dfh54*',
	'kathy' => '12345', // Kathy, this is a very weak password!
));
$user->setAuthenticator($authenticator);
\--

If login createntials are not valid, authenticator throws an [api:Nette\Security\AuthenticationException]:

/--php
try {
	// we try to log the user in
	$user->login($username, $password);
	// ... and redirect upon success
	$this->redirect(...);

} catch (Nette\Security\AuthenticationException $e) {
	echo 'Login error: ', $e->getMessage();
}
\--

We usually configure authenticator inside a [config file |configuring], which only creates the object if it's requested by the application. The example above would be set in `config.neon` as follows:

/--
common:
	services:
		authenticator:
			class: Nette\Security\SimpleAuthenticator
			arguments: [[
				john: IJ^%4dfh54*
				kathy: 12345
			]]
\--


Custom authenticator
--------------------

We will create a custom authenticator that will check validity of login credentials against a database table. Every authenticator must be and implementation of [api:Nette\Security\IAuthenticator], with is't only method `authenticate()`. It's only purpose is to return an [identity | #identity] or to throw an `Nette\Security\AuthenticationException`. Framework defines a few error codes, which can be used to determine the reason login was not successful, such as self-explaining `IAuthenticator::IDENTITY_NOT_FOUND` or `IAuthenticator::INVALID_CREDENTIAL`.

/--php
use Nette\Security as NS;

class MyAuthenticator extends Nette\Object implements NS\IAuthenticator
{
	public $connection;

	function __construct(Nette\Database\Connection $connection)
	{
		$this->connection = $connection;
	}

	function authenticate(array $credentials)
	{
		list($username, $password) = $credentials;
		$row = $this->connection->table('users')
			->where('username', $username)->fetch();

		if (!$row) {
			throw new NS\AuthenticationException('User not found.');
		}

		if ($row->password !== md5($password)) {
			throw new NS\AuthenticationException('Invalid password.');
		}

		return new NS\Identity($row->id, $row->role);
	}
}
\--

Class `MyAuthenticator` communicates with database using [Nette\Database |database] layer and works with table `users`,  where it grabs `username` and md5 hash of `password` in the appropriate columns. If the password check is successful, it returnrs new identity with user ID and role, which we will mention [later | #roles];

This authenticator would be configured in the `config.neon` file like this:

/--
common:
	services:
		authenticator:
			class: MyAuthenticator
			arguments: [@database]

		database:
			class: Nette\Database\Connection
			arguments: [..., ..., ...] # database access (DSN, user, password)
\--


Identity
--------

Identity presents a set of user information, as returned by autheticator. It's an object implementing [api:Nette\Security\IIdentity] interface, with default implementation [api:Nette\Security\Identity].
Class has methods `getId()`, that returns users ID (for example primary key for the respective database row), and `getRoles()`, which returns an array of all roles user is in. User data can be access as if they were identity properties.

Identity is not erased when user is logged out. So, if identity exists, it by itself does not grant that user is also logged in. If we would explicitly delete the identity for some reason, we can logout user with `$user->logout(TRUE)`.

Service `user` of class [api:Nette\Http\User] keeps identity in session and uses it to all authorizations.
Identity can be access with `getIdentity` upon `$user`:

/--php
if ($user->isLoggedIn()) {
	echo 'Logged in user: ', $user->getIdentity()->getId();
} else {
	echo 'User logged out';
}
\--



Authorization
=============

Authorization detects whether an user has enough privilege to do some action, for example opening a file or deleting an article. Authorization assumes that user has been successfully authenticated (logged in).

Nette Framework authorization may be based on what groups does user belong to or which roles user has got. We will start at the very beginning.

Simple web sites with few administrator, where all users have same privileges, may use only already mentioned `isLoggedIn()` method. Simply put, if user is logged in, he has permission to all actions, and vice versa.

/--php
if ($user->isLoggedIn()) { // is user logged in?
	deleteItem(); // if so, he may delete an item
}
\--


Roles
-----

The purpose of roles is to offer a more precise privilege control while not depending on a user name. As soon as user logs in, we give his identity one or more roles. Roles itself may be a simple strings, such as `admin`, `member`, `guest`, etc. They are set via a second argument of `Identity` constructor, either a string or an array.

This time we will use `isInRole()` to check if user is allowed to take some action:

/--php
if ($user->isInRole('admin')) { // is user an admin?
	deleteItem(); // if so, he may delete an item
}
\--

As you already know, logging user out does not erase his identity. So the method `getIdentity()` still returns an `Identity` object, with all roles as before the logout. Nette Framework does profess an "less code, more security" principle, which leads to not forcing coders to write `if ($user->isLoggedIn() && $user->isInRole('admin'))` everwhere and that's why `isInRole()` method does work with **efective roles*. If user is logged out, his identity is explicitly returned as `guest`, ignoring any identity that might be present.

Authorizator
------------

Authorizator decides, whether user has permission to take some action. It's an implementation of [api:Nette\Security\IAuthorizator] interface with only one method `isAllowed()`, which either allows an an action if given *role* is allowed to do certain *operation* with specific *resource*, or denies it.

- **role** is an user attribute - for example moderator, editor, visitor, registered user, administrator, ...
- **resource** is an logical unit - article, page, user, menu item, poll, presenter, ...
- **privilege** is a specific activity, which user may or may not do with *resource* - view, edit, delete, vote, ...


An implementation skeleton looks like this:

/--php
class MyAuthorizator extends Nette\Object
	implements Nette\Security\IAuthorizator
{

	function isAllowed($role, $resource, $privilege)
	{
		return ...; // returns either TRUE or FALSE
	}

}
\--

And an usage example:

/--php
// registeres authorizator
$user->setAuthorizator(new MyAuthorizator);

if ($user->isAllowed('file')) { // is user allowed to do everything with resource 'file'?
	useFile();
}

if ($user->isAllowed('file', 'delete')) { // is user allowed to delete a resource 'file'?
	deleteFile();
}
\--

.[note]
Do not confuse two different methods `isAllowed`: one belongs to authorizator and the other one to the `User` class, where first argument is not `$role`.

Because user may have many roles, the permission is granted if at least one roles is allowed. Both arguments are optional and defaults to *everything*.


Permission ACL
--------------
Nette Framework has a complete authorizator, class [api:Nette\Security\Permission] which offers a light weight and flexible ACL((Access Control List)) layer for permission and access control. All permissions are set for roles, resources and specific privileges. Roles and resources may be linked to hierarchies, as shown in the following snippet:

- `guest`: logged out visitor, allowrd read and browser public part of the web, that is articles, comments and vote in poll

- `registered`: loggin in user, which may as well post comments

- `administrator`: may write and manage articles, comments and polls

We have defined certain roles (`guest`, `registered` and `administrator`) and metioned resources (`article`, `comments`, `poll`), which users may access or take actions on (`view`, `vote`, `add`, `edit`).

We create an instance of Presmission and define user roles. As roles may inherit each other, we may for example specify that `administrator` may do the same as an ordinary visitor (an of course more).

/--php
$acl = new Nette\Security\Permission;

// roles definition
$acl->addRole('guest');
$acl->addRole('registered', 'guest'); // registered inherits from guest
$acl->addRole('administrator', 'registered'); // and administrator inherits from registered
\--

Trivial, isn't it? This ensures all properties are set from parent role to it's children.

Do note method `getRoleParents()`, which returns an array of all parent roles, and method `roleIntheritsFrom()`, which check whether on role extends the other. Their usage:

/--php
$acl->roleInheritsFrom('administrator', 'guest'); // TRUE
$acl->getRoleParents('administrator'); // array('guest', 'registered')
\--

It's right time to define proper resources which users may acccess:

/--php
$acl->addResource('article');
$acl->addResource('comments');
$acl->addResource('poll');
\--

Also resources may use inheritance. The API offeres similar methods, only the names are slightly different: `resourceInheritsFrom()`, `removeResource()`.

And now to the most important part. Roles and resources alone would do us no good, we have to create rules defining who can do what with whatever:

TODO: chybí příklad deny()

/--php
// everything is denied now

// guest may view articles, comments and polls
$acl->allow('guest', array('article', 'comments', 'poll'), 'view');

// registered user has also right to add comments
$acl->allow('registered', 'comments', 'add');

// administrator may also edit and add everything
$acl->allow('administrator', Permission::ALL, array('view', 'edit', 'add'));
\--

With set of rules, we may ask authorization simple questions:

/--php
// can guest view articles?
echo $acl->isAllowed('guest', 'article', 'view'); // TRUE
// can guest edit an article?
echo $acl->isAllowed('guest', 'article', 'edit'); // FALSE
// may guest add comments?
echo $acl->isAllowed('guest', 'comments', 'add'); // FALSE
\--

The same is true for the registered user, though he is allowed to add a comment:

/--php
echo $acl->isAllowed('registered', 'article', 'view'); // TRUE
echo $acl->isAllowed('registered', 'comments', 'add'); // TRUE
echo $acl->isAllowed('registered', 'backend', 'view'); // FALSE
\--

Administrator is allowed to do everything:

/--php
echo $acl->isAllowed('administrator', 'article', 'view'); // TRUE
echo $acl->isAllowed('administrator', 'commend', 'add'); // TRUE
echo $acl->isAllowed('administrator', 'poll', 'edit'); // TRUE
\--

Admin rules may possibly be defined without any restrictions (without inheriting from any other roles):

/--php
$acl->addRole('supervisor');
$acl->allow('supervisor');  // all privileges for all resources for supervisor
\--

Whenever during the application runtime we may remove roles `removeRoll()`, resources `removeResource()` or rules `removeAllow()` or `removeDeny()`.

Roles may inherith form one or more other roles. What happens, if one ancestor has a certain action allowed and the other one denied? Then the *role weight* comes into play - the last role in the array of roles to inherit has the greatest weight, first one the lowest:

/--php
$acl = new Permission();
$acl->addRole('admin');
$acl->addRole('guest');

$acl->addResource('backend');

$acl->allow('admin', 'backend');
$acl->deny('guest', 'backend');

// example A: role admin has lower weight than role guest
$acl->addRole('john', array('admin', 'guest'));
$acl->isAllowed('john', 'backend'); // FALSE

// example B: role admin has greater weight than role guest
$acl->addRole('mary', array('guest', 'admin'));
$acl->isAllowed('mary', 'backend'); // TRUE
\--


Multiple applications in one scope
==================================

Multiple applications may work on the same server, session, etc., each with separated authentication logic. It's enough to set a unique namespace for each:

/--php
$user->setNamespace('forum');
\--


Events: onLoggedIn, onLoggedOut
===============================

`user` service offers events: `onLoggedIn` and `onLoggedOut`, useful for logging authorization activities on the website. `onLoggedIn` event is called only when user has logged in successfully and the other one `onLoggedOut` when user is logged out.

{{themeicon: icon-key.png}}
