Презентери
**********
<div class=perex>


Навчимося створювати презентери та шаблони в Nette. Після прочитання цієї статті ви дізнаєтеся:

- як працює презентер
- що таке постійні параметри
- як відрендерити шаблон

</div>

[Ми вже знаємо |how-it-works#Nette-Application], що презентер - це клас, який представляє конкретну сторінку веб-додатка, як-от головна сторінка; сторінка товару в інтернет-магазині; форма авторизації; мапа сайту тощо. Додаток може мати від одного до тисячі презентерів. В інших фреймворках вони також відомі як контролери.

Зазвичай термін *презентер* співвідноситься з нащадком класу [api:Nette\Application\UI\Presenter], який підходить для веб-інтерфейсів. Ми обговоримо цей клас у решті частини цього розділу. У загальному сенсі, презентер - це будь-який об'єкт, що реалізує інтерфейс [api:Nette\Application\IPresenter].


Життєвий цикл презентера .[#toc-life-cycle-of-presenter]
========================================================

Завдання ведучого - обробити запит і повернути відповідь (яка може бути HTML-сторінкою, зображенням, редиректом тощо).

Отже, на початку - запит. Це не безпосередньо HTTP-запит, а об'єкт [api:Nette\Application\Request], у який HTTP-запит було перетворено за допомогою маршрутизатора. Зазвичай ми не стикаємося з цим об'єктом, тому що презентер спритно делегує обробку запиту спеціальним методам, які ми зараз побачимо.

[* lifecycle.svg *] *** *Життєвий цикл презентера* .<>

На малюнку показано список методів, які викликаються послідовно зверху вниз, якщо вони існують. Усі вони необов'язкові, ми можемо мати абсолютно порожній презентер без жодного методу і побудувати на ньому простий статичний веб.


`__construct()`
---------------

Конструктор не зовсім належить до життєвого циклу презентера, оскільки викликається в момент створення об'єкта. Але ми згадуємо його через важливість, оскільки він використовується для передачі залежностей.

Презентер не повинен піклуватися про бізнес-логіку застосунку, писати і читати з бази даних, виконувати обчислення тощо. Це завдання для класів із шару, який ми називаємо моделлю. Наприклад, клас `ArticleRepository` може відповідати за завантаження і збереження статей. Для того щоб презентер міг його використовувати, він [передається за допомогою впровадження залежностей |dependency-injection:passing-dependencies]:


```php
class ArticlePresenter extends Nette\Application\UI\Presenter
{
	public function __construct(
		private ArticleRepository $articles,
	) {
	}
}
```


`startup()`
-----------

Відразу після отримання запиту викликається метод `startup()`. Ви можете використовувати його для ініціалізації властивостей, перевірки привілеїв користувача тощо. Потрібно завжди викликати предка `parent::startup()`.


`action<Action>(args...)` .{toc: action<Action>()}
--------------------------------------------------

Аналогічний методу `render<View>()`. У той час як `render<View>()` призначена для підготовки даних для певного шаблону, який згодом рендериться, в `action<Action>()` запит обробляється без подальшого рендерингу шаблону. Наприклад, дані обробляються, користувач входить або виходить із системи тощо, а потім [перенаправляється в інше місце |#Redirection].

Важливо, що `action<Action>()` викликається перед `render<View>()`, тому всередині нього ми можемо, можливо, змінити наступний хід життєвого циклу, тобто змінити шаблон, який буде відображатися, а також метод `render<View>()`, який буде викликатися, використовуючи `setView('otherView')`.

У метод передаються параметри із запиту. Можна і рекомендується вказувати типи для параметрів, наприклад `actionShow(int $id, string $slug = null)` - якщо параметр `id` відсутній або якщо він не є цілим числом, презентер повертає [помилку 404 |#Error-404-etc] і завершує операцію.


`handle<Signal>(args...)` .{toc: handle<Signal>()}
--------------------------------------------------

Цей метод обробляє так звані сигнали, про які ми поговоримо в розділі про [Компоненти |components#Signal]. Він призначений в основному для компонентів і обробки AJAX-запитів.

Параметри передаються методу, як у випадку `action<Action>()`включно з перевіркою типу.


`beforeRender()`
----------------

Метод `beforeRender`, як випливає з назви, викликається перед кожним методом `render<View>()`. Використовується для загального налаштування шаблону, передачі змінних для верстки тощо.


`render<View>(args...)` .{toc: render<View>()}
----------------------------------------------

Місце, де ми готуємо шаблон до подальшого рендерингу, передаємо йому дані тощо.

Параметри передаються методу, як у випадку `action<Action>()`, включно з перевіркою типу.

```php
public function renderShow(int $id): void
{
	// ми отримуємо дані з моделі та передаємо їх у шаблон
	$this->template->article = $this->articles->getById($id);
}
```


`afterRender()`
---------------

Метод `afterRender`, як випливає з назви, викликається після кожного методу `render<View>()`. Він використовується досить рідко.


`shutdown()`
------------

Викликається наприкінці життєвого циклу презентера.


**Хороша порада, перш ніж ми продовжимо**. Як ви бачите, презентер може обробляти більше дій/переглядів, тобто мають більше методів `render<View>()`. Але ми рекомендуємо розробляти презентери з однією або якомога меншою кількістю дій.


Надсилання відповіді .[#toc-sending-a-response]
===============================================

Зазвичай відповіддю ведучого є [рендеринг шаблону з HTML-сторінкою |templates], але це також може бути надсилання файлу, JSON або навіть перенаправлення на іншу сторінку.

У будь-який момент життєвого циклу ми можемо використовувати один із таких методів для надсилання відповіді та завершення роботи презентера:

- [Перенаправлення |#Redirection] `redirect()`, `redirectPermanent()`, `redirectUrl()` і `forward()`.
- `error()` завершує роботу презентера [через помилку |#Error-404-etc].
- `sendJson($data)` виходить із презентера і надсилає дані у форматі JSON
- `sendTemplate()` завершує роботу презентера і відразу ж виконує рендеринг шаблону
- `sendResponse($response)` виходить із презентера та надсилає [власну відповідь |#Ответы].
- `terminate()` завершує роботу презентера без відповіді

**Зараз щось важливе**: якщо ми явно не говоримо, яку відповідь має надіслати презентер, відповіддю буде [рендеринг шаблонів |#Рендеринг шаблонов] HTML. Чому? Ну, тому що в 99% випадків ми хочемо відрендерити шаблон, тому презентер приймає таку поведінку за замовчуванням і хоче полегшити нашу роботу.


Створення посилань .[#toc-creating-links]
=========================================

У презентера є метод `link()`, який використовується для створення URL-посилань на інші презентери. Першим параметром є цільовий презентер і дія, потім йдуть аргументи, які можуть бути передані у вигляді масиву:

```php
$url = $this->link('Product:show', $id);

$url = $this->link('Product:show', [$id, 'lang' => 'en']);
```

У шаблоні ми створюємо посилання на інші презентери та дії таким чином:

```latte
<a n:href="Product:show $id">страница товара</a>
```

Просто напишіть знайому пару `Presenter:action` замість реального URL і включіть будь-які параметри. Хитрість полягає в `n:href`, який говорить, що цей атрибут буде оброблений Latte і згенерує справжній URL. У Nette вам взагалі не потрібно думати про URL-адреси, тільки про презентери та дії.

Для отримання додаткової інформації див. [Створення посилань |creating-links].


Перенаправлення .[#toc-redirection]
===================================

Для переходу до іншого презентера використовуються методи `redirect()` і `forward()`, які мають дуже схожий синтаксис із методом [link() |#Creating-Links].

Функція `forward()` перемикає на новий презентер негайно без перенаправлення HTTP:

```php
$this->forward('Product:show');
```

Приклад тимчасового перенаправлення з HTTP-кодом 302 або 303:

```php
$this->redirect('Product:show', $id);
```

Для досягнення постійного перенаправлення з HTTP-кодом 301 використовуйте:

```php
$this->redirectPermanent('Product:show', $id);
```

Ви можете перенаправити на інший URL поза додатком за допомогою методу `redirectUrl()`:

```php
$this->redirectUrl('https://nette.org');
```

Перенаправлення негайно завершує життєвий цикл презентера, викидаючи так зване виключення мовчазного завершення `Nette\Application\AbortException`.

Перед перенаправленням можна надіслати [флеш-повідомлення |#Flash-Messages], яке відображатиметься в шаблоні після перенаправлення.


Флеш-повідомлення .[#toc-flash-messages]
========================================

Це повідомлення, які зазвичай інформують про результат операції. Важливою особливістю флеш-повідомлень є те, що вони доступні в шаблоні навіть після перенаправлення. Навіть після відображення вони залишатимуться живими ще 30 секунд - наприклад, на випадок, якщо користувач ненавмисно оновить сторінку - повідомлення не буде загублено.

Просто викличте метод [flashMessage() |api:Nette\Application\UI\Control::flashMessage()] і презентер подбає про передачу повідомлення в шаблон. Перший аргумент - текст повідомлення, а другий необов'язковий аргумент - його тип (помилка, попередження, інформація тощо). Метод `flashMessage()` повертає екземпляр флеш-повідомлення, щоб ми могли додати додаткову інформацію.

```php
$this->flashMessage('Item was removed.');
$this->redirect(/* ... */);
```

У шаблоні ці повідомлення доступні у змінній `$flashes` як об'єкти `stdClass`, які містять властивості `message` (текст повідомлення), `type` (тип повідомлення) і можуть містити вже згадану інформацію про користувача. Ми виводимо їх таким чином:

```latte
{foreach $flashes as $flash}
	<div class="flash {$flash->type}">{$flash->message}</div>
{/foreach}
```


Помилка 404 тощо. .[#toc-error-404-etc]
=======================================

Коли ми не можемо виконати запит, тому що, наприклад, стаття, яку ми хочемо відобразити, не існує в базі даних, ми викинемо помилку 404, використовуючи метод `error(string $message = null, int $httpCode = 404)`, який представляє HTTP-помилку 404:

```php
public function renderShow(int $id): void
{
	$article = $this->articles->getById($id);
	if (!$article) {
		$this->error();
	}
	// ...
}
```

Код помилки HTTP може бути переданий як другий параметр, за замовчуванням це 404. Метод працює, викидаючи виняток `Nette\Application\BadRequestException`, після чого `Application` передає управління презентуванню помилки. Його завдання - відобразити сторінку, що інформує про помилку.
Преселектор помилок встановлюється в [конфігураціях програми |configuration].


Надсилання JSON .[#toc-sending-json]
====================================

Приклад дії-методу, який надсилає дані у форматі JSON і виходить із ведучого:

```php
public function actionData(): void
{
	$data = ['hello' => 'nette'];
	$this->sendJson($data);
}
```


Постійні параметри .[#toc-persistent-parameters]
================================================

Постійні параметри **передаються автоматично** у посиланнях. Це означає, що нам не потрібно явно вказувати їх у кожному `link()` або `n:href` у шаблоні, але вони все одно будуть передані.

Якщо ваш додаток має кілька мовних версій, то поточна мова є параметром, який завжди повинен бути частиною URL. І було б неймовірно утомливо згадувати про це в кожному посиланні. З Nette в цьому немає необхідності. Таким чином ми просто позначаємо параметр `lang` як постійний:

```php
class ProductPresenter extends Nette\Application\UI\Presenter
{
	/** @persistent */
	public $lang;
}
```

Якщо поточне значення параметра `lang` дорівнює `'en'`, то URL, створений за допомогою `link()` або `n:href` у шаблоні, міститиме `lang=en`. Чудово!

Однак ми також можемо додати параметр `lang` і тим самим змінити його значення:

```latte
<a n:href="Product:show $id, lang: en">подробности на английском</a>
```

Або, навпаки, його можна видалити, встановивши в null:

```latte
<a n:href="Product:show $id, lang: null">нажмите здесь</a>
```

Постійна змінна має бути оголошена як public. Ми також можемо вказати значення за замовчуванням. Якщо параметр має те саме значення, що й значення за замовчуванням, його не буде включено в URL.

Сталість відображає ієрархію класів презентерів, тому параметр, визначений у конкретному презентері або трейте, автоматично передається кожному презентеру, який успадковує від нього або використовує той самий трейт.

У PHP 8 ви також можете використовувати атрибути для маркування постійних параметрів:

```php
use Nette\Application\Attributes\Persistent;

class ProductPresenter extends Nette\Application\UI\Presenter
{
	#[Persistent]
	public $lang;
}
```


Інтерактивні компоненти .[#toc-interactive-components]
======================================================

У презентерів є вбудована система компонентів. Компоненти - це окремі багаторазово використовувані одиниці, які ми поміщаємо в презентери. Це можуть бути [форми |forms:in-presenter], сітки даних, меню, загалом, усе, що має сенс використовувати багаторазово.

Як розміщуються і згодом використовуються компоненти в презентері? Це пояснюється в розділі [компоненти |components]. Ви навіть дізнаєтеся, який стосунок вони мають до Голлівуду.

Де можна придбати деякі компоненти? На сторінці [Componette |https://componette.org] ви можете знайти деякі компоненти з відкритим вихідним кодом та інші доповнення для Nette, що створюються та розповсюджуються спільнотою фреймворку Nette.


Заглиблюємося .[#toc-going-deeper]
==================================

.[tip]
Того, що ми показали досі в цьому розділі, ймовірно, буде достатньо. Наступні рядки призначені для тих, хто цікавиться презентерами досконально і хоче знати все.


Вимоги та параметри .[#toc-requirement-and-parameters]
------------------------------------------------------

Запит, що обробляється презентером, є об'єктом [api:Nette\Application\Request] і повертається методом презентера `getRequest()`. Він містить масив параметрів, кожен з яких належить або якомусь із компонентів, або безпосередньо презентеру (який насправді теж є компонентом, хоча й спеціальним). Таким чином, Nette перерозподіляє параметри і передається між окремими компонентами (і презентером) шляхом виклику методу `loadState(array $params)`, який детальніше описано в розділі [Компоненти |components]. Параметри можна отримати за допомогою методу `getParameters(): array`, індивідуально використовуючи `getParameter($name)`. Значення параметрів - це рядки або масиви рядків, в основному це необроблені дані, отримані безпосередньо з URL.


Збереження та відновлення запиту .[#toc-save-and-restore-the-request]
---------------------------------------------------------------------

Ви можете зберегти поточний запит у сесії або відновити його із сесії та дозволити презентеру виконати його знову. Це корисно, наприклад, коли користувач заповнює форму, а термін дії його логіна закінчується. Щоб не втратити дані, перед перенаправленням на сторінку реєстрації ми зберігаємо поточний запит у сесію за допомогою функції `$reqId = $this->storeRequest()`, яка повертає ідентифікатор у вигляді короткого рядка і передає його як параметр презенту для реєстрації.

Після входу в систему ми викликаємо метод `$this->restoreRequest($reqId)`, який забирає запит у сесії та пересилає його їй. Метод перевіряє, що запит був створений тим самим користувачем, який зараз увійшов у систему. Якщо інший користувач увійшов у систему або ключ недійсний, він нічого не робить, і програма продовжує роботу.

Див. розділ [Як повернутися на попередню сторінку |best-practices:restore-request].


Канонізація .[#toc-canonization]
--------------------------------

У презентерів є одна справді чудова функція, яка покращує SEO. Вони автоматично запобігають існуванню дублюючого контенту на різних URL-адресах. Якщо кілька URL-адрес ведуть до певного місця призначення, наприклад, `/index` і `/index?page=1`, фреймворк призначає одну з них основною (канонічною) і перенаправляє на неї решту за допомогою HTTP-коду 301. Завдяки цьому пошукові системи не індексують сторінки двічі і не послаблюють їхній рейтинг.

Цей процес називається канонізацією. Канонічний URL - це URL, згенерований [маршрутом |routing], зазвичай перший відповідний маршрут у колекції.

Канонізація ввімкнена за замовчуванням і може бути вимкнена за допомогою `$this->autoCanonicalize = false`.

Перенаправлення не відбувається під час запиту AJAX або POST, оскільки це призведе до втрати даних або не принесе жодної користі для SEO.

Ви також можете викликати канонізацію вручну за допомогою методу `canonicalize()`, який, як і метод `link()`, отримує як аргументи презентера, дії та параметри. Він створює посилання і порівнює його з поточним URL. Якщо вони відрізняються, то відбувається перенаправлення на згенероване посилання.

```php
public function actionShow(int $id, string $slug = null): void
{
	$realSlug = $this->facade->getSlugForId($id);
	// перенаправляє, якщо $slug відрізняється від $realSlug
	$this->canonicalize('Product:show', [$id, $realSlug]);
}
```


Події .[#toc-events]
--------------------

Крім методів `startup()`, `beforeRender()` і `shutdown()`, які викликаються в рамках життєвого циклу презентера, можна визначити інші функції, які будуть викликатися автоматично. Презентер визначає так звані [події |nette:glossary#Events], а ви додаєте їхні обробники в масиви `$onStartup`, `$onRender` і `$onShutdown`.

```php
class ArticlePresenter extends Nette\Application\UI\Presenter
{
	public function __construct()
	{
		$this->onStartup[] = function () {
			// ...
		};
	}
}
```

Обробники в масиві `$onStartup` викликаються безпосередньо перед методом `startup()`, потім `$onRender` між `beforeRender()` і `render<View>()` і, нарешті, `$onShutdown` безпосередньо перед `shutdown()`.


Відповіді .[#toc-responses]
---------------------------

Відповідь, яку повертає презентер, являє собою об'єкт, що реалізує інтерфейс [api:Nette\Application\Response]. Є кілька готових відповідей:

- [api:Nette\Application\Responses\CallbackResponse] - надсилає зворотний виклик
- [api:Nette\Application\Responses\FileResponse] - надсилає файл
- [api:Nette\Application\Responses\ForwardResponse] - forward ()
- [api:Nette\Application\Responses\JsonResponse] - надсилає JSON
- [api:Nette\Application\Responses\RedirectResponse] - перенаправляє
- [api:Nette\Application\Responses\TextResponse] - надсилає текст
- [api:Nette\Application\Responses\VoidResponse] - порожня відповідь

Відповіді надсилаються методом `sendResponse()`:

```php
use Nette\Application\Responses;

// Простий текст
$this->sendResponse(new Responses\TextResponse('Hello Nette!'));

// Відправляє файл
$this->sendResponse(new Responses\FileResponse(__DIR__ . '/invoice.pdf', 'Invoice13.pdf'));

// Відправляє зворотній виклик
$callback = function (Nette\Http\IRequest $httpRequest, Nette\Http\IResponse $httpResponse) {
	if ($httpResponse->getHeader('Content-Type') === 'text/html') {
		echo '<h1>Привіт</h1>';
	}
};
$this->sendResponse(new Responses\CallbackResponse($callback));
```


Читати далі .[#toc-further-reading]
===================================

- Введення [методів та атрибутів |best-practices:inject-method-attribute]
- Складання презентерів [з |best-practices:presenter-traits]атрибутів
- Передача [налаштувань |best-practices:passing-settings-to-presenters]презентерам
- [Як повернутися на попередню сторінку |best-practices:restore-request]
