Aserce
******

Na "stránce s průvodcem":[guide#Píšeme testy] jsme v ukázkovém testu použili dvě aserce: `Assert::same()` a `Assert::exception()`. Nyní si ukážeme i všechny ostatní a vysvětlíme, jak se používají. Jsou to metody třídy `Tester\Assert`, ale pro zjednodušení je dále uvádíme bez jmenného prostoru.


Assert::same($expected, $actual) .[method]
------------------------------------------
`$expected` musí být totožný s `$actual`. To samé jako PHP operátor `===`.


Assert::notSame($expected, $actual) .[method]
---------------------------------------------
Opak `Assert::same()`.


Assert::equal($expected, $actual) .[method]
-------------------------------------------
`$expected` musí být stejný s `$actual`, nebo musí "splňovat očekávání":[#očekávání]. Ignoruje se identita objektů a pořadí klíčů v polích.


Assert::notEqual($expected, $actual) .[method]
----------------------------------------------
Opak `Assert::equal()`.


Assert::contains($needle, $actual) .[method]
--------------------------------------------
`$actual` musí obsahovat `$needle`. Pokud je `$actual` řetězec, musí obsahovat podřetězec `$needle`. Pokud je pole, musí obsahovat prvek `$needle`.


Assert::notContains($needle, $actual) .[method]
-----------------------------------------------
Opak `Assert::contains()`.


Assert::true($value) .[method]
------------------------------
`$value` musí být `true`, tedy `$value === true`.


Assert::truthy($value) .[method]
--------------------------------
`$value` musí být pravdivý, tedy `$value == true`.


Assert::false($value) .[method]
-------------------------------
`$value` musí být `false`, tedy `$value === false`.


Assert::falsey($value) .[method]
--------------------------------
`$value` musí být nepravdivý, tedy `$value == false`.


Assert::count($count, $value) .[method]
---------------------------------------
`$count` musí být počet prvků ve `$value`. Počitatelné je pole nebo objekt implementující `Countable`.


Assert::null($value) .[method]
------------------------------
`$value` musí být `null`, tedy `$value === null`.


Assert::nan($value) .[method]
-----------------------------
`$value` musí být Not a Number.


Assert::type($type, $value) .[method]
-------------------------------------
`$value` musí být daného typu. Jako `$type` můžeme použít řetězec:
- `array`
- `list` - je jako array, ale indexy musí být od nuly a číslované po jedné
- `bool`
- `callable`
- `float`
- `int` nebo `integer`
- `null`
- `object`
- `resource`
- `scalar`
- `string`
- název třídy nebo přímo objekt, potom musí být `$value instanceof $type`


Assert::exception($callable, $class, $message = null, $code = null) .[method]
-----------------------------------------------------------------------------
Při zavolání `$callable` musí být vyhozena výjimka instance `$class`. Pokud uvedeme `$message`, musí pasovat (viz. [Assert::match() |#assert-match]) i zpráva výjimky a pokud uvedeme `$code`, musí se shodovat i kódy. Následující test selže, protože neodpovídá zpráva výjimky:

```php
Assert::exception(function () {
	throw new App\InvalidValueException('Zero value');
}, App\InvalidValueException::class, 'Value is to low');
```

`Assert::exception()` je zvláštní tím, že vrací vyhozenou výjimku. Lze tak otestovat i výjimku předchozí.

```php
$e = Assert::exception(function () {
	throw new MyException('Something is wrong', 0, new RuntimeException);
}, MyException::class, 'Something is wrong');

Assert::type(RuntimeException::class, $e->getPrevious());
```


Assert::error($callable, $type, $message = null) .[method]
----------------------------------------------------------
Pokud jako `$type` uvedete název třídy, chová se aserce naprosto stejně jako `Assert::exception()`.

Pokud je `$type` jedna z konstant `E_...`, tedy například `E_WARNING`, musí `$callable` při zavolání tuto chybu vygenerovat. A pokud uvedeme `$message`, musí pasovat (viz. [Assert::match() |#assert-match]) i chybová zpráva. Například:

```php
Assert::error(function () {
	$i++;
}, E_NOTICE, 'Undefined variable: i');
```

A poslední varianta, pokud je `$type` pole, musí `$callable` vygenerovat všechny takto očekávané chyby. Nejlépe asi vysvětlí příklad:

```php
Assert::error(function () {
	$a++;
	$b++;
}, [
	[E_NOTICE, 'Undefined variable: a'],
	[E_NOTICE, 'Undefined variable: b'],
]);
```


Assert::noError($callable) .[method]
------------------------------------
Kontroluje, že funkce `$callable` nevygenerovala žádné varování, chybu nebo výjimku. Hodí se pro testování kousků kódu, kde není žádná další aserce.


Assert::match($pattern, $actual) .[method]
------------------------------------------
`$actual` musí vyhovět vzoru `$pattern`. Můžeme použít dvě varianty vzorů.

Jako `$pattern` předáme regulární výraz. K jeho ohraničení musíme použít `~` nebo `#`, jiné oddělovače nejsou podporovány. Například test, kdy `$var` musí obsahovat pouze hexadecimální číslice:

```php
Assert::match('#^[0-9a-f]$#i', $var);
```

Druhá varianta je podobná běžnému porovnání řetězců, ale v `$pattern` můžeme použít různé modifikátory:
- `%a%` jeden nebo více znaků, kromě znaků konce řádku
- `%a?%` žádný nebo více znaků, kromě znaků konce řádku
- `%A%` jeden nebo více znaků, včetně znaků konce řádku
- `%A?%` žádný nebo více znaků, včetně znaků konce řádku
- `%s%` jeden nebo více bílých znaků, kromě znaků konce řádku
- `%s?%` žádný nebo více bílých znaků, kromě znaků konce řádku
- `%S%` jeden nebo více znaků, kromě bílých znaků
- `%S?%` žádný nebo více znaků, kromě bílých znaků
- `%c%` jakýkoli jeden znak, kromě znaku konce řádku
- `%d%` jedna nebo více číslic
- `%d?%` žádná nebo více číslic
- `%i%` znaménková celočíselná hodnota
- `%f%` číslo s desetinnou čárkou
- `%h%` jedna nebo více hexadecimálních číslic
- `%w%` jeden nebo více alfanumerických znaků
- `%%` znak %

Příklady:

```php
# Opět test na hexadecimální číslo
Assert::match('%h%', $var);

# Zobecnění cesty k souboru a čísla řádky
Assert::match('Error in file %a% on line %i%', $errorMessage);
```


Assert::matchFile($file, $actual) .[method]
-------------------------------------------
Aserce je totožná s [Assert::match() |#assert-match], ale vzor se načítá ze souboru `$file`. To je užitečné pro testování velmi dlouhých řetězců. Soubor s testem zůstane přehledný.


Assert::fail($message, $actual = null, $expected = null) .[method]
------------------------------------------------------------------
Tato aserce vždy selže. Někdy se to prostě hodí. Volitelně můžeme uvést i očekávanou a aktuální hodnotu.


Očekávání
---------
Když porovnáváme složitější struktury, nemusí být výše uvedené aserce dostatečné, pokud jsou položky náhodné povahy. Například některé hashe nebo časové údaje. V těchto situacích můžeme použít `Tester\Expect` objekty uvnitř `$expected` parametru metod `Assert::equal()` a `Assert::notEqual()`.

Předpokládejme, že testujeme metodu, která vytváří nového uživatele a vrací jeho atributy jako pole.

```php
use Tester\Expect;

Assert::equal([
	'id' => 123,
	'username' => 'milo',
	'password' => Expect::match('%h%'),  # náhodný řetězec, hash, ale musí vyhovit nějakému vzoru
	'created_at' => Expect::type(DateTimeImmutable::class),  # ověření pouze typu, ne přesné hodnoty
], User::create(123, 'milo', 'RandomPaSsWoRd'));
```

S `Expect` můžeme provádět téměř stejné aserce jako s `Assert`. Tedy `Expect::same()`, `Expect::match()`, `Expect::count()` a další jsou k dispozici. Navíc je můžeme zřetězit:

```php
Expect::type(MyIterator::class)->andCount(5);  # položka je MyIterator object a její počet je 5
```

Anebo můžeme psát vlastní callbacky asercí.

```php
Expect::that(function ($value) {
	# vrátíme false, pokud očekávání selže
});
```


Zkoumání chybných asercí
------------------------
Když aserce selže, Tester vypíše, v čem je chyba. Pokud porovnáváme složitější struktury, Tester vytvoří dumpy porovnávaných hodnot a uloží je do adresáře **output**. Například při selhání smyšleného testu `Arrays.recursive.phpt` budou dumpy uloženy následovně:

```
app/
└── tests/
    ├── output/
    │   ├── Arrays.recursive.actual    # aktuální hodnota
    │   └── Arrays.recursive.expected  # očekávaná hodnota
    │
    └── Arrays.recursive.phpt          # selhávající test
```

Název adresáře můžeme změnit přes `Tester\Dumper::$dumpDir`.



Tipy
----
- Vybírejte co nejvhodnější aserce. Například `Assert::same($a, $b)`, nikoliv `Assert::true($a === $b)`. Pouze v prvním případě dostaneme smysluplnou chybovou zprávu. V druhém případě pouze `false should be true` což nám o obsahu proměnných `$a` a `$b` nic neříká.
- Pro testování NAN hodnoty (Not a Number) použijte `Assert::nan()`. Hodnota NAN je velmi specifická a aserce `Assert::same()` nebo `Assert::equal()` mohou fungovat neočekávaně.
