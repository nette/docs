KÃ¼resel Durum ve Singletonlar
*****************************

.[perex]
UyarÄ±: AÅŸaÄŸÄ±daki yapÄ±lar kÃ¶tÃ¼ tasarlanmÄ±ÅŸ kodun belirtileridir:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` veya `static::$var`

Kodunuzda bu yapÄ±lardan herhangi biriyle karÅŸÄ±laÅŸÄ±yor musunuz? EÄŸer Ã¶yleyse, onu geliÅŸtirmek iÃ§in bir fÄ±rsatÄ±nÄ±z var demektir. BunlarÄ±n yaygÄ±n yapÄ±lar olduÄŸunu, genellikle Ã§eÅŸitli kÃ¼tÃ¼phanelerin ve Ã§erÃ§evelerin Ã¶rnek Ã§Ã¶zÃ¼mlerinde gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nÃ¼ dÃ¼ÅŸÃ¼nebilirsiniz. EÄŸer durum buysa, kod tasarÄ±mlarÄ± kusurludur.

Burada akademik bir saflÄ±ktan bahsetmiyoruz. TÃ¼m bu yapÄ±larÄ±n ortak bir noktasÄ± var: kÃ¼resel durum kullanÄ±yorlar. Ve bunun kod kalitesi Ã¼zerinde yÄ±kÄ±cÄ± bir etkisi vardÄ±r. SÄ±nÄ±flar baÄŸÄ±mlÄ±lÄ±klarÄ± konusunda aldatÄ±cÄ±dÄ±r. Kod Ã¶ngÃ¶rÃ¼lemez hale gelir. GeliÅŸtiricilerin kafasÄ±nÄ± karÄ±ÅŸtÄ±rÄ±r ve verimliliklerini azaltÄ±r.

Bu bÃ¶lÃ¼mde, bunun neden bÃ¶yle olduÄŸunu ve kÃ¼resel durumdan nasÄ±l kaÃ§Ä±nÄ±lacaÄŸÄ±nÄ± aÃ§Ä±klayacaÄŸÄ±z.


KÃ¼resel BaÄŸlantÄ± .[#toc-global-interlinking]
--------------------------------------------

Ä°deal bir dÃ¼nyada, bir nesne yalnÄ±zca [kendisine doÄŸrudan aktarÄ±lan |passing-dependencies] nesnelerle iletiÅŸim kurmalÄ±dÄ±r. Ä°ki nesne yaratÄ±rsam `A` ve `B` ve aralarÄ±nda hiÃ§bir zaman bir referans geÃ§mezsem, o zaman ne `A` ne de `B` diÄŸerinin durumuna eriÅŸemez veya deÄŸiÅŸtiremez. Bu, kodun oldukÃ§a arzu edilen bir Ã¶zelliÄŸidir. Bu, bir pil ve bir ampule sahip olmaya benzer; ampul, siz onu bir kabloyla pile baÄŸlamadan yanmaz.

Ancak bu durum global (statik) deÄŸiÅŸkenler veya tekil deÄŸiÅŸkenler iÃ§in geÃ§erli deÄŸildir. `A` nesnesi `C` nesnesine *kablosuz* olarak eriÅŸebilir ve `C::changeSomething()` adresini Ã§aÄŸÄ±rarak herhangi bir referans geÃ§iÅŸi olmadan onu deÄŸiÅŸtirebilir. EÄŸer `B` nesnesi global `C` nesnesine de eriÅŸirse, `A` ve `B` birbirlerini `C` Ã¼zerinden etkileyebilir.

Global deÄŸiÅŸkenlerin kullanÄ±lmasÄ±, dÄ±ÅŸarÄ±dan gÃ¶rÃ¼nmeyen yeni bir *kablosuz* baÄŸlantÄ± biÃ§imi ortaya Ã§Ä±karÄ±r. Bu da kodun anlaÅŸÄ±lmasÄ±nÄ± ve kullanÄ±lmasÄ±nÄ± zorlaÅŸtÄ±ran bir sis perdesi yaratÄ±r. BaÄŸÄ±mlÄ±lÄ±klarÄ± gerÃ§ekten anlamak iÃ§in, geliÅŸtiricilerin sadece sÄ±nÄ±f arayÃ¼zlerine aÅŸina olmak yerine kaynak kodun her satÄ±rÄ±nÄ± okumalarÄ± gerekir. Ãœstelik bu karÄ±ÅŸÄ±klÄ±k tamamen gereksizdir. Global durum, her yerden kolayca eriÅŸilebildiÄŸi ve Ã¶rneÄŸin global (statik) bir yÃ¶ntem aracÄ±lÄ±ÄŸÄ±yla bir veritabanÄ±na yazmaya izin verdiÄŸi iÃ§in kullanÄ±lÄ±r `DB::insert()`. Ancak, gÃ¶receÄŸimiz gibi, sunduÄŸu fayda minimum dÃ¼zeydeyken, ortaya Ã§Ä±kardÄ±ÄŸÄ± komplikasyonlar ciddidir.

.[note]
DavranÄ±ÅŸ aÃ§Ä±sÄ±ndan, global ve statik deÄŸiÅŸken arasÄ±nda bir fark yoktur. Ä°kisi de eÅŸit derecede zararlÄ±dÄ±r.


Uzaktaki ÃœrkÃ¼tÃ¼cÃ¼ Eylem .[#toc-the-spooky-action-at-a-distance]
---------------------------------------------------------------

"Uzaktaki Ã¼rkÃ¼tÃ¼cÃ¼ eylem" - Albert Einstein 1935 yÄ±lÄ±nda kuantum fiziÄŸinde kendisini Ã¼rkÃ¼ten bir olguyu bÃ¶yle adlandÄ±rmÄ±ÅŸtÄ±.
Bu kuantum dolanÄ±klÄ±ÄŸÄ±dÄ±r ve Ã¶zelliÄŸi, bir parÃ§acÄ±k hakkÄ±ndaki bilgiyi Ã¶lÃ§tÃ¼ÄŸÃ¼nÃ¼zde, milyonlarca Ä±ÅŸÄ±k yÄ±lÄ± uzakta olsalar bile baÅŸka bir parÃ§acÄ±ÄŸÄ± hemen etkilemenizdir.
Bu da evrenin temel yasasÄ± olan hiÃ§bir ÅŸeyin Ä±ÅŸÄ±ktan hÄ±zlÄ± gidemeyeceÄŸi ilkesini ihlal eder.

YazÄ±lÄ±m dÃ¼nyasÄ±nda, izole olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼z bir sÃ¼reci Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z (Ã§Ã¼nkÃ¼ ona herhangi bir referans iletmedik), ancak sistemin nesneye sÃ¶ylemediÄŸimiz uzak konumlarÄ±nda beklenmedik etkileÅŸimlerin ve durum deÄŸiÅŸikliklerinin meydana geldiÄŸi bir durumu "uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ eylem" olarak adlandÄ±rabiliriz. Bu yalnÄ±zca global durum aracÄ±lÄ±ÄŸÄ±yla gerÃ§ekleÅŸebilir.

BÃ¼yÃ¼k ve olgun bir kod tabanÄ±na sahip bir proje geliÅŸtirme ekibine katÄ±ldÄ±ÄŸÄ±nÄ±zÄ± dÃ¼ÅŸÃ¼nÃ¼n. Yeni lideriniz sizden yeni bir Ã¶zelliÄŸi hayata geÃ§irmenizi istiyor ve siz de iyi bir geliÅŸtirici gibi iÅŸe bir test yazarak baÅŸlÄ±yorsunuz. Ancak projede yeni olduÄŸunuz iÃ§in, "bu yÃ¶ntemi Ã§aÄŸÄ±rÄ±rsam ne olur" tÃ¼rÃ¼nde Ã§ok sayÄ±da keÅŸif testi yaparsÄ±nÄ±z. Ve aÅŸaÄŸÄ±daki testi yazmaya Ã§alÄ±ÅŸÄ±yorsunuz:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // kart numaranÄ±z
	$cc->charge(100);
}
```

Kodu belki birkaÃ§ kez Ã§alÄ±ÅŸtÄ±rÄ±yorsunuz ve bir sÃ¼re sonra telefonunuza bankadan gelen bildirimlerde kodu her Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±zda kredi kartÄ±nÄ±zdan 100 $ Ã§ekildiÄŸini fark ediyorsunuz ğŸ¤¦â€â™‚ï¸

Test nasÄ±l olur da gerÃ§ek bir Ã¼cretlendirmeye neden olabilir? Kredi kartÄ± ile iÅŸlem yapmak kolay deÄŸildir. ÃœÃ§Ã¼ncÃ¼ taraf bir web hizmetiyle etkileÅŸime girmeniz, bu web hizmetinin URL'sini bilmeniz, oturum aÃ§manÄ±z vb. gerekir.
Bu bilgilerin hiÃ§biri testte yer almÄ±yor. Daha da kÃ¶tÃ¼sÃ¼, bu bilgilerin nerede bulunduÄŸunu ve bu nedenle her Ã§alÄ±ÅŸtÄ±rmanÄ±n tekrar 100 $ Ã¼cretlendirilmesiyle sonuÃ§lanmamasÄ± iÃ§in harici baÄŸÄ±mlÄ±lÄ±klarÄ± nasÄ±l taklit edeceÄŸinizi bile bilmiyorsunuz. Ve yeni bir geliÅŸtirici olarak, yapmak Ã¼zere olduÄŸunuz ÅŸeyin 100 dolar daha fakir olmanÄ±za yol aÃ§acaÄŸÄ±nÄ± nereden bilebilirdiniz?

Bu uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ bir hareket!

Projedeki baÄŸlantÄ±larÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlayana kadar, daha yaÅŸlÄ± ve daha deneyimli meslektaÅŸlarÄ±nÄ±za sorarak Ã§ok sayÄ±da kaynak kodu incelemekten baÅŸka seÃ§eneÄŸiniz yoktur.
Bunun nedeni, `CreditCard` sÄ±nÄ±fÄ±nÄ±n arayÃ¼zÃ¼ne baktÄ±ÄŸÄ±nÄ±zda, baÅŸlatÄ±lmasÄ± gereken global durumu belirleyememenizdir. SÄ±nÄ±fÄ±n kaynak koduna bakmak bile size hangi ilklendirme yÃ¶ntemini Ã§aÄŸÄ±rmanÄ±z gerektiÄŸini sÃ¶ylemeyecektir. En iyi ihtimalle, eriÅŸilen global deÄŸiÅŸkeni bulabilir ve buradan nasÄ±l baÅŸlatÄ±lacaÄŸÄ±nÄ± tahmin etmeye Ã§alÄ±ÅŸabilirsiniz.

BÃ¶yle bir projedeki sÄ±nÄ±flar patolojik yalancÄ±lardÄ±r. Ã–deme kartÄ±, sadece onu Ã¶rnekleyebileceÄŸinizi ve `charge()` yÃ¶ntemini Ã§aÄŸÄ±rabileceÄŸinizi iddia eder. Ancak, gizlice baÅŸka bir sÄ±nÄ±f olan `PaymentGateway` ile etkileÅŸim halindedir. ArayÃ¼zÃ¼ bile baÄŸÄ±msÄ±z olarak baÅŸlatÄ±labileceÄŸini sÃ¶ylÃ¼yor, ancak gerÃ§ekte bazÄ± yapÄ±landÄ±rma dosyalarÄ±ndan kimlik bilgilerini Ã§ekiyor vb.
Bu kodu yazan geliÅŸtiriciler iÃ§in `CreditCard` 'un `PaymentGateway`'a ihtiyacÄ± olduÄŸu aÃ§Ä±ktÄ±r. Kodu bu ÅŸekilde yazmÄ±ÅŸlardÄ±r. Ancak projede yeni olan herkes iÃ§in bu tam bir gizemdir ve Ã¶ÄŸrenmeyi engeller.

Bu durum nasÄ±l dÃ¼zeltilir? Ã‡ok kolay. **API'nin baÄŸÄ±mlÄ±lÄ±klarÄ± bildirmesine izin verin.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Kod iÃ§indeki iliÅŸkilerin birdenbire nasÄ±l belirgin hale geldiÄŸine dikkat edin. `charge()` yÃ¶nteminin `PaymentGateway` adresine ihtiyaÃ§ duyduÄŸunu beyan ederek, kodun nasÄ±l birbirine baÄŸlÄ± olduÄŸunu kimseye sormak zorunda kalmazsÄ±nÄ±z. Bunun bir Ã¶rneÄŸini oluÅŸturmanÄ±z gerektiÄŸini biliyorsunuz ve bunu yapmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±zda eriÅŸim parametreleri saÄŸlamanÄ±z gerektiÄŸi gerÃ§eÄŸiyle karÅŸÄ±laÅŸÄ±yorsunuz. Onlar olmadan kod Ã§alÄ±ÅŸmaz bile.

Ve en Ã¶nemlisi, artÄ±k Ã¶deme aÄŸ geÃ§idini taklit edebilirsiniz, bÃ¶ylece her test Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±zda 100 $ Ã¼cretlendirilmezsiniz.

KÃ¼resel durum, nesnelerinizin API'lerinde bildirilmeyen ÅŸeylere gizlice eriÅŸebilmesine neden olur ve sonuÃ§ olarak API'lerinizi patolojik yalancÄ±lar haline getirir.

Daha Ã¶nce bu ÅŸekilde dÃ¼ÅŸÃ¼nmemiÅŸ olabilirsiniz, ancak global state kullandÄ±ÄŸÄ±nÄ±zda gizli kablosuz iletiÅŸim kanallarÄ± oluÅŸturmuÅŸ olursunuz. ÃœrkÃ¼tÃ¼cÃ¼ uzaktan eylem, geliÅŸtiricileri potansiyel etkileÅŸimleri anlamak iÃ§in her kod satÄ±rÄ±nÄ± okumaya zorlar, geliÅŸtirici verimliliÄŸini azaltÄ±r ve yeni ekip Ã¼yelerinin kafasÄ±nÄ± karÄ±ÅŸtÄ±rÄ±r.
Kodu oluÅŸturan kiÅŸi sizseniz, gerÃ§ek baÄŸÄ±mlÄ±lÄ±klarÄ± bilirsiniz, ancak sizden sonra gelenlerin hiÃ§bir ÅŸeyden haberi olmaz.

Global durum kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ± aktarmayÄ± tercih edin. Yani, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


KÃ¼resel Devletin KÄ±rÄ±lganlÄ±ÄŸÄ± .[#toc-brittleness-of-the-global-state]
---------------------------------------------------------------------

Global state ve singleton kullanan kodlarda, bu state'in ne zaman ve kim tarafÄ±ndan deÄŸiÅŸtirildiÄŸi asla kesin deÄŸildir. Bu risk baÅŸlatma sÄ±rasÄ±nda zaten mevcuttur. AÅŸaÄŸÄ±daki kodun bir veritabanÄ± baÄŸlantÄ±sÄ± oluÅŸturmasÄ± ve Ã¶deme aÄŸ geÃ§idini baÅŸlatmasÄ± gerekiyor, ancak sÃ¼rekli bir istisna atÄ±yor ve nedenini bulmak son derece sÄ±kÄ±cÄ±:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

 `PaymentGateway` nesnesinin diÄŸer nesnelere kablosuz olarak eriÅŸtiÄŸini ve bunlardan bazÄ±larÄ±nÄ±n veritabanÄ± baÄŸlantÄ±sÄ± gerektirdiÄŸini bulmak iÃ§in kodu ayrÄ±ntÄ±lÄ± olarak incelemeniz gerekir. Bu nedenle, `PaymentGateway` adresinden Ã¶nce veritabanÄ±nÄ± baÅŸlatmanÄ±z gerekir. Ancak, global durum sis perdesi bunu sizden gizler. Her sÄ±nÄ±fÄ±n API'si yalan sÃ¶ylemeseydi ve baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± beyan etseydi ne kadar zaman kazanÄ±rdÄ±nÄ±z?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Bir veritabanÄ± baÄŸlantÄ±sÄ±na genel eriÅŸim kullanÄ±ldÄ±ÄŸÄ±nda da benzer bir sorun ortaya Ã§Ä±kar:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

 `save()` yÃ¶ntemi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, bir veritabanÄ± baÄŸlantÄ±sÄ±nÄ±n zaten oluÅŸturulup oluÅŸturulmadÄ±ÄŸÄ± ve oluÅŸturulmasÄ±ndan kimin sorumlu olduÄŸu kesin deÄŸildir. Ã–rneÄŸin, veritabanÄ± baÄŸlantÄ±sÄ±nÄ± anÄ±nda deÄŸiÅŸtirmek istersek, belki de test amacÄ±yla, muhtemelen `DB::reconnect(...)` veya `DB::reconnectForTest()` gibi ek yÃ¶ntemler oluÅŸturmamÄ±z gerekecektir.

Bir Ã¶rnek dÃ¼ÅŸÃ¼nÃ¼n:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

 `$article->save()` adresini Ã§aÄŸÄ±rÄ±rken test veritabanÄ±nÄ±n gerÃ§ekten kullanÄ±ldÄ±ÄŸÄ±ndan nasÄ±l emin olabiliriz? Ya `Foo::doSomething()` yÃ¶ntemi global veritabanÄ± baÄŸlantÄ±sÄ±nÄ± deÄŸiÅŸtirdiyse? Bunu Ã¶ÄŸrenmek iÃ§in `Foo` sÄ±nÄ±fÄ±nÄ±n ve muhtemelen diÄŸer birÃ§ok sÄ±nÄ±fÄ±n kaynak kodunu incelememiz gerekir. Ancak, durum gelecekte deÄŸiÅŸebileceÄŸinden, bu yaklaÅŸÄ±m yalnÄ±zca kÄ±sa vadeli bir yanÄ±t saÄŸlayacaktÄ±r.

VeritabanÄ± baÄŸlantÄ±sÄ±nÄ± `Article` sÄ±nÄ±fÄ±nÄ±n iÃ§indeki statik bir deÄŸiÅŸkene taÅŸÄ±rsak ne olur?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Bu hiÃ§bir ÅŸeyi deÄŸiÅŸtirmez. Sorun global bir durumdur ve hangi sÄ±nÄ±fta saklandÄ±ÄŸÄ± Ã¶nemli deÄŸildir. Bu durumda, bir Ã¶ncekinde olduÄŸu gibi, `$article->save()` yÃ¶ntemi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda hangi veritabanÄ±na yazÄ±ldÄ±ÄŸÄ±na dair hiÃ§bir ipucumuz yoktur. UygulamanÄ±n uzak ucundaki herhangi biri `Article::setDb()` adresini kullanarak istediÄŸi zaman veritabanÄ±nÄ± deÄŸiÅŸtirebilir. Elimizin altÄ±nda.

KÃ¼resel durum uygulamamÄ±zÄ± **son derece kÄ±rÄ±lgan** hale getirir.

Ancak bu sorunun Ã¼stesinden gelmenin basit bir yolu vardÄ±r. Uygun iÅŸlevselliÄŸi saÄŸlamak iÃ§in API'nin baÄŸÄ±mlÄ±lÄ±klarÄ± bildirmesi yeterlidir.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Bu yaklaÅŸÄ±m, veritabanÄ± baÄŸlantÄ±larÄ±nda gizli ve beklenmedik deÄŸiÅŸiklikler yapÄ±lmasÄ± endiÅŸesini ortadan kaldÄ±rÄ±r. ArtÄ±k makalenin nerede saklandÄ±ÄŸÄ±ndan eminiz ve baÅŸka bir ilgisiz sÄ±nÄ±fÄ±n iÃ§indeki hiÃ§bir kod deÄŸiÅŸikliÄŸi artÄ±k durumu deÄŸiÅŸtiremez. Kod artÄ±k kÄ±rÄ±lgan deÄŸil, kararlÄ±.

Global durum kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ± aktarmayÄ± tercih edin. BÃ¶ylece, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


Singleton .[#toc-singleton]
---------------------------

Singleton, Ã¼nlÃ¼ Gang of Four yayÄ±nÄ±ndaki [tanÄ±mÄ±yla |https://en.wikipedia.org/wiki/Singleton_pattern], bir sÄ±nÄ±fÄ± tek bir Ã¶rnekle sÄ±nÄ±rlayan ve ona global eriÅŸim sunan bir tasarÄ±m modelidir. Bu kalÄ±bÄ±n uygulamasÄ± genellikle aÅŸaÄŸÄ±daki koda benzer:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// ve sÄ±nÄ±fÄ±n iÅŸlevlerini yerine getiren diÄŸer yÃ¶ntemler
}
```

Ne yazÄ±k ki, singleton uygulamaya global durum ekler. Ve yukarÄ±da gÃ¶sterdiÄŸimiz gibi, global durum istenmeyen bir durumdur. Bu yÃ¼zden singleton bir antipattern olarak kabul edilir.

Kodunuzda singleton kullanmayÄ±n ve bunlarÄ± baÅŸka mekanizmalarla deÄŸiÅŸtirin. Tekillere gerÃ§ekten ihtiyacÄ±nÄ±z yok. Ancak, tÃ¼m uygulama iÃ§in bir sÄ±nÄ±fÄ±n tek bir Ã¶rneÄŸinin varlÄ±ÄŸÄ±nÄ± garanti etmeniz gerekiyorsa, bunu [DI konteynerine |container] bÄ±rakÄ±n.
BÃ¶ylece, bir uygulama singletonu veya hizmeti oluÅŸturun. Bu, sÄ±nÄ±fÄ±n kendi benzersizliÄŸini saÄŸlamasÄ±nÄ± durduracak (yani, bir `getInstance()` yÃ¶ntemine ve statik bir deÄŸiÅŸkene sahip olmayacaktÄ±r) ve yalnÄ±zca iÅŸlevlerini yerine getirecektir. BÃ¶ylece, tek sorumluluk ilkesini ihlal etmeyi durduracaktÄ±r.


Testlere KarÅŸÄ± KÃ¼resel Durum .[#toc-global-state-versus-tests]
--------------------------------------------------------------

Testleri yazarken, her testin izole bir birim olduÄŸunu ve hiÃ§bir dÄ±ÅŸ durumun teste girmediÄŸini varsayarÄ±z. Ve hiÃ§bir durum testleri terk etmez. Bir test tamamlandÄ±ÄŸÄ±nda, testle iliÅŸkili tÃ¼m durumlar Ã§Ã¶p toplayÄ±cÄ± tarafÄ±ndan otomatik olarak kaldÄ±rÄ±lmalÄ±dÄ±r. Bu, testleri yalÄ±tÄ±lmÄ±ÅŸ hale getirir. Bu nedenle testleri istediÄŸimiz sÄ±rada Ã§alÄ±ÅŸtÄ±rabiliriz.

Ancak, kÃ¼resel durumlar/singletonlar mevcutsa, tÃ¼m bu gÃ¼zel varsayÄ±mlar bozulur. Bir durum bir teste girebilir ve Ã§Ä±kabilir. Birdenbire, testlerin sÄ±rasÄ± Ã¶nemli olabilir.

Tekil Ã¶ÄŸeleri test etmek iÃ§in, geliÅŸtiricilerin genellikle bir Ã¶rneÄŸin baÅŸka bir Ã¶rnekle deÄŸiÅŸtirilmesine izin vererek Ã¶zelliklerini gevÅŸetmeleri gerekir. Bu tÃ¼r Ã§Ã¶zÃ¼mler, en iyi ihtimalle, bakÄ±mÄ± ve anlaÅŸÄ±lmasÄ± zor kodlar Ã¼reten hilelerdir. Herhangi bir global durumu etkileyen herhangi bir test veya yÃ¶ntem `tearDown()` bu deÄŸiÅŸiklikleri geri almalÄ±dÄ±r.

Global durum, birim testindeki en bÃ¼yÃ¼k baÅŸ aÄŸrÄ±sÄ±dÄ±r!

Bu durum nasÄ±l dÃ¼zeltilir? Ã‡ok kolay. Singleton kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ± aktarmayÄ± tercih edin. Yani baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


KÃ¼resel Sabitler .[#toc-global-constants]
-----------------------------------------

KÃ¼resel durum tekil ve statik deÄŸiÅŸkenlerin kullanÄ±mÄ±yla sÄ±nÄ±rlÄ± deÄŸildir, aynÄ± zamanda kÃ¼resel sabitler iÃ§in de geÃ§erli olabilir.

DeÄŸeri bize yeni (`M_PI`) veya faydalÄ± (`PREG_BACKTRACK_LIMIT_ERROR`) bilgi saÄŸlamayan sabitler aÃ§Ä±kÃ§a tamamdÄ±r.
Tersine, kod iÃ§inde *kablosuz* bilgi aktarmanÄ±n bir yolu olarak hizmet eden sabitler, gizli bir baÄŸÄ±mlÄ±lÄ±ktan baÅŸka bir ÅŸey deÄŸildir. AÅŸaÄŸÄ±daki Ã¶rnekte `LOG_FILE` gibi.
 `FILE_APPEND` sabitini kullanmak tamamen doÄŸrudur.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Bu durumda, API'nin bir parÃ§asÄ± haline getirmek iÃ§in parametreyi `Foo` sÄ±nÄ±fÄ±nÄ±n kurucusunda bildirmeliyiz:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

ArtÄ±k gÃ¼nlÃ¼k dosyasÄ±nÄ±n yolu hakkÄ±nda bilgi aktarabilir ve gerektiÄŸinde kolayca deÄŸiÅŸtirebiliriz, bu da kodu test etmeyi ve bakÄ±mÄ±nÄ± yapmayÄ± kolaylaÅŸtÄ±rÄ±r.


Global Ä°ÅŸlevler ve Statik YÃ¶ntemler .[#toc-global-functions-and-static-methods]
-------------------------------------------------------------------------------

Statik yÃ¶ntemlerin ve global fonksiyonlarÄ±n kullanÄ±mÄ±nÄ±n kendi iÃ§inde sorunlu olmadÄ±ÄŸÄ±nÄ± vurgulamak istiyoruz. `DB::insert()` ve benzeri yÃ¶ntemlerin kullanÄ±lmasÄ±nÄ±n uygunsuzluÄŸunu aÃ§Ä±kladÄ±k, ancak bu her zaman statik bir deÄŸiÅŸkende saklanan global durum meselesi olmuÅŸtur. `DB::insert()` yÃ¶ntemi, veritabanÄ± baÄŸlantÄ±sÄ±nÄ± sakladÄ±ÄŸÄ± iÃ§in statik bir deÄŸiÅŸkenin varlÄ±ÄŸÄ±nÄ± gerektirir. Bu deÄŸiÅŸken olmadan yÃ¶ntemi uygulamak imkansÄ±zdÄ±r.

 `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` ve diÄŸerleri gibi deterministik statik yÃ¶ntem ve fonksiyonlarÄ±n kullanÄ±mÄ± baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile tamamen tutarlÄ±dÄ±r. Bu fonksiyonlar her zaman aynÄ± girdi parametrelerinden aynÄ± sonuÃ§larÄ± dÃ¶ndÃ¼rÃ¼r ve bu nedenle Ã¶ngÃ¶rÃ¼lebilirdir. Herhangi bir global durum kullanmazlar.

Ancak, PHP'de deterministik olmayan iÅŸlevler de vardÄ±r. Bunlara Ã¶rnek olarak `htmlspecialchars()` fonksiyonu verilebilir. ÃœÃ§Ã¼ncÃ¼ parametresi olan `$encoding` belirtilmezse, varsayÄ±lan olarak `ini_get('default_charset')` yapÄ±landÄ±rma seÃ§eneÄŸinin deÄŸerini alÄ±r. Bu nedenle, fonksiyonun olasÄ± Ã¶ngÃ¶rÃ¼lemeyen davranÄ±ÅŸÄ±nÄ± Ã¶nlemek iÃ§in bu parametrenin her zaman belirtilmesi Ã¶nerilir. Nette bunu sÃ¼rekli olarak yapar.

 `strtolower()`, `strtoupper()` ve benzerleri gibi bazÄ± fonksiyonlar yakÄ±n geÃ§miÅŸte deterministik olmayan davranÄ±ÅŸlara sahipti ve `setlocale()` ayarÄ±na baÄŸlÄ±ydÄ±. Bu, Ã§oÄŸunlukla TÃ¼rkÃ§e diliyle Ã§alÄ±ÅŸÄ±rken birÃ§ok komplikasyona neden olmuÅŸtur.
Bunun nedeni, TÃ¼rkÃ§e dilinin noktalÄ± ve noktasÄ±z bÃ¼yÃ¼k ve kÃ¼Ã§Ã¼k harf `I` arasÄ±nda ayrÄ±m yapmasÄ±dÄ±r. Bu yÃ¼zden `strtolower('I')`, `Ä±` karakterini ve `strtoupper('i')`, `Ä°` karakterini dÃ¶ndÃ¼rÃ¼yordu, bu da uygulamalarÄ±n bir dizi gizemli hataya neden olmasÄ±na yol aÃ§Ä±yordu.
Ancak, bu sorun PHP 8.2 sÃ¼rÃ¼mÃ¼nde dÃ¼zeltilmiÅŸtir ve iÅŸlevler artÄ±k yerel ayara baÄŸlÄ± deÄŸildir.

Bu, kÃ¼resel durumun dÃ¼nyanÄ±n dÃ¶rt bir yanÄ±ndaki binlerce geliÅŸtiriciyi nasÄ±l rahatsÄ±z ettiÄŸinin gÃ¼zel bir Ã¶rneÄŸidir. Ã‡Ã¶zÃ¼m, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile deÄŸiÅŸtirmekti.


Global State Ne Zaman KullanÄ±labilir? .[#toc-when-is-it-possible-to-use-global-state]
-------------------------------------------------------------------------------------

Global durumu kullanmanÄ±n mÃ¼mkÃ¼n olduÄŸu bazÄ± Ã¶zel durumlar vardÄ±r. Ã–rneÄŸin, kodda hata ayÄ±klama yaparken bir deÄŸiÅŸkenin deÄŸerini dÃ¶kmeniz veya programÄ±n belirli bir bÃ¶lÃ¼mÃ¼nÃ¼n sÃ¼resini Ã¶lÃ§meniz gerekir. Daha sonra koddan kaldÄ±rÄ±lacak geÃ§ici eylemlerle ilgili olan bu gibi durumlarda, global olarak kullanÄ±labilen bir dumper veya kronometre kullanmak meÅŸrudur. Bu araÃ§lar kod tasarÄ±mÄ±nÄ±n bir parÃ§asÄ± deÄŸildir.

BaÅŸka bir Ã¶rnek, derlenmiÅŸ dÃ¼zenli ifadeleri dahili olarak bellekteki statik bir Ã¶nbellekte saklayan `preg_*` dÃ¼zenli ifadelerle Ã§alÄ±ÅŸma iÅŸlevleridir. AynÄ± dÃ¼zenli ifadeyi kodun farklÄ± bÃ¶lÃ¼mlerinde birden Ã§ok kez Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zda, bu ifade yalnÄ±zca bir kez derlenir. Ã–nbellek performans tasarrufu saÄŸlar ve ayrÄ±ca kullanÄ±cÄ± iÃ§in tamamen gÃ¶rÃ¼nmezdir, bu nedenle bu tÃ¼r kullanÄ±m meÅŸru kabul edilebilir.


Ã–zet .[#toc-summary]
--------------------

Bunun neden mantÄ±klÄ± olduÄŸunu gÃ¶sterdik

1) Koddan tÃ¼m statik deÄŸiÅŸkenleri kaldÄ±rÄ±n
2) BaÄŸÄ±mlÄ±lÄ±klarÄ± beyan edin
3) Ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonu kullanÄ±n

Kod tasarÄ±mÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼rken, her `static $foo` adresinin bir sorunu temsil ettiÄŸini unutmayÄ±n. Kodunuzun DI'ya saygÄ±lÄ± bir ortam olmasÄ± iÃ§in, global durumu tamamen ortadan kaldÄ±rmak ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile deÄŸiÅŸtirmek Ã§ok Ã¶nemlidir.

Bu sÃ¼reÃ§ sÄ±rasÄ±nda, birden fazla sorumluluÄŸu olduÄŸu iÃ§in bir sÄ±nÄ±fÄ± bÃ¶lmeniz gerektiÄŸini fark edebilirsiniz. Bu konuda endiÅŸelenmeyin; tek sorumluluk ilkesi iÃ§in Ã§aba gÃ¶sterin.

*[Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] gibi makaleleri bu bÃ¶lÃ¼mÃ¼n temelini oluÅŸturan MiÅ¡ko Hevery'ye teÅŸekkÃ¼r ederim.*
