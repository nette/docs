Globaler Zustand und Singletons
*******************************

.[perex]
Warnung: Die folgenden Konstrukte sind Anzeichen f√ºr schlecht entworfenen Code:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` oder `static::$var`

Treten einige dieser Konstrukte in Ihrem Code auf? Dann haben Sie die M√∂glichkeit, ihn zu verbessern. Vielleicht denken Sie, dass dies √ºbliche Konstrukte sind, die Sie vielleicht sogar in Beispiel-L√∂sungen verschiedener Bibliotheken und Frameworks sehen. Wenn dies der Fall ist, dann ist das Design ihres Codes nicht gut.

Wir sprechen hier definitiv nicht von irgendeiner akademischen Reinheit. Alle diese Konstrukte haben eines gemeinsam: Sie verwenden globalen Zustand. Und dieser hat einen zerst√∂rerischen Einfluss auf die Codequalit√§t. Klassen l√ºgen √ºber ihre Abh√§ngigkeiten. Code wird unvorhersehbar. Er verwirrt Programmierer und reduziert ihre Effizienz.

In diesem Kapitel erkl√§ren wir, warum das so ist und wie man globalen Zustand vermeidet.


Globale Kopplung
----------------

In einer idealen Welt sollte ein Objekt nur mit Objekten kommunizieren k√∂nnen, die ihm [direkt √ºbergeben |passing-dependencies] wurden. Wenn ich zwei Objekte `A` und `B` erstelle und niemals eine Referenz zwischen ihnen √ºbergebe, dann k√∂nnen weder `A` noch `B` auf das andere Objekt zugreifen oder seinen Zustand √§ndern. Das ist eine sehr w√ºnschenswerte Eigenschaft von Code. Es ist √§hnlich wie bei einer Batterie und einer Gl√ºhbirne; die Gl√ºhbirne leuchtet nicht, solange Sie sie nicht mit einem Draht mit der Batterie verbinden.

Das gilt jedoch nicht f√ºr globale (statische) Variablen oder Singletons. Objekt `A` k√∂nnte *drahtlos* auf Objekt `C` zugreifen und es modifizieren, ohne dass eine Referenz √ºbergeben wird, indem es `C::changeSomething()` aufruft. Wenn Objekt `B` ebenfalls auf das globale `C` zugreift, dann k√∂nnen sich `A` und `B` gegenseitig √ºber `C` beeinflussen.

Die Verwendung globaler Variablen f√ºhrt eine neue Form der *drahtlosen* Kopplung in das System ein, die von au√üen nicht sichtbar ist. Sie erzeugt eine Nebelwand, die das Verst√§ndnis und die Verwendung des Codes erschwert. Um die Abh√§ngigkeiten wirklich zu verstehen, m√ºssen Entwickler jede Zeile des Quellcodes lesen, anstatt sich nur mit der Schnittstelle der Klassen vertraut zu machen. Es handelt sich zudem um eine v√∂llig unn√∂tige Kopplung. Globaler Zustand wird verwendet, weil er von √ºberall leicht zug√§nglich ist und es beispielsweise erm√∂glicht, √ºber eine globale (statische) Methode `DB::insert()` in die Datenbank zu schreiben. Aber wie wir zeigen werden, ist der Vorteil, den dies bringt, gering, w√§hrend die dadurch verursachten Komplikationen fatal sind.

.[note]
Aus Verhaltenssicht gibt es keinen Unterschied zwischen einer globalen und einer statischen Variablen. Sie sind gleicherma√üen sch√§dlich.


Spukhafte Fernwirkung
---------------------

"Spukhafte Fernwirkung" ‚Äì so nannte Albert Einstein 1935 ber√ºhmt ein Ph√§nomen in der Quantenphysik, das ihm G√§nsehaut bereitete.
Es handelt sich um die Quantenverschr√§nkung, deren Besonderheit darin besteht, dass, wenn man Informationen √ºber ein Teilchen misst, man sofort das andere Teilchen beeinflusst, auch wenn sie Millionen von Lichtjahren voneinander entfernt sind. Dies scheint das Grundgesetz des Universums zu verletzen, dass sich nichts schneller als Licht ausbreiten kann.

In der Softwarewelt k√∂nnen wir "spukhafte Fernwirkung" eine Situation nennen, in der wir einen Prozess starten, von dem wir annehmen, dass er isoliert ist (weil wir ihm keine Referenzen √ºbergeben haben), aber an entfernten Stellen im System unerwartete Interaktionen und Zustands√§nderungen auftreten, von denen wir keine Ahnung hatten. Dies kann nur durch globalen Zustand geschehen.

Stellen Sie sich vor, Sie treten einem Entwicklerteam eines Projekts bei, das √ºber eine umfangreiche, ausgereifte Codebasis verf√ºgt. Ihr neuer Vorgesetzter bittet Sie, eine neue Funktion zu implementieren, und Sie beginnen als guter Entwickler mit dem Schreiben eines Tests. Da Sie jedoch neu im Projekt sind, f√ºhren Sie viele explorative Tests durch, wie z. B. "Was passiert, wenn ich diese Methode aufrufe?". Und Sie versuchen, den folgenden Test zu schreiben:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // Ihre Kartennummer
	$cc->charge(100);
}
```

Sie f√ºhren den Code aus, vielleicht mehrmals, und nach einer Weile bemerken Sie Benachrichtigungen von Ihrer Bank auf Ihrem Handy, dass bei jedem Ausf√ºhren 100 Dollar von Ihrer Kreditkarte abgebucht wurden ü§¶‚Äç‚ôÇÔ∏è

Wie um alles in der Welt konnte der Test dazu f√ºhren, dass tats√§chlich Geld abgebucht wird? Die Handhabung einer Kreditkarte ist nicht einfach. Sie m√ºssen mit einem Webdienst eines Drittanbieters kommunizieren, Sie m√ºssen die URL dieses Webdienstes kennen, Sie m√ºssen sich anmelden und so weiter. Keine dieser Informationen ist im Test enthalten. Schlimmer noch, Sie wissen nicht einmal, wo diese Informationen vorhanden sind, und daher auch nicht, wie Sie externe Abh√§ngigkeiten mocken k√∂nnen, damit nicht bei jeder Ausf√ºhrung erneut 100 Dollar abgebucht werden. Und wie h√§tten Sie als neuer Entwickler wissen sollen, dass das, was Sie tun wollten, dazu f√ºhren w√ºrde, dass Sie um 100 Dollar √§rmer sind?

Das ist spukhafte Fernwirkung!

Es bleibt Ihnen nichts anderes √ºbrig, als sich lange durch eine Menge Quellcode zu w√ºhlen und √§ltere und erfahrenere Kollegen zu fragen, bis Sie verstehen, wie die Abh√§ngigkeiten im Projekt funktionieren. Dies liegt daran, dass beim Betrachten der Schnittstelle der Klasse `CreditCard` der globale Zustand, der initialisiert werden muss, nicht erkannt werden kann. Selbst ein Blick in den Quellcode der Klasse verr√§t Ihnen nicht, welche Initialisierungsmethode Sie aufrufen m√ºssen. Im besten Fall finden Sie eine globale Variable, auf die zugegriffen wird, und k√∂nnen daraus versuchen abzuleiten, wie sie initialisiert wird.

Klassen in einem solchen Projekt sind pathologische L√ºgner. Die Kreditkarte tut so, als ob es ausreicht, sie zu instanziieren und die Methode `charge()` aufzurufen. Im Verborgenen arbeitet sie jedoch mit einer anderen Klasse `PaymentGateway` zusammen, die das Zahlungsgateway darstellt. Auch deren Schnittstelle besagt, dass sie separat initialisiert werden kann, aber tats√§chlich holt sie sich Anmeldeinformationen aus einer Konfigurationsdatei und so weiter. Den Entwicklern, die diesen Code geschrieben haben, ist klar, dass `CreditCard` `PaymentGateway` ben√∂tigt. Sie haben den Code auf diese Weise geschrieben. Aber f√ºr jeden, der neu im Projekt ist, ist es ein absolutes R√§tsel und behindert das Lernen.

Wie kann man die Situation beheben? Einfach. **Lassen Sie die API Abh√§ngigkeiten deklarieren.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Beachten Sie, wie die Abh√§ngigkeiten innerhalb des Codes pl√∂tzlich offensichtlich sind. Dadurch, dass die Methode `charge()` deklariert, dass sie `PaymentGateway` ben√∂tigt, m√ºssen Sie niemanden fragen, wie der Code verkn√ºpft ist. Sie wissen, dass Sie eine Instanz davon erstellen m√ºssen, und wenn Sie dies versuchen, sto√üen Sie darauf, dass Sie Zugriffsparameter angeben m√ºssen. Ohne sie lie√üe sich der Code nicht einmal ausf√ºhren.

Und vor allem k√∂nnen Sie jetzt das Zahlungsgateway mocken, sodass Ihnen nicht bei jedem Testlauf 100 Dollar berechnet werden.

Globaler Zustand f√ºhrt dazu, dass Ihre Objekte heimlich auf Dinge zugreifen k√∂nnen, die nicht in ihrer API deklariert sind, und macht Ihre APIs dadurch zu pathologischen L√ºgnern.

Vielleicht haben Sie bisher nicht so dar√ºber nachgedacht, aber wann immer Sie globalen Zustand verwenden, erstellen Sie geheime drahtlose Kommunikationskan√§le. Spukhafte Fernwirkung zwingt Entwickler, jede Codezeile zu lesen, um potenzielle Interaktionen zu verstehen, reduziert die Produktivit√§t der Entwickler und verwirrt neue Teammitglieder. Wenn Sie derjenige sind, der den Code erstellt hat, kennen Sie die tats√§chlichen Abh√§ngigkeiten, aber jeder, der nach Ihnen kommt, ist ratlos.

Schreiben Sie keinen Code, der globalen Zustand verwendet, bevorzugen Sie die √úbergabe von Abh√§ngigkeiten. Also Dependency Injection.


Zerbrechlichkeit des globalen Zustands
--------------------------------------

In Code, der globalen Zustand und Singletons verwendet, ist nie sicher, wann und wer diesen Zustand ge√§ndert hat. Dieses Risiko tritt bereits bei der Initialisierung auf. Der folgende Code soll eine Datenbankverbindung herstellen und das Zahlungsgateway initialisieren, wirft jedoch st√§ndig eine Ausnahme, und die Suche nach der Ursache ist extrem langwierig:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Sie m√ºssen den Code detailliert durchgehen, um festzustellen, dass das `PaymentGateway`-Objekt drahtlos auf andere Objekte zugreift, von denen einige eine Datenbankverbindung erfordern. Daher muss die Datenbank vor `PaymentGateway` initialisiert werden. Die Nebelwand des globalen Zustands verbirgt dies jedoch vor Ihnen. Wie viel Zeit h√§tten Sie gespart, wenn die API der einzelnen Klassen nicht gelogen und ihre Abh√§ngigkeiten deklariert h√§tte?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Ein √§hnliches Problem tritt auch bei der Verwendung des globalen Zugriffs auf die Datenbankverbindung auf:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Beim Aufruf der Methode `save()` ist nicht sicher, ob die Datenbankverbindung bereits hergestellt wurde und wer f√ºr ihre Erstellung verantwortlich ist. Wenn wir beispielsweise die Datenbankverbindung zur Laufzeit √§ndern m√∂chten, etwa f√ºr Tests, m√ºssten wir wahrscheinlich weitere Methoden wie `DB::reconnect(...)` oder `DB::reconnectForTest()` erstellen.

Betrachten wir ein Beispiel:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Woher haben wir die Gewissheit, dass beim Aufruf von `$article->save()` tats√§chlich die Testdatenbank verwendet wird? Was w√§re, wenn die Methode `Foo::doSomething()` die globale Datenbankverbindung ge√§ndert h√§tte? Um dies herauszufinden, m√ºssten wir den Quellcode der Klasse `Foo` und wahrscheinlich auch vieler anderer Klassen untersuchen. Dieser Ansatz w√ºrde jedoch nur eine kurzfristige Antwort liefern, da sich die Situation in Zukunft √§ndern kann.

Und was w√§re, wenn wir die Datenbankverbindung in eine statische Variable innerhalb der Klasse `Article` verschieben?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Dadurch hat sich √ºberhaupt nichts ge√§ndert. Das Problem ist der globale Zustand, und es ist v√∂llig egal, in welcher Klasse er sich versteckt. In diesem Fall haben wir, genau wie im vorherigen, beim Aufruf der Methode `$article->save()` keinen Hinweis darauf, in welche Datenbank geschrieben wird. Irgendjemand am anderen Ende der Anwendung k√∂nnte die Datenbank jederzeit mit `Article::setDb()` √§ndern. Unter unseren H√§nden.

Globaler Zustand macht unsere Anwendung **extrem zerbrechlich**.

Es gibt jedoch eine einfache M√∂glichkeit, dieses Problem zu l√∂sen. Lassen Sie einfach die API Abh√§ngigkeiten deklarieren, um die korrekte Funktionalit√§t sicherzustellen.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Dank dieses Ansatzes entf√§llt die Sorge √ºber versteckte und unerwartete √Ñnderungen der Datenbankverbindung. Jetzt haben wir die Gewissheit, wohin der Artikel gespeichert wird, und keine Code√§nderungen innerhalb einer anderen, nicht zusammenh√§ngenden Klasse k√∂nnen die Situation mehr √§ndern. Der Code ist nicht mehr zerbrechlich, sondern stabil.

Schreiben Sie keinen Code, der globalen Zustand verwendet, bevorzugen Sie die √úbergabe von Abh√§ngigkeiten. Also Dependency Injection.


Singleton
---------

Singleton ist ein Entwurfsmuster, das laut der "Definition":https://en.wikipedia.org/wiki/Singleton_pattern aus der bekannten Publikation der Gang of Four eine Klasse auf eine einzige Instanz beschr√§nkt und einen globalen Zugriff darauf bietet. Die Implementierung dieses Musters √§hnelt normalerweise dem folgenden Code:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// und weitere Methoden, die die Funktionen der gegebenen Klasse erf√ºllen
}
```

Leider f√ºhrt das Singleton globalen Zustand in die Anwendung ein. Und wie wir oben gezeigt haben, ist globaler Zustand unerw√ºnscht. Daher wird das Singleton als Anti-Pattern betrachtet.

Verwenden Sie keine Singletons in Ihrem Code und ersetzen Sie sie durch andere Mechanismen. Sie ben√∂tigen Singletons wirklich nicht. Wenn Sie jedoch sicherstellen m√ºssen, dass nur eine einzige Instanz einer Klasse f√ºr die gesamte Anwendung existiert, √ºberlassen Sie dies dem [DI-Container |container]. Erstellen Sie so einen Anwendungs-Singleton, also einen Dienst. Dadurch k√ºmmert sich die Klasse nicht mehr um die Sicherstellung ihrer eigenen Einzigartigkeit (d. h. sie hat keine `getInstance()`-Methode und keine statische Variable) und erf√ºllt nur noch ihre Funktionen. So h√∂rt sie auf, das Prinzip der einzigen Verantwortung zu verletzen.


Globaler Zustand versus Tests
-----------------------------

Beim Schreiben von Tests gehen wir davon aus, dass jeder Test eine isolierte Einheit ist und kein externer Zustand in ihn eintritt. Und kein Zustand verl√§sst die Tests. Nach Abschluss eines Tests sollte der gesamte zugeh√∂rige Zustand automatisch vom Garbage Collector entfernt werden. Dadurch sind die Tests isoliert. Daher k√∂nnen wir Tests in beliebiger Reihenfolge ausf√ºhren.

Wenn jedoch globale Zust√§nde/Singletons vorhanden sind, zerfallen all diese angenehmen Annahmen. Zustand kann in den Test eintreten und ihn verlassen. Pl√∂tzlich kann die Reihenfolge der Tests eine Rolle spielen.

Um Singletons √ºberhaupt testen zu k√∂nnen, m√ºssen Entwickler oft ihre Eigenschaften lockern, etwa indem sie erlauben, die Instanz durch eine andere zu ersetzen. Solche L√∂sungen sind bestenfalls Hacks, die schwer wartbaren und verst√§ndlichen Code erzeugen. Jeder Test oder jede `tearDown()`-Methode, die einen globalen Zustand beeinflusst, muss diese √Ñnderungen r√ºckg√§ngig machen.

Globaler Zustand ist der gr√∂√üte Kopfschmerz beim Unit-Testing!

Wie kann man die Situation beheben? Einfach. Schreiben Sie keinen Code, der Singletons verwendet, bevorzugen Sie die √úbergabe von Abh√§ngigkeiten. Also Dependency Injection.


Globale Konstanten
------------------

Globaler Zustand beschr√§nkt sich nicht nur auf die Verwendung von Singletons und statischen Variablen, sondern kann auch globale Konstanten betreffen.

Konstanten, deren Wert uns keine neue (`M_PI`) oder n√ºtzliche (`PREG_BACKTRACK_LIMIT_ERROR`) Information bringt, sind eindeutig in Ordnung. Im Gegensatz dazu sind Konstanten, die als Mittel dienen, Informationen *drahtlos* in den Code zu √ºbergeben, nichts anderes als versteckte Abh√§ngigkeiten. Wie z. B. `LOG_FILE` im folgenden Beispiel. Die Verwendung der Konstante `FILE_APPEND` ist v√∂llig korrekt.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

In diesem Fall sollten wir einen Parameter im Konstruktor der Klasse `Foo` deklarieren, damit er Teil der API wird:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Jetzt k√∂nnen wir die Information √ºber den Pfad zur Log-Datei √ºbergeben und sie bei Bedarf leicht √§ndern, was das Testen und die Wartung des Codes erleichtert.


Globale Funktionen und statische Methoden
-----------------------------------------

Wir m√∂chten betonen, dass die Verwendung statischer Methoden und globaler Funktionen an sich nicht problematisch ist. Wir haben erkl√§rt, warum die Verwendung von `DB::insert()` und √§hnlichen Methoden ungeeignet ist, aber es ging immer nur um den globalen Zustand, der in einer statischen Variablen gespeichert ist. Die Methode `DB::insert()` erfordert die Existenz einer statischen Variablen, da darin die Datenbankverbindung gespeichert ist. Ohne diese Variable w√§re es unm√∂glich, die Methode zu implementieren.

Die Verwendung deterministischer statischer Methoden und Funktionen wie `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` und vielen anderen steht in vollem Einklang mit der Dependency Injection. Diese Funktionen geben bei gleichen Eingabeparametern immer die gleichen Ergebnisse zur√ºck und sind daher vorhersagbar. Sie verwenden keinen globalen Zustand.

Es gibt jedoch auch Funktionen in PHP, die nicht deterministisch sind. Dazu geh√∂rt beispielsweise die Funktion `htmlspecialchars()`. Ihr dritter Parameter `$encoding`, falls nicht angegeben, hat als Standardwert den Wert der Konfigurationsoption `ini_get('default_charset')`. Daher wird empfohlen, diesen Parameter immer anzugeben, um m√∂gliches unvorhersehbares Verhalten der Funktion zu vermeiden. Nette tut dies konsequent.

Einige Funktionen wie `strtolower()`, `strtoupper()` und √§hnliche verhielten sich in der j√ºngeren Vergangenheit nicht deterministisch und waren von der Einstellung `setlocale()` abh√§ngig. Dies verursachte viele Komplikationen, am h√§ufigsten bei der Arbeit mit der t√ºrkischen Sprache. Diese unterscheidet n√§mlich sowohl Klein- als auch Gro√übuchstaben `I` mit und ohne Punkt. So gab `strtolower('I')` den Buchstaben `ƒ±` zur√ºck und `strtoupper('i')` den Buchstaben `ƒ∞`, was dazu f√ºhrte, dass Anwendungen eine Reihe r√§tselhafter Fehler verursachten. Dieses Problem wurde jedoch in PHP Version 8.2 behoben, und die Funktionen sind nicht mehr von der Locale abh√§ngig.

Dies ist ein sch√∂nes Beispiel daf√ºr, wie globaler Zustand Tausende von Entwicklern weltweit geplagt hat. Die L√∂sung bestand darin, ihn durch Dependency Injection zu ersetzen.


Wann ist die Verwendung von globalem Zustand m√∂glich?
-----------------------------------------------------

Es gibt bestimmte spezifische Situationen, in denen die Verwendung von globalem Zustand m√∂glich ist. Zum Beispiel beim Debuggen von Code, wenn Sie den Wert einer Variablen ausgeben oder die Dauer eines bestimmten Programmteils messen m√ºssen. In solchen F√§llen, die sich auf tempor√§re Aktionen beziehen, die sp√§ter aus dem Code entfernt werden, ist es legitim, einen global verf√ºgbaren Dumper oder eine Stoppuhr zu verwenden. Diese Werkzeuge sind n√§mlich nicht Teil des Code-Designs.

Ein weiteres Beispiel sind Funktionen zur Arbeit mit regul√§ren Ausdr√ºcken `preg_*`, die intern kompilierte regul√§re Ausdr√ºcke in einem statischen Cache im Speicher ablegen. Wenn Sie also denselben regul√§ren Ausdruck mehrmals an verschiedenen Stellen im Code aufrufen, wird er nur einmal kompiliert. Der Cache spart Leistung und ist gleichzeitig f√ºr den Benutzer v√∂llig unsichtbar, daher kann eine solche Verwendung als legitim angesehen werden.


Zusammenfassung
---------------

Wir haben besprochen, warum es sinnvoll ist:

1) Alle statischen Variablen aus dem Code zu entfernen
2) Abh√§ngigkeiten zu deklarieren
3) Und Dependency Injection zu verwenden

Wenn Sie √ºber das Code-Design nachdenken, denken Sie daran, dass jedes `static $foo` ein Problem darstellt. Damit Ihr Code eine Umgebung ist, die DI respektiert, ist es unerl√§sslich, den globalen Zustand vollst√§ndig zu beseitigen und ihn durch Dependency Injection zu ersetzen.

W√§hrend dieses Prozesses stellen Sie m√∂glicherweise fest, dass eine Klasse aufgeteilt werden muss, da sie mehr als eine Verantwortung hat. Scheuen Sie sich nicht davor; streben Sie das Prinzip der einzigen Verantwortung an.

*Ich m√∂chte Mi≈°ko Hevery danken, dessen Artikel wie [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] die Grundlage f√ºr dieses Kapitel bilden.*
