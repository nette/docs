Protection contre les vulnérabilités
************************************

.[perex]
De temps en temps, une faille de sécurité est signalée sur un autre site web important ou une faille est exploitée. C'est désagréable. Si la sécurité de vos applications web vous tient à cœur, Nette Framework est certainement le meilleur choix.


Cross-Site Scripting (XSS)
==========================

Le Cross-Site Scripting est une méthode de violation des pages web exploitant des sorties non traitées. L'attaquant peut alors injecter son propre code dans la page et ainsi la modifier ou même obtenir des données sensibles sur les visiteurs. On ne peut se défendre contre le XSS qu'en traitant de manière cohérente et correcte toutes les chaînes. Pourtant, il suffit que votre codeur l'omette une seule fois, et tout le site peut être compromis d'un coup.

Un exemple d'attaque peut être l'injection d'une URL modifiée à l'utilisateur, à l'aide de laquelle nous injectons notre code dans la page. Si l'application ne traite pas correctement les sorties, elle exécutera le script dans le navigateur de l'utilisateur. De cette manière, nous pouvons par exemple lui voler son identité.

```
https://example.com/?search=<script>alert('Attaque XSS réussie.');</script>
```

Nette Framework introduit une technologie révolutionnaire [d'Échappement sensible au contexte |latte:safety-first#Échappement sensible au contexte], qui vous débarrasse à jamais du risque de Cross-Site Scripting. Il traite automatiquement toutes les sorties, de sorte qu'il est impossible qu'un codeur oublie quelque chose. Un exemple ? Le codeur crée ce template :

```latte
<p onclick="alert({$message})">{$message}</p>

<script>
document.title = {$message};
</script>
```

La notation `{$message}` signifie afficher la variable. Dans d'autres frameworks, il est nécessaire de traiter explicitement chaque affichage et même différemment à chaque endroit. Dans Nette Framework, il n'est pas nécessaire de traiter quoi que ce soit, tout est fait automatiquement, correctement et de manière cohérente. Si nous attribuons à la variable `$message = 'Largeur 1/2"'`, le framework générera le code HTML :

```latte
<p onclick="alert(&quot;Largeur 1\/2\&quot;&quot;)">Largeur 1/2&quot;</p>

<script>
document.title = "Largeur 1\/2\"";
</script>
```


Cross-Site Request Forgery (CSRF)
=================================

L'attaque Cross-Site Request Forgery consiste pour l'attaquant à attirer la victime sur une page qui exécute discrètement dans le navigateur de la victime une requête vers le serveur sur lequel la victime est connectée, et le serveur croit que la requête a été exécutée par la victime de sa propre volonté. Ainsi, sous l'identité de la victime, il effectue une certaine action sans que celle-ci le sache. Il peut s'agir de modifier ou de supprimer des données, d'envoyer un message, etc.

Nette Framework **protège automatiquement les formulaires et les signaux dans les presenters** contre ce type d'attaque. Et ce, en empêchant leur envoi ou leur déclenchement depuis un autre domaine. Si vous souhaitez désactiver la protection, utilisez pour les formulaires :

```php
$form->allowCrossOrigin();
```

ou dans le cas d'un signal, ajoutez l'annotation `@crossOrigin`:

```php
/**
 * @crossOrigin
 */
public function handleXyz()
{
}
```

Dans Nette Application 3.2, vous pouvez également utiliser des attributs :

```php
use Nette\Application\Attributes\Requires;

#[Requires(sameOrigin: false)]
public function handleXyz()
{
}
```


Attaque d'URL, codes de contrôle, UTF-8 invalide
================================================

Divers termes liés à la tentative de l'attaquant d'injecter une entrée *malveillante* dans votre application web. Les conséquences peuvent être très diverses, allant de l'endommagement des sorties XML (par exemple, des flux RSS non fonctionnels) à l'obtention d'informations sensibles de la base de données ou de mots de passe. La défense consiste en un traitement cohérent de toutes les entrées au niveau des octets individuels. Et soyons honnêtes, qui d'entre vous le fait ?

Nette Framework le fait pour vous et de plus automatiquement. Vous n'avez rien à configurer du tout et toutes les entrées seront traitées.


Détournement de session, vol de session, fixation de session
============================================================

Plusieurs types d'attaques sont liés à la gestion des sessions. L'attaquant vole ou injecte son ID de session à l'utilisateur et obtient ainsi l'accès à l'application web sans connaître le mot de passe de l'utilisateur. Il peut ensuite faire n'importe quoi dans l'application sans que l'utilisateur le sache. La défense consiste en une configuration correcte du serveur et de PHP.

Nette Framework configure PHP automatiquement. Le programmeur n'a donc pas à réfléchir à la manière de sécuriser correctement la session et peut se concentrer pleinement sur la création de l'application. Cela nécessite cependant que la fonction `ini_set()` soit activée.


Cookie SameSite
===============

Les cookies SameSite fournissent un mécanisme pour reconnaître ce qui a conduit au chargement de la page. Ce qui est absolument essentiel pour la sécurité.

L'indicateur SameSite peut avoir trois valeurs : `Lax`, `Strict` et `None` (ce dernier nécessite HTTPS). Si la requête de page provient directement du site ou si l'utilisateur ouvre la page en la saisissant directement dans la barre d'adresse ou en cliquant sur un signet, le navigateur envoie tous les cookies au serveur (c'est-à-dire avec les indicateurs `Lax`, `Strict` et `None`). Si l'utilisateur accède au site via un lien depuis un autre site, les cookies avec les indicateurs `Lax` et `None` sont transmis au serveur. Si la requête est générée d'une autre manière, comme l'envoi d'un formulaire POST depuis un autre site, le chargement à l'intérieur d'un iframe, via JavaScript, etc., seuls les cookies avec l'indicateur `None` sont envoyés.

Nette envoie par défaut tous les cookies avec l'indicateur `Lax`.

{{leftbar: www:@menu-common}}
