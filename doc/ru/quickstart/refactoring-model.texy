Модель
******

По мере роста нашего приложения мы вскоре обнаруживаем, что нам необходимо выполнять аналогичные операции с базой данных в разных местах и в разных презентерах. Например, получать самые новые опубликованные статьи. Если мы улучшим наше приложение, добавив к статьям флаг, указывающий на состояние готовности, мы также должны пройтись по всем местам в нашем приложении и добавить условие *where*, чтобы убедиться, что выбираются только готовые статьи.

На этом этапе прямой работы с базой данных становится недостаточно, и разумнее будет помочь себе новой функцией, возвращающей опубликованные статьи. И когда позже мы добавим ещё один пункт (например, не отображать статьи с будущей датой), мы будем редактировать наш код только в одном месте.

Мы поместим функцию в класс `PostFacade` и назовем её `getPublicArticles()`.

Создадим наш класс модели `PostFacade` в директории `app/Model/`, чтобы позаботиться о наших статьях. Давайте поместим его в файл `PostFacade.php`.

```php .{data-file:app/Model/PostFacade.php}
namespace App\Model;

use Nette;

final class PostFacade
{
	use Nette\SmartObject;

	private Nette\Database\Explorer $database;

	public function __construct(Nette\Database\Explorer $database)
	{
		$this->database = $database;
	}

	public function getPublicArticles()
	{
		return $this->database
			->table('posts')
			->where('created_at < ', new \DateTime)
			->order('created_at DESC');
	}
}
```

В этом классе мы передаем базу данных Explorer:[api:Nette\Database\Explorer]. Это позволит использовать возможности [DI-контейнера|/dependency-injection/passing-dependencies].

Добавьте строку с полным именем класса в файл `config/services.neon` в секции services:

```neon .{data-file:config/services.neon}
services:
	- App\Router\RouterFactory::createRouter
	- App\Model\PostFacade
```

Таким образом, мы сообщаем Nette и её контейнеру DI следующее: «Если кому-то нужен экземпляр этого класса, вы знаете, где его найти. Дайте этому экземпляру всё, что ему нужно, и подготовьте его к использованию в других классах». Класс, зарегистрированный таким образом, называется **сервисом** (или *службой*, кому как нравится).


Перейдем к файлу `HomepagePresenter.php`, который мы отредактируем так, чтобы избавиться от зависимости от `Nette\Database\Explorer`, заменив её новой зависимостью от нашего созданного класса.

```php .{data-file:app/Presenters/HomepagePresenter.php}
namespace App\Presenters;

use App\Model\PostFacade;
use Nette;

final class HomepagePresenter extends Nette\Application\UI\Presenter
{
	private PostFacade $facade;

	public function __construct(PostFacade $facade)
	{
		$this->facade = $facade;
	}

	public function renderDefault(): void
	{
		$this->template->posts = $this->facade
			->getPublicArticles()
			->limit(5);
	}
}
```

В секции `use` мы используем `App\Model\PostFacade`. Таким образом можно сократить наш PHP-код только до PostFacade (не бойтесь, он работает даже в комментариях, и ваша умная IDE должна быть в состоянии справиться с этим).

Мы запрашиваем `PostFacade` в конструкторе и присваиваем атрибуту `$facade`, а в методе `renderDefault` мы вызываем метод `getPublicArticles()`. Мы также вызываем метод `limit(5)` на результате этой функции.

Класс `PostFacade` запрашивает `Nette\Database\Explorer` в конструкторе, и поскольку этот класс зарегистрирован в контейнере DI, контейнер создает этот экземпляр и передает его. DI таким образом создает для нас экземпляр PostFacade и передает его в конструкторе классу HomepagePresenter, который его запросил. Своего рода матрешка кода. :) Все компоненты запрашивают только то, что им нужно, и их не волнует, где и как это будет создано. Созданием занимается DI-контейнер.

{{priority: -1}}
{{sitename: Nette Quickstart}}
