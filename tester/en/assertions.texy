Assertions
**********

In the example on "guide page":[guide#writing the tests] we used two assertions: `Assert::same()` and `Assert::exception()`. Now we introduce all other types and we explain how to be used. They are methods of the `Tester\Assert` class but for simplification, we use them further without namespace.


Assert::same($expected, $actual) .[method]
------------------------------------------
`$expected` must be the same as `$actual`. It is the same as PHP operator `===`.


Assert::notSame($expected, $actual) .[method]
---------------------------------------------
Opposite to `Assert::same()`.


Assert::equal($expected, $actual) .[method]
-------------------------------------------
`$expected` must be equal to `$actual`, or must "fulfill expectations":[#expectations]. Object identities and array keys order are ignored.


Assert::notEqual($expected, $actual) .[method]
----------------------------------------------
Opposite to `Assert::equal()`.


Assert::contains($needle, $actual) .[method]
--------------------------------------------
`$actual` must contain `$needle`. If `$actual` is string, it must contain `$needle` substring. If it is an array, it must contain `$needle` item.


Assert::notContains($needle, $actual) .[method]
-----------------------------------------------
Opposite to `Assert::contains()`.


Assert::true($value) .[method]
------------------------------
`$value` must be `true`, so `$value === true`.


Assert::truthy($value) .[method]
--------------------------------
`$value` must be truthy, so `$value == true`.


Assert::false($value) .[method]
-------------------------------
`$value` must be `false`, so `$value === false`.


Assert::falsey($value) .[method]
--------------------------------
`$value` must be falsey, so `$value == false`.


Assert::count($count, $value) .[method]
---------------------------------------
`$count` must be number of elements in `$value`. Countable is an array or an object implementing `Countable`.


Assert::null($value) .[method]
------------------------------
`$value` must be `null`, so `$value === null`.


Assert::nan($value) .[method]
-----------------------------
`$value` must be Not a Number.


Assert::type($type, $value) .[method]
-------------------------------------
`$value` must be of a given type. As `$type` we can use string:
- `array`
- `list` - same as the array but keys must start by zero and must be incremented by one
- `bool`
- `callable`
- `float`
- `int` or `integer`
- `null`
- `object`
- `resource`
- `scalar`
- `string`
- class name or object directly then must pass `$value instanceof $type`


Assert::exception($callable, $class, $message = null, $code = null) .[method]
-----------------------------------------------------------------------------
On `$callable` invocation an exception of `$class` instance must be thrown. If we pass `$message`, the message of the exception must match (see [Assert::match() |#assert-match]). And if we pass `$code`, code of the exception must be the same. For example, this test fails because message of the exception does not match:

```php
Assert::exception(function () {
	throw new App\InvalidValueException('Zero value');
}, App\InvalidValueException::class, 'Value is to low');
```

The `Assert::exception()` is unique by returning the thrown exception. So we can test a previous exception:

```php
$e = Assert::exception(function () {
	throw new MyException('Something is wrong', 0, new RuntimeException);
}, MyException::class, 'Something is wrong');

Assert::type(RuntimeException::class, $e->getPrevious());
```


Assert::error($callable, $type, $message = null) .[method]
----------------------------------------------------------
If we pass a class name as `$type`, this assertion behaves as absolutely same as `Assert::exception()`.

If `$type` is one of `E_...` constants, for example `E_WARNING`, the `$callable` must generate this error when invoked. And if we pass `$message` message of the error must match (see [Assert::match() |#assert-match]). For example:

```php
Assert::error(function () {
	$i++;
}, E_NOTICE, 'Undefined variable: i');
```

And the last possibility, if `$type` is an array the `$callable` must generate all expected errors. An example shows it best:

```php
Assert::error(function () {
	$a++;
	$b++;
}, [
	[E_NOTICE, 'Undefined variable: a'],
	[E_NOTICE, 'Undefined variable: b'],
]);
```


Assert::noError($callable) .[method]
------------------------------------
Checks that the function `$callable` does not throw any PHP warning/notice/error or exception. It is useful for testing a piece of code where is no other assertion.


Assert::match($pattern, $actual) .[method]
------------------------------------------
`$actual` must match to `$pattern`. We can use two pattern types:

We pass a regular expression as `$pattern`. To delimit it we must use `~` or `#`. Other delimiters are not supported. For example test where `$var` must contain only hexadecimal digits:

```php
Assert::match('#^[0-9a-f]$#i', $var);
```

The other variant is similar to string comparing but we can use some modifiers in `$pattern`:
- `%a%` one or more of anything except for the end of line characters
- `%a?%` zero or more of anything except for the end of line characters
- `%A%` one or more of anything including the end of line characters
- `%A?%` zero or more of anything including the end of line characters
- `%s%` one or more white space characters except for the end of line characters
- `%s?%` zero or more white space characters except for the end of line characters
- `%S%` one or more of characters except for the white space
- `%S?%` zero or more of characters except for the white space
- `%c%` a single character of any sort (except for the end of line)
- `%d%` one or more digits
- `%d?%` zero or more digits
- `%i%` signed integer value
- `%f%` floating point number
- `%h%` one or more HEX digits
- `%w%` one or more alphanumeric characters
- `%%` one % character

Examples:

```php
# Again, hexadecimal number test
Assert::match('%h%', $var);

# Generalized path to file and line number
Assert::match('Error in file %a% on line %i%', $errorMessage);
```


Assert::matchFile($file, $actual) .[method]
-------------------------------------------
The assertion is identical to [Assert::match() |#assert-match] but the pattern is loaded from `$file`. It is useful for very long strings testing. Test file stands readable.


Assert::fail($message, $actual = null, $expected = null) .[method]
------------------------------------------------------------------
This assertion always fails. It is just handy. We can optionally pass expected and actual values.


Expectations
------------
When comparing more complex structures, the assertions above may not be sufficient when some structure items are of random nature. For example some hashes or timestamps. In that case we can use `Tester\Expect` objects inside `$expected` parameter of `Assert::equal()` and `Assert::notEqual()` methods as following.

Let's suppose that we test a method that creates a new user and returns its attributes as an array.

```php
use Tester\Expect;

Assert::equal([
	'id' => 123,
	'username' => 'milo',
	'password' => Expect::match('%h%'),  # random string, hash, but must match some pattern
	'created_at' => Expect::type(DateTimeImmutable::class),  # check type only, not exact value
], User::create(123, 'milo', 'RandomPaSsWoRd'));
```

With `Expect`, we can make almost the same assertions as with `Assert`. So `Expect::same()`, `Expect::match()`, `Expect::count()` and so on are available. Moreover, we can chain them like:

```php
Expect::type(MyIterator::class)->andCount(5);  # item is the MyIterator object and its count is 5
```

Or, we can write own assertion callbacks.

```php
Expect::that(function ($value) {
	# return false if expectation fails
});
```


Failed assertions investigation
-------------------------------
The Tester shows where the error is when an assertion fails. When we compare complex structures, the Tester creates dumps of compared values and saves them into directory **output**. For example when imaginary test `Arrays.recursive.phpt` fails the dumps will be saved as follows:

```
app/
└── tests/
    ├── output/
    │   ├── Arrays.recursive.actual    # actual value
    │   └── Arrays.recursive.expected  # expected value
    │
    └── Arrays.recursive.phpt          # failing test
```

We can change the name of the directory by `Tester\Dumper::$dumpDir`.



Tips
----
- Choose the most accurate assertions. For example `Assert::same($a, $b)`, not `Assert::true($a === $b)`. Only in the first case we get meaningful error message. In the other case we get `false should be true` only and it says nothing about $a and $b variables contents.
- Use the `Assert::nan()` for NAN (Not a Value) testing. NAN value is very specific and assertions `Assert::same()` or `Assert::equal()` can behave unpredictably.
