Globalno stanje in singletoni
*****************************

.[perex]
Opozorilo: Naslednje konstrukcije so znak slabo naÄrtovane kode:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` ali `static::$var`

Ali se nekatere od teh konstrukcij pojavljajo v vaÅ¡i kodi? Potem imate priloÅ¾nost za njeno izboljÅ¡anje. Morda si mislite, da gre za obiÄajne konstrukcije, ki jih vidite na primer tudi v vzorÄnih reÅ¡itvah razliÄnih knjiÅ¾nic in ogrodij. ÄŒe je temu tako, potem naÄrtovanje njihove kode ni dobro.

Zdaj zagotovo ne govorimo o neki akademski Äistosti. Vse te konstrukcije imajo eno skupno: izkoriÅ¡Äajo globalno stanje. In to ima uniÄujoÄ vpliv na kakovost kode. Razredi laÅ¾ejo o svojih odvisnostih. Koda postane nepredvidljiva. Zmede programerje in zmanjÅ¡uje njihovo uÄinkovitost.

V tem poglavju si bomo razloÅ¾ili, zakaj je temu tako in kako se globalnemu stanju izogniti.


Globalna povezanost
-------------------

V idealnem svetu bi moral objekt biti sposoben komunicirati samo z objekti, ki so mu bili [neposredno posredovani |passing-dependencies]. ÄŒe ustvarim dva objekta `A` in `B` in nikoli ne posredujem reference med njima, potem se niti `A` niti `B` ne moreta dostopati do drugega objekta ali spremeniti njegovega stanja. To je zelo zaÅ¾elena lastnost kode. Podobno je, kot Äe imate baterijo in Å¾arnico; Å¾arnica ne bo svetila, dokler je z baterijo ne poveÅ¾ete z Å¾ico.

To pa ne velja pri globalnih (statiÄnih) spremenljivkah ali singletonih. Objekt `A` bi se lahko *brezÅ¾iÄno* dostopal do objekta `C` in ga modificiral brez kakrÅ¡nega koli posredovanja reference, s klicem `C::changeSomething()`. ÄŒe se objekt `B` prav tako oprime globalnega `C`, potem se `A` in `B` lahko medsebojno vplivata prek `C`.

Uporaba globalnih spremenljivk v sistem vnaÅ¡a novo obliko *brezÅ¾iÄne* povezanosti, ki od zunaj ni vidna. Ustvarja dimno zaveso, ki oteÅ¾uje razumevanje in uporabo kode. Da bi razvijalci odvisnosti resniÄno razumeli, morajo prebrati vsako vrstico izvorne kode. Namesto zgolj seznanitve z vmesnikom razredov. Gre poleg tega za popolnoma nepotrebno povezanost. Globalno stanje se uporablja zato, ker je enostavno dostopno od kjerkoli in omogoÄa na primer zapis v podatkovno bazo prek globalne (statiÄne) metode `DB::insert()`. Ampak kot si bomo pokazali, je prednost, ki jo to prinaÅ¡a, neznatna, nasprotno pa povzroÄa usodne zaplete.

.[note]
Z vidika obnaÅ¡anja ni razlike med globalno in statiÄno spremenljivko. Sta enako Å¡kodljivi.


StraÅ¡ljivo delovanje na daljavo
-------------------------------

"StraÅ¡ljivo delovanje na daljavo" - tako je slavno leta 1935 Albert Einstein poimenoval pojav v kvantni fiziki, ki mu je naganjal kurjo polt.
Gre za kvantno prepletenost, katere posebnost je, da ko izmerite informacijo o enem delcu, s tem takoj vplivate na drugi delec, tudi Äe sta med seboj oddaljena milijone svetlobnih let. Kar navidezno krÅ¡i osnovni zakon vesolja, da se niÄ ne more Å¡iriti hitreje od svetlobe.

V svetu programske opreme lahko "straÅ¡ljivo delovanje na daljavo" poimenujemo situacijo, ko zaÅ¾enemo nek proces, za katerega menimo, da je izoliran (ker mu nismo posredovali nobenih referenc), vendar na oddaljenih mestih sistema pride do nepriÄakovanih interakcij in sprememb stanja, o katerih nismo imeli pojma. Do tega lahko pride samo prek globalnega stanja.

Predstavljajte si, da se pridruÅ¾ite ekipi razvijalcev projekta, ki ima obseÅ¾no napredno kodno bazo. VaÅ¡ novi vodja vas prosi za implementacijo nove funkcije in vi kot pravi razvijalec zaÄnete s pisanjem testa. Ker pa ste v projektu novi, delate veliko raziskovalnih testov tipa "kaj se zgodi, Äe pokliÄem to metodo". In poskusite napisati naslednji test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // Å¡tevilka vaÅ¡e kartice
	$cc->charge(100);
}
```

ZaÅ¾enete kodo, morda veÄkrat, in po nekem Äasu opazite na mobilnem telefonu obvestila iz banke, da se je ob vsakem zagonu odÅ¡telo 100 dolarjev z vaÅ¡e plaÄilne kartice ğŸ¤¦â€â™‚ï¸

Kako za vraga je lahko test povzroÄil dejansko odtegnitev denarja? Upravljanje s plaÄilno kartico ni enostavno. Morate komunicirati s spletno storitvijo tretje osebe, morate poznati URL te spletne storitve, morate se prijaviti in tako naprej. Nobena od teh informacij ni vsebovana v testu. Å e huje, niti ne veste, kje so te informacije prisotne, in torej niti kako mockati zunanje odvisnosti, da vsak zagon ne bi vodil k temu, da se ponovno odÅ¡teje 100 dolarjev. In kako ste kot novi razvijalec morali vedeti, da bo to, kar se pripravljate storiti, vodilo k temu, da boste za 100 dolarjev revnejÅ¡i?

To je straÅ¡ljivo delovanje na daljavo!

Ne preostane vam drugega, kot da se dolgo prebijate skozi veliko izvorne kode, spraÅ¡ujete starejÅ¡e in izkuÅ¡enejÅ¡e kolege, preden razumete, kako povezave v projektu delujejo. To je posledica tega, da ob pogledu na vmesnik razreda `CreditCard` ni mogoÄe ugotoviti globalnega stanja, ki ga je treba inicializirati. Celo pogled v izvorno kodo razreda vam ne bo razkril, katero inicializacijsko metodo morate poklicati. V najboljÅ¡em primeru lahko najdete globalno spremenljivko, do katere se dostopa, in iz nje poskusite uganiti, kako jo inicializirati.

Razredi v takem projektu so patoloÅ¡ki laÅ¾nivci. PlaÄilna kartica se pretvarja, da jo zadostuje instancirati in poklicati metodo `charge()`. Skrito pa sodeluje z drugim razredom `PaymentGateway`, ki predstavlja plaÄilni prehod. Tudi njen vmesnik pravi, da jo je mogoÄe inicializirati samostojno, vendar v resnici potegne poverilnice iz neke konfiguracijske datoteke in tako naprej. Razvijalcem, ki so to kodo napisali, je jasno, da `CreditCard` potrebuje `PaymentGateway`. Kodo so napisali na ta naÄin. Ampak za vsakogar, ki je v projektu nov, je to popolna uganka in ovira uÄenje.

Kako situacijo popraviti? Enostavno. **Pustite API-ju, da deklarira odvisnosti.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Opazite, kako so naenkrat povezave znotraj kode oÄitne. S tem, ko metoda `charge()` deklarira, da potrebuje `PaymentGateway`, vam ni treba nikogar spraÅ¡evati, kako je koda povezana. Veste, da morate ustvariti njeno instanco, in ko to poskusite, naletite na to, da morate dodati dostopne parametre. Brez njih kode ne bi bilo mogoÄe niti zagnati.

In predvsem zdaj lahko plaÄilni prehod mockate, tako da se vam ob vsakem zagonu testa ne bo zaraÄunalo 100 dolarjev.

Globalno stanje povzroÄa, da se vaÅ¡i objekti lahko skrivaj dostopajo do stvari, ki niso deklarirane v njihovem API-ju, in poslediÄno delajo iz vaÅ¡ih API-jev patoloÅ¡ke laÅ¾nivce.

Morda o tem prej niste tako razmiÅ¡ljali, ampak kadarkoli uporabljate globalno stanje, ustvarjate skrivne brezÅ¾iÄne komunikacijske kanale. StraÅ¡ljivo delovanje na daljavo sili razvijalce, da berejo vsako vrstico kode, da bi razumeli potencialne interakcije, zmanjÅ¡uje produktivnost razvijalcev in zmede nove Älane ekipe. ÄŒe ste vi tisti, ki ste kodo ustvarili, poznate dejanske odvisnosti, ampak vsakdo, ki pride za vami, je nemoÄen.

Ne piÅ¡ite kode, ki izkoriÅ¡Äa globalno stanje, dajte prednost posredovanju odvisnosti. Torej dependency injection.


Krhkost globalnega stanja
-------------------------

V kodi, ki uporablja globalno stanje in singletone, nikoli ni gotovo, kdaj in kdo je to stanje spremenil. To tveganje se pojavlja Å¾e pri inicializaciji. Naslednja koda naj bi ustvarila povezavo s podatkovno bazo in inicializirala plaÄilni prehod, vendar nenehno meÄe izjemo in iskanje vzroka je izjemno dolgotrajno:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Morate podrobno pregledovati kodo, da ugotovite, da objekt `PaymentGateway` brezÅ¾iÄno dostopa do drugih objektov, od katerih nekateri zahtevajo povezavo s podatkovno bazo. Torej je treba inicializirati podatkovno bazo prej kot `PaymentGateway`. Vendar dimna zavesa globalnega stanja to pred vami skriva. Koliko Äasa bi prihranili, Äe API posameznih razredov ne bi lagal in bi deklariral svoje odvisnosti?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Podobna teÅ¾ava se pojavlja tudi pri uporabi globalnega dostopa do povezave s podatkovno bazo:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Pri klicu metode `save()` ni gotovo, ali je bila povezava s podatkovno bazo Å¾e ustvarjena in kdo nosi odgovornost za njeno ustvarjanje. ÄŒe Å¾elimo na primer spreminjati povezavo s podatkovno bazo med izvajanjem, na primer zaradi testov, bi morali najverjetneje ustvariti dodatne metode, kot na primer `DB::reconnect(...)` ali `DB::reconnectForTest()`.

Razmislimo o primeru:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Kje imamo gotovost, da se pri klicu `$article->save()` res uporablja testna podatkovna baza? Kaj Äe je metoda `Foo::doSomething()` spremenila globalno povezavo s podatkovno bazo? Za ugotovitev bi morali pregledati izvorno kodo razreda `Foo` in verjetno tudi mnogih drugih razredov. Ta pristop bi prinesel le kratkoroÄen odgovor, saj se situacija lahko v prihodnosti spremeni.

In kaj Äe povezavo s podatkovno bazo premaknemo v statiÄno spremenljivko znotraj razreda `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

S tem se sploh niÄ ni spremenilo. TeÅ¾ava je globalno stanje in popolnoma vseeno je, v katerem razredu se skriva. V tem primeru, enako kot v prejÅ¡njem, nimamo pri klicu metode `$article->save()` nobenega namiga o tem, v katero bazo podatkov se bo zapisalo. Kdorkoli na drugem koncu aplikacije je lahko kadarkoli z `Article::setDb()` bazo podatkov spremenil. Nam pod rokami.

Globalno stanje naredi naÅ¡o aplikacijo **izjemno krhko**.

Obstaja pa preprost naÄin, kako se s to teÅ¾avo spopasti. Zadostuje, da API deklarira odvisnosti, s Äimer se zagotovi pravilna funkcionalnost.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

ZahvaljujoÄ temu pristopu odpade skrb za skrite in nepriÄakovane spremembe povezave z bazo podatkov. Zdaj imamo gotovost, kam se Älanek shranjuje in nobene spremembe kode znotraj druge nepovezane razreda Å¾e ne morejo situacije spremeniti. Koda ni veÄ krhka, ampak stabilna.

Ne piÅ¡ite kode, ki izkoriÅ¡Äa globalno stanje, dajte prednost posredovanju odvisnosti. Torej dependency injection.


Singleton
---------

Singleton je naÄrtovalski vzorec, ki po "definiciji":https://en.wikipedia.org/wiki/Singleton_pattern iz znane publikacije Gang of Four omejuje razred na eno samo instanco in ponuja globalni dostop do nje. Implementacija tega vzorca se obiÄajno podobna naslednji kodi:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// in druge metode, ki opravljajo funkcije danega razreda
}
```

Na Å¾alost singleton v aplikacijo uvaja globalno stanje. In kot smo si pokazali zgoraj, je globalno stanje nezaÅ¾eleno. Zato je singleton obravnavan kot antipattern.

Ne uporabljajte v svoji kodi singletonov in jih nadomestite z drugimi mehanizmi. Singletonov resniÄno ne potrebujete. ÄŒe pa morate zagotoviti obstoj ene same instance razreda za celotno aplikacijo, pustite to [DI vsebniku |container]. Ustvarite tako aplikacijski singleton, ali storitev. S tem se razred preneha ukvarjati z zagotavljanjem svoje lastne edinstvenosti (tj. ne bo imel metode `getInstance()` in statiÄne spremenljivke) in bo opravljal samo svoje funkcije. Tako ne bo veÄ krÅ¡il naÄela ene same odgovornosti.


Globalno stanje proti testom
----------------------------

Pri pisanju testov predpostavljamo, da je vsak test izolirana enota in da vanj ne vstopa nobeno zunanje stanje. In nobeno stanje testov ne zapuÅ¡Äa. Po zakljuÄku testa bi moralo biti vse povezano stanje s testom samodejno odstranjeno z garbage collectorjem. ZahvaljujoÄ temu so testi izolirani. Zato lahko teste izvajamo v poljubnem vrstnem redu.

ÄŒe pa so prisotna globalna stanja/singletoni, se vse te prijetne predpostavke razblinijo. Stanje lahko vstopa v test in izstopa iz njega. Naenkrat lahko postane pomemben vrstni red testov.

Da bi sploh lahko testirali singletone, morajo razvijalci pogosto sprostiti njihove lastnosti, na primer tako, da dovolijo zamenjavo instance z drugo. Take reÅ¡itve so v najboljÅ¡em primeru hack, ki ustvarja teÅ¾ko vzdrÅ¾ljivo in razumljivo kodo. Vsak test ali metoda `tearDown()`, ki vpliva na katero koli globalno stanje, mora te spremembe vrniti nazaj.

Globalno stanje je najveÄja boleÄina pri unit testiranju!

Kako situacijo popraviti? Enostavno. Ne piÅ¡ite kode, ki izkoriÅ¡Äa singletone, dajte prednost posredovanju odvisnosti. Torej dependency injection.


Globalne konstante
------------------

Globalno stanje se ne omejuje samo na uporabo singletonov in statiÄnih spremenljivk, ampak se lahko nanaÅ¡a tudi na globalne konstante.

Konstante, katerih vrednost nam ne prinaÅ¡a nobene nove (`M_PI`) ali koristne (`PREG_BACKTRACK_LIMIT_ERROR`) informacije, so nedvomno v redu. Nasprotno pa konstante, ki sluÅ¾ijo kot naÄin, kako *brezÅ¾iÄno* posredovati informacijo znotraj kode, niso niÄ drugega kot skrita odvisnost. Kot na primer `LOG_FILE` v naslednjem primeru. Uporaba konstante `FILE_APPEND` je popolnoma pravilna.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

V tem primeru bi morali deklarirati parameter v konstruktorju razreda `Foo`, da postane del API-ja:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Zdaj lahko posredujemo informacijo o poti do datoteke za beleÅ¾enje in jo enostavno spreminjamo po potrebi, kar olajÅ¡a testiranje in vzdrÅ¾evanje kode.


Globalne funkcije in statiÄne metode
------------------------------------

Å½elimo poudariti, da sama uporaba statiÄnih metod in globalnih funkcij ni problematiÄna. RazloÅ¾ili smo, v Äem je neprimernost uporabe `DB::insert()` in podobnih metod, vendar je vedno Å¡lo le za zadevo globalnega stanja, ki je shranjeno v neki statiÄni spremenljivki. Metoda `DB::insert()` zahteva obstoj statiÄne spremenljivke, ker je v njej shranjena povezava z bazo podatkov. Brez te spremenljivke bi bilo nemogoÄe metodo implementirati.

Uporaba deterministiÄnih statiÄnih metod in funkcij, kot na primer `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` in mnogih drugih, je v popolnem skladu z dependency injection. Te funkcije vedno vraÄajo enake rezultate iz enakih vhodnih parametrov in so torej predvidljive. Ne uporabljajo nobenega globalnega stanja.

Obstajajo pa tudi funkcije v PHP, ki niso deterministiÄne. K njim spada na primer funkcija `htmlspecialchars()`. Njen tretji parameter `$encoding`, Äe ni naveden, ima kot privzeto vrednost vrednost konfiguracijske moÅ¾nosti `ini_get('default_charset')`. Zato se priporoÄa ta parameter vedno navesti in prepreÄiti morebitno nepredvidljivo obnaÅ¡anje funkcije. Nette to dosledno poÄne.

Nekatere funkcije, kot na primer `strtolower()`, `strtoupper()` in podobne, so se v nedavni preteklosti nedeterministiÄno obnaÅ¡ale in bile odvisne od nastavitve `setlocale()`. To je povzroÄalo veliko zapletov, najpogosteje pri delu s turÅ¡kim jezikom. Ta namreÄ razlikuje malo in veliko Ärko `I` s piko in brez pike. Tako je `strtolower('I')` vraÄalo znak `Ä±` in `strtoupper('i')` znak `Ä°`, kar je vodilo k temu, da so aplikacije zaÄele povzroÄati vrsto skrivnostnih napak. Ta teÅ¾ava pa je bila odpravljena v PHP razliÄici 8.2 in funkcije niso veÄ odvisne od locale.

Gre za lep primer, kako je globalno stanje muÄilo na tisoÄe razvijalcev po vsem svetu. ReÅ¡itev je bila zamenjava z dependency injection.


Kdaj je mogoÄe uporabiti globalno stanje?
-----------------------------------------

Obstajajo doloÄene specifiÄne situacije, ko je mogoÄe izkoristiti globalno stanje. Na primer pri razhroÅ¡Äevanju kode, ko morate izpisati vrednost spremenljivke ali izmeriti trajanje doloÄenega dela programa. V takih primerih, ki se nanaÅ¡ajo na zaÄasna dejanja, ki bodo kasneje odstranjena iz kode, je mogoÄe legitimno izkoristiti globalno dostopen dumper ali Å¡toparico. Ti orodji namreÄ niso del naÄrtovanja kode.

Drug primer so funkcije za delo z regularnimi izrazi `preg_*`, ki interno shranjujejo prevedene regularne izraze v statiÄni predpomnilnik v pomnilniku. Ko torej kliÄete isti regularni izraz veÄkrat na razliÄnih mestih kode, se prevede samo enkrat. Predpomnilnik varÄuje z zmogljivostjo in hkrati je za uporabnika popolnoma neviden, zato lahko tako uporabo Å¡tejemo za legitimno.


Povzetek
--------

Pregledali smo, zakaj ima smisel:

1) Odstraniti vse statiÄne spremenljivke iz kode
2) Deklarirati odvisnosti
3) In uporabljati dependency injection

Ko razmiÅ¡ljate o naÄrtovanju kode, mislite na to, da vsak `static $foo` predstavlja teÅ¾avo. Da bi vaÅ¡a koda bila okolje, ki spoÅ¡tuje DI, je nujno popolnoma izkoreniniti globalno stanje in ga nadomestiti z dependency injection.

Med tem procesom morda ugotovite, da je treba razred razdeliti, ker ima veÄ kot eno odgovornost. Ne bojte se tega; prizadevajte si za naÄelo ene same odgovornosti.

*Rad bi se zahvalil MiÅ¡ku Heveryju, Äigar Älanki, kot je [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/], so osnova tega poglavja.*
