Tokenizer: Токенізація рядків
*****************************

.[perex]
Tokenizer - це простий інструмент, який використовує регулярні вирази для розбиття заданого рядка на лексеми. Для чого це потрібно, запитаєте ви? Ну, ви можете створювати свої власні мови.

*(Для більш досвідчених програмістів)*.

Встановлення:

```shell
composer require nette/tokenizer
```


Токенізація рядків .[#toc-string-tokenization]
----------------------------------------------

Давайте створимо простий токенізатор, який розділяє рядки на числа, пропуски і букви.

```php
$tokenizer = new Nette\Tokenizer\Tokenizer([
	T_DNUMBER => '\d+',
	T_WHITESPACE => '\s+',
	T_STRING => '\w+',
]);
```

Підказка: Якщо вам цікаво, звідки взялися константи T_, то це "внутрішній тип":https://www.php.net/manual/tokens.php, який використовується для розбору коду. Вони охоплюють більшість поширених імен токенів, які нам зазвичай потрібні. Пам'ятайте, що їхнє значення не гарантоване, тому не використовуйте цифри для порівняння.

Тепер, коли ми передамо йому рядок, він поверне [потік |api:Nette\Tokenizer\Stream] із [маркерів |api:Nette\Tokenizer\Token].

```php
$stream = $tokenizer->tokenize("say \n123");
```

Результуючий масив лексем `$stream->tokens` матиме такий вигляд:

```php
[
	new Token('say', T_STRING, 0),
	new Token(" \n", T_WHITESPACE, 3),
	new Token('123', T_DNUMBER, 5),
]
```

Також ви можете отримати доступ до окремих властивостей токена:

```php
$firstToken = $stream->tokens[0];
$firstToken->value; // значение
$firstToken->type; // значение T_STRING
$firstToken->offset; // позиция в строке: 0
```

Просто, чи не так?


Обробка токенів .[#toc-processing-the-tokens]
---------------------------------------------

Тепер ми знаємо, як створювати токени з рядка. Давайте ефективно опрацюємо їх, використовуючи [потік |api:Nette\Tokenizer\Stream]. У ньому є безліч дійсно приголомшливих методів, якщо вам потрібно переміщати токени!

Давайте спробуємо розібрати просту анотацію з PHPDoc і створити з неї об'єкт. Які регулярні вирази нам потрібні для лексем? Усі анотації починаються з `@`, потім йде ім'я, пробіли і значення.

- `@` для початку анотації
- `\s+` для пробілів
- `\w+` для рядків

.[note]
Ніколи не використовуйте захоплюючі підшаблони в регулярних виразах Tokenizer, наприклад `'(ab)+c'`, використовуйте тільки не захоплюючі `'(?:ab)+c'`.

Це повинно працювати з простими анотаціями, вірно? Тепер покажемо вхідний рядок, який ми спробуємо розібрати.

```php
$input = '
	@author David Grudl
	@package Nette
';
```

Давайте створимо клас `Parser`, який прийматиме рядок і повертатиме масив пар '['ім'я, значення |имя, значение]''. Це буде дуже просто.

```php
use Nette\Tokenizer\Tokenizer;
use Nette\Tokenizer\Stream;

class Parser
{
	const T_AT = 1;
	const T_WHITESPACE = 2;
	const T_STRING = 3;

	private Tokenizer $tokenizer;
	private Stream $stream;

	public function __construct()
	{
		$this->tokenizer = new Tokenizer([
			self::T_AT => '@',
			self::T_WHITESPACE => '\s+',
			self::T_STRING => '\w+',
		]);
	}

	public function parse(string $input): array
	{
		$this->stream = $this->tokenizer->tokenize($input);

		$result = [];
		while ($this->stream->nextToken()) {
			if ($this->stream->isCurrent(self::T_AT)) {
				$result[] = $this->parseAnnotation();
			}
		}

		return $result;
	}

	private function parseAnnotation(): array
	{
		$name = $this->stream->joinUntil(self::T_WHITESPACE);
		$this->stream->nextUntil(self::T_STRING);
		$content = $this->stream->joinUntil(self::T_AT);

		return [$name, trim($content)];
	}
}
```

```php
$parser = new Parser;
$annotations = $parser->parse($input);
```

Отже, що ж робить метод `parse()`? Він перебирає лексеми і шукає символ `@`, с которого начинаются аннотации. Вызов `nextToken()` переміщує курсор на наступний токен. Метод `isCurrent()` перевіряє, чи є поточний токен у курсорі заданим типом. Потім, якщо `@` найден, метод `parse()` викликає `parseAnnotation()`, який очікує, що анотації будуть у дуже специфічному форматі.

Спочатку, використовуючи метод `joinUntil()`, потік продовжує переміщати курсор і додавати значення лексем до буфера, доки не знайде лексему потрібного типу, потім зупиняється і повертає виведення буфера. Оскільки в даній позиції знаходиться тільки одна лексема типу `T_STRING` і це `'name'`, у змінній `$name` буде значення `'name'`.

Метод `nextUntil()` схожий на `joinUntil()`, але в нього немає буфера. Він переміщує курсор тільки доти, доки не знайде маркер. Тому цей виклик просто пропускає всі пробіли після імені анотації.

І потім, є ще один `joinUntil()`, який шукає наступний `@`. Этот конкретный вызов вернет ``David Grudl\n``` David Grudl\n``.

І ось, ми розібрали цілу анотацію! Ймовірно, `$content` закінчується пробілами, тому ми повинні обрізати його. Тепер ми можемо повернути цю конкретну анотацію у вигляді пари `[$name, $content]`.

Спробуйте скопіювати код і запустити його. Якщо ви скинете змінну `$annotations`, вона повинна видати схожий результат.

```
array (2)
   0 => array (2)
   |  0 => 'author'
   |  1 => 'David Grudl'
   1 => array (2)
   |  0 => 'package'
   |  1 => 'Nette'
```


Потокові методи .[#toc-stream-methods]
--------------------------------------

Потік може повернути поточний токен за допомогою методу `currentToken()` або тільки його значення за допомогою `currentValue()`.

`nextToken()` переміщує курсор і повертає токен. Якщо ви не даєте йому жодних аргументів, він просто повертає наступний токен.

`nextValue()` подібно до `nextToken()`, але повертає тільки значення токена.

Більшість методів також приймають кілька аргументів, тому ви можете шукати кілька типів одночасно.

```php
// итерация до тех пор, пока не будет найдена строка или пробел, затем возвращает следующий токен
$token = $stream->nextToken(T_STRING, T_WHITESPACE);

// получить следующий токен
$token = $stream->nextToken();
```

Можна також виконувати пошук за значенням токена.

```php
// перемещайте курсор, пока не найдете лексему, содержащую только '@', затем остановитесь и верните её обратно
$token = $stream->nextToken('@');
```

`nextUntil()` переміщує курсор і повертає масив усіх зустрінутих токенів, поки не знайде потрібну лексему, але зупиняється перед нею. Він може приймати кілька аргументів.

`joinUntil()` аналогічний `nextUntil()`, але конкатенує всі пройдені токени і повертає рядок.

`joinAll()` просто конкатенує всі значення маркерів, що залишилися, і повертає їх. Він переміщує курсор у кінець потоку токенів

`nextAll()` як і `joinAll()`, але повертає масив токенів.

`isCurrent()` перевіряє, чи дорівнює поточний токен або значення поточного токена одному із заданих аргументів.

```php
// является ли текущий поток токеном '@' или типом T_AT?
$stream->isCurrent(T_AT, '@');
```

`isNext()` як і `isCurrent()`, але перевіряє наступний токен.

`isPrev()` подібно до `isCurrent()`, але перевіряє попередній токен.

І останній метод `reset()` скидає курсор, щоб ви могли знову ітерувати потік токенів.


{{leftbar: utils:@left-menu}}
