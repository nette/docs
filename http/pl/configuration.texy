Konfiguracja HTTP
*****************

.[perex]
Przegląd opcji konfiguracyjnych dla Nette HTTP.

Jeśli nie używasz całego frameworka, a jedynie tej biblioteki, przeczytaj [jak załadować konfigurację |bootstrap:].


Nagłówki HTTP .[#toc-http-hlavicky]
===================================

```neon
http:
	# hlavičky, které se s každým požadavkem odešlou
	headers:
		X-Powered-By: MyCMS
		X-Content-Type-Options: nosniff
		X-XSS-Protection: '1; mode=block'

	# ovlivňuje hlavičku X-Frame-Options
	frames: ...      # (string|bool) výchozí je 'SAMEORIGIN'
```

Ze względów bezpieczeństwa framework wysyła nagłówek `X-Frame-Options: SAMEORIGIN`, który mówi, że strona może być wyświetlana wewnątrz innej strony (w elemencie `<iframe>`) tylko wtedy, gdy znajduje się w tej samej domenie. Może to być niepożądane w niektórych sytuacjach (na przykład, jeśli tworzysz aplikację dla Facebooka), więc możesz zmienić zachowanie, ustawiając `frames: http://allowed-host.com`.


Polityka bezpieczeństwa treści .[#toc-content-security-policy]
--------------------------------------------------------------

Łatwo jest zbudować nagłówki `Content-Security-Policy` (dalej CSP), zobacz opis [CSP |https://content-security-policy.com] dla opisu. Dyrektywy CSP (takie jak `script-src`) mogą być zapisane jako łańcuchy zgodnie ze specyfikacją lub jako tablica wartości dla lepszej czytelności. Wtedy nie ma potrzeby pisania cudzysłowów wokół słów kluczowych, takich jak na przykład `'self'`,. Nette automatycznie wygeneruje również wartość `nonce`, więc w nagłówku będzie napisane `'nonce-y4PopTLM=='`.

```neon
http:
	# Content Security Policy
	csp:
		# řetězec ve tvaru dle specifikace CSP
		default-src: "'self' https://example.com"

		# pole hodnot
		script-src:
			- nonce
			- strict-dynamic
			- self
			- https://example.com

		# bool v případě přepínačů
		upgrade-insecure-requests: true
		block-all-mixed-content: false
```

W szablonach należy używać `<script n:nonce>...</script>` a wartość nonce zostanie dodana automatycznie. Tworzenie bezpiecznych stron w Nette jest naprawdę proste.

Podobnie można zbudować nagłówki `Content-Security-Policy-Report-Only` (które mogą być używane równolegle z CSP) i [Feature Policy |https://developers.google.com/web/updates/2018/06/feature-policy]:

```neon
http:
	# Content Security Policy Report-Only
	cspReportOnly:
		default-src: self
		report-uri: 'https://my-report-uri-endpoint'

	# Feature Policy
	featurePolicy:
		unsized-media: none
		geolocation:
			- self
			- https://example.com
```


Ciasteczko HTTP .[#toc-http-cookie]
-----------------------------------

Możesz zmienić domyślne wartości niektórych parametrów metod [NetteCookie::setCookie() |response#setCookie] i session.

```neon
http:
	# dosah cookie podle cesty
	cookiePath: ...        # (string) výchozí je '/'

	# domény, které přijímají cookie
	cookieDomain: 'example.com'  # (string|domain) výchozí je nenastaveno

	# posílat cookie pouze přes HTTPS?
	cookieSecure: ...      # (bool|auto) výchozí je auto

	# vypne posílání cookie, kterou používá Nette jako ochranu před CSRF
	disableNetteCookie: ...  # (bool) výchozí je false
```

Atrybut `cookieDomain` określa, które domeny mogą akceptować pliki cookie. Jeśli nie jest określone, plik cookie jest akceptowany przez tę samą (pod)domenę, która go ustawiła, *ale nie* jej subdomeny. Jeśli określono `cookieDomain`, uwzględniane są subdomeny. Dlatego określenie `cookieDomain` jest mniej restrykcyjne niż pominięcie go.

Na przykład, w przypadku `cookieDomain: nette.org`, pliki cookie są również dostępne na wszystkich subdomenach jako `doc.nette.org`. To samo można również osiągnąć za pomocą wartości specjalnej `domain`, czyli `cookieDomain: domain`.

Domyślna wartość `auto` dla atrybutu `cookieSecure` oznacza, że jeśli strona działa na HTTPS, pliki cookie będą wysyłane z flagą `Secure`, a więc będą dostępne tylko przez HTTPS.


Proxy HTTP .[#toc-http-proxy]
-----------------------------

Jeśli witryna działa za proxy HTTP, wpisz jego adres IP, aby wykrywanie połączenia HTTPS działało poprawnie, a także adres IP klienta. Oznacza to, że funkcje [Nette:getRemoteAddress() |request#getRemoteAddress] i [isSecured() |request#isSecured] zwracają poprawne wartości i generują w szablonach linki z protokołem `https:`.

```neon
http:
	# IP adresa, rozsah (např. 127.0.0.1/8) nebo pole těchto hodnot
	proxy: 127.0.0.1       # (string|string[]) výchozí je nenastaveno
```


Sesja .[#toc-session]
=====================

Podstawowe ustawienia [sesji |sessions]:

```neon
session:
	# zobrazit session panel v Tracy Bar?
	debugger: ...        # (bool) výchozí je false

	# doba neaktivity po které session vyexpiruje
	expiration: 14 days  # (string) výchozí je '3 hours'

	# kdy se má startovat session?
	autoStart: ...       # (smart|always|never) výchozí je 'smart'

	# handler, služba implementující rozhraní SessionHandlerInterface
	handler: @handlerService
```

Opcja `autoStart` kontroluje, kiedy rozpocząć sesję. Wartość `always` oznacza, że sesja będzie zawsze uruchamiana w momencie startu aplikacji. Wartość `smart` oznacza, że sesja będzie uruchamiana tylko w momencie startu aplikacji, jeśli już istnieje, lub gdy będziemy chcieli z niej czytać lub do niej pisać. Wreszcie, wartość `never` wyłącza automatyczne rozpoczynanie sesji.

Możesz również ustawić wszystkie [dyrektywy sesji |https://www.php.net/manual/en/session.configuration.php] PHP (w formacie camelCase), a także [readAndClose |https://www.php.net/manual/en/function.session-start.php#refsect1-function.session-start-parameters]. Przykład:

```neon
session:
	# 'session.name' zapíšeme jako 'name'
	name: MYID

	# 'session.save_path' zapíšeme jako 'savePath'
	savePath: "%tempDir%/sessions"
```


Plik cookie sesji .[#toc-session-cookie]
----------------------------------------

Sesyjny plik cookie jest wysyłany z takimi samymi parametrami jak [inne |#HTTP cookie] pliki cookie, ale możesz je dla niego zmienić:

```neon
session:
	# domény, které přijímají cookie
	cookieDomain: 'example.com'   # (string|domain)

	# omezení při přístupu z jiné domény
	cookieSamesite: None          # (Strict|Lax|None) výchozí je Lax
```

Atrybut `cookieSamesite` wpływa na to, czy plik cookie jest wysyłany przy [dostępie z innej domeny |nette:glossary#SameSite cookie], co zapewnia pewną ochronę przed atakami [Cross-Site Request Forgery |nette:glossary#cross-site-request-forgery-csrf] (CSRF).
