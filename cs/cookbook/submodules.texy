Vnořené moduly
**************

Může se stát, že jedna aplikace obsahuje vlastně dvě. Například píšete-li API. Pak se hodí používat jednu sadu presenterů na aplikaci (např. `https://example.com/calendar`) a jiný set presenterů na API (např. `https://example.com/api/calendar`). Aplikace vrací HTML stránku s aplikací, naproti tomu API vrátí JSON. Ale aplikaci již máte interně rozdělenou na moduly - zde se například jedná o modul calendar.

K tomu můžete využít [vícenásobně zanořené moduly|/configuring#toc-mapovani].

Vytvoříte si presentery:
1. App\Calendar\Presenter\DefaultPresenter
2. App\Api\Calendar\Presenter\DefaultPresenter

Složková struktura pak může vypadat například takto:
```
app
└modules
 └calendar
  └presenter
   ├api
   │└DefaultPresenter
   └app
    └DefaultPresenter
```

Nastavíte si routy:
```php
$router = new RouteList;

//routa pro veškeré requesty, začínající na https://example.com/api
$router->withPath('api')->addRoute('<module>[/<presenter>][/<action>]', [
	'module' => [
		Route::FILTER_IN => function ($module) {
			return 'Api:' . ucfirst($module);
		},
		Route::FILTER_OUT => function ($module) {
			list(, $module) = explode(':', $module);
			return strtolower($module);
		},
	],
	'presenter' => 'Default',
	'action' => 'default',
]);

//routa pro veškeré ostatní requesty
$router->addRoute('<module>[/<presenter>][/<action>]');
```

Nastavíme si dva mappingy:
```neon
application:
  mapping:
    *: App\*\Presenter\*Presenter
    Api: App\Api\*\Presenter\*Presenter
```

Navštíví-li uživatel stránku `https://example.com/api/calendar` - spustí se mu presenter třídy `App\Api\Calendar\Presenter\DefaultPresenter`. Navštíví-li ovšem stránku `https://example.com/calendar`, spustí se mu presenter třídy `App\Calendar\Presenter\DefaultPresenter`.

Nette při skládání názvu presenteru matchne první routu. Z regulérního výrazu zjistí že se nám jedná o modul calendar, ten ale ve filtrovacím pravidle doplní na `Api:calendar`. V případě že modul obsahuje dvojtečky, tak Nette string dle dvojteček rozdělí do pole a klíč mappingu hledá podle první položky pole - v našem případě tedy část Api. Část calendar již pak standardně nahradí za hvězdičku v mappingu, tedy výsledek je
`Api: App\Api\Calendar\Presenter\*Presenter`
Presenter je Default, tedy výsledná třída se poskládá do `App\Api\Calendar\Presenter\DefaultPresenter`.

Máte složitější aplikaci a potřebujete detailnější členění modulů? Filtrovací funkce může být složitější. Napište si funkci, která Vám např. modul calendar změní na `Api:Main:calendar`. Mapping se nadále matchuje podle klíče Api. Za modul ovšem Nette dosadí kombinaci `Main:calendar`, ale namísto dvojtečky ji oddělí zpětným lomítkem, tedy výsledná třída bude `App\Api\Main\Calendar\Presenter\DefaultPresenter`.
