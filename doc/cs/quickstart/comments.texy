Komentáře
*********

Nahráli jsme blog na webserver, publikovali několik velmi zajímavých příspěvků pomocí Admineru. Lidé čtou náš blog a jsou z něho velmi nadšení. Dostáváme každý den mnoho emailů s pochvalami, ale k čemu je všechna tato chvála, pokud ji máme pouze v emailu a nikdo si ji nemůže přečíst? Bylo by lepší, kdyby mohl čtenář článek přímo komentovat, takže by si mohl každý přečíst, jak jsme úžasní.

Pojďme tedy naprogramovat komentáře.


Tvorba nové tabulky
====================

Nažhavíme Adminer a vytvoříme tabulku `comments` s těmito sloupci:

- `id` int, zaškrtneme autoincrement (AI)
- `post_id`, cizí klíč, který odkazuje na tabulku `posts`
- `name` varchar, length 255
- `email` varchar, length 255
- `content` text
- `created_at` timestamp

Tabulka by tedy měla vypadat nějak takto:

[* adminer-comments.png *]

Nezapomeňte opět použít úložiště InnoDB.


Formulář pro komentování
===================

Prvně musíme vytvořit formulář, který umožní uživatelům příspěvky komentovat. Nette Framework má úžasnou podporu pro formuláře. Můžeme je nakonfigurovat v presenteru a vykreslit v šabloně.

Nette Framework využívá koncept *komponent*. **Komponenta** je znovupoužitelná třída, nebo část kódu, který může být přiložen k jiné komponentě. Dokonce i presenter je komponenta. Každá komponenta je vytvořena prostřednictvím továrničky. Vytvoříme si tedy továrničku pro formulář na komentáře v presenteru `PostPresenter`.

/--php
	protected function createComponentCommentForm()
	{
		$form = new Nette\Application\UI\Form;

		$form->addText('name', 'Jméno:')
			->setRequired();

		$form->addText('email', 'Email:');

		$form->addTextArea('content', 'Komentář:')
			->setRequired();

		$form->addSubmit('send', 'Publikovat komentář');

		return $form;
	}
\--

Pojďme si to zase trochu vysvětlit. První řádka vytvoří novou instanci komponenty `Form`.
Následující metody připojují HTML inputy do definice tohoto formuláře.
`->addText` se vykreslí jako `<input type=text name=name>` s `<label>Jméno:</label>`. Jak již zřejmě správně odhadujete, tak `->addTextArea` se vykreslí jako `<textarea>` a `->addSubmit` jako `<input type=submit>`.
Existuje daleko více obdobných metod, ale tyto zatím pro tento formulář stačí. Více se [dočtete v dokumentaci|/forms].

Pokud je již formulář definován v presenteru, můžeme ho vykreslit (zobrazit) v šabloně. To uděláme umístěním makra `{control}` na konec šablony, která vykresluje jeden konkrétní příspěvek, do `app/templates/Post/show.latte`. Protože se komponenta jmenuje `commentForm` (název je odvozen od názvu metody `createComponentCommentForm`), makro bude vypadat takto:

/--html
<h2>Vložte nový příspěvek</h2>

{control commentForm}
\--

Když si nyní zobrazíte stránku s detailem příspěvku, na jeho konci uvidíte nový formulář pro komentáře.


Ukládání do databáze
==================

Už jste zkoušeli formulář vyplnit a odeslat? Asi jste si všimli, že ten formulář vlastně nic nedělá. Musíme připojit callback metodu, která uloží odeslaná data.

Na řádek před `return` v továrničce pro komponentu `commentForm` umístíme následující řádek:

/--php
$form->onSuccess[] = $this->commentFormSucceeded; // bez závorek
\--

Předchozí zápis znamená "po úspěšném odeslání formuláře zavolej metodu `commentFormSucceeded` ze současného presenteru". Zápis `$this->commentFormSucceeded` je jeden ze *syntaktických cukříků*, které poskytuje [Nette\Object|/php-language-enhancements]. Chová se to jako callback metoda. Tato metoda však ještě neexistuje, pojďme ji tedy vytvořit.

/--php
	public function commentFormSucceeded($form)
	{
		$values = $form->getValues();
		$postId = $this->getParameter('postId');

		$this->database->table('comments')->insert(array(
			'post_id' => $postId,
			'name' => $values->name,
			'email' => $values->email,
			'content' => $values->content,
		));

		$this->flashMessage('Děkuji za komentář', 'success');
		$this->redirect('this');
	}
\--

Tuto metodu umístíme přímo za továrničku formuláře `commentForm`.

Tato nová metoda má jeden argument, což je instance formuláře, který byl odeslán - vytvořen továrničkou. Zeptáme se instance formuláře na odeslané hodnoty voláním `$form->getValues()`. A následně uložíme data do databázové tabulky `comments`.

Ještě jsou zde další dvě metody, které si zaslouží vysvětlit. Redirect metoda doslova přesměrovává zpět na aktuální stránku. Toto je vhodné udělat po každém odeslání formuláře, pokud obsahoval validní data a callback provedl operaci tak jak měl. A taky pokud přesměrujeme stránku po odeslání formuláře, neuvidíme dobře známou hlášku `Chcete odeslat data z formuláře znovu?`, kterou občas můžeme v prohlížeči spatřit. (Obecně platí, že po odeslání formuláře metodou `POST` by mělo následovat vždy přesměrování na `GET` akci.)

Metoda `flashMessage` je pro informování uživatele o výsledku nějaké operace. Protože přesměrováváme, zpráva nemůže být jednoduše předána šabloně a vykreslena. Proto je zde tato metoda, která si tuto zprávu uloží a zpřístupní ji při dalším načtení stránky. Flash zprávy jsou vykreslovány v hlavní šabloně `app/templates/@layout.latte` a vypadá to takto:

/--html
<div n:foreach="$flashes as $flash" class="flash {$flash->type}">{$flash->message}</div>
\--

Jak již víme, tak flash zprávy jsou automaticky předávány do šablony, takže o tom nemusíme moc přemýšlet, zkrátka to funguje. Pro více informací [navštivte dokumentaci |/presenters#toc-flash-messages].


Vykreslování komentářů
======================

Toto je jedna z těch věcí, které si prostě zamilujete. Nette\Database má skvělou funkci nazvanou *Selection API*. Pamatujete si ještě, že tabulky v databázi jsme schválně vytvářeli pomocí InnoDB úložiště? Adminer tak vytvořil něco, čemu se říká [cizí klíče |http://dev.mysql.com/doc/refman/5.5/en/innodb-foreign-key-constraints.html], které nám ušetří spoustu práce.

Nette\Database používá cizí klíče pro vyřešení vzájemného vztahu mezi tabulkami a ze znalostí těchto vztahů umí automaticky vytvořit databázové dotazy.

Jak si jistě pamatujete, do šablony jsme předali proměnnou `$post` pomocí metody `PostPresenter::renderShow()` a nyní chceme iterovat přes všechny komentáře, které mají hodnotu sloupce `post_id` shodnou s `$post->id`. Toho můžeme docílit voláním `$post->related('comments')`. Ano, takhle jednoduše. Podívejme se na výsledný kód:

/--php
	public function renderShow($postId)
	{
		...
		$this->template->post = $post;
		$this->template->comments = $post->related('comment')->order('created_at');
	}
\--

A šablonu:

/--html
<h2>Komentáře</h2>

<div class="comments">
	{foreach $comments as $comment}
		<p><b><a href="mailto:{$comment->email}" n:tag-if="$comment->email">{$comment->name}</a></b> said:</p>
		<div>{$comment->content}</div>
	{/foreach}
</div>

\--

Všimněte si speciálního makra `n:tag-if`. Již víte jak `n:makra` fungují. Pokud k atributu připojíte předponu `tag-`, makro se aplikuje pouze na HTML tag, ne na jeho obsah. Toto nám umožňuje udělat ze jména komentátora odkaz pouze v případě, že poskytl svůj email. Tyto dvě řádky jsou identické:

/--html
<strong n:tag-if="$important"> Dobrý den! </strong>
{if $important}<strong>{/if} Dobrý den! {if $important}</strong>{/if}
\--

{{care: Filip Procházka|2117}}
{{care: Honza Doleček|3537}}
