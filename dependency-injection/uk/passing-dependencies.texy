Передача залежностей
********************

<div class=perex>

Аргументи, або "залежності" в термінології DI, можуть бути передані класам такими основними способами:

* передача за допомогою конструктора
* передача методом (називається setter)
* шляхом встановлення властивості
* методом, анотацією або атрибутом *inject*

</div>

Перші три методи застосовні взагалі у всіх об'єктно-орієнтованих мовах, четвертий специфічний для презентаторів Nette, тому його обговорюють в [окремому розділі |best-practices:inject-method-attribute]. Зараз ми докладніше розглянемо кожен із цих варіантів і покажемо їх на конкретних прикладах.


Впровадження через конструктор .[#toc-constructor-injection]
============================================================

Залежності передаються як аргументи конструктору під час створення об'єкта:

```php
class MyClass
{
	private Cache $cache;

	public function __construct(Cache $cache)
	{
		$this->cache = $cache;
	}
}

$obj = new MyClass($cache);
```

Ця форма корисна для обов'язкових залежностей, які абсолютно необхідні класу для функціонування, оскільки без них екземпляр не може бути створений.

Починаючи з версії PHP 8.0, ми можемо використовувати коротшу форму позначення ([constructor property promotion |https://blog.nette.org/uk/php-8-0-povnij-oglyad-novin#toc-constructor-property-promotion]), яка функціонально еквівалентна:

```php
// PHP 8.0
class MyClass
{
	public function __construct(
		private Cache $cache,
	) {
	}
}
```

Починаючи з версії PHP 8.1, властивість може бути позначена прапором `readonly`, який оголошує, що вміст властивості не буде змінюватися:

```php
// PHP 8.1
class MyClass
{
	public function __construct(
		private readonly Cache $cache,
	) {
	}
}
```

DI контейнер передає залежності в конструктор автоматично, використовуючи [autowiring |autowiring]. Аргументи, які не можна передавати таким чином (наприклад, рядки, числа, булеви) [записати в конфігурації |services#Arguments].


Впровадження через сеттери .[#toc-setter-injection]
===================================================

Залежності передаються шляхом виклику методу, який зберігає їх у приватній властивості. Звичайна угода про іменування цих методів має вигляд `set*()`, тому вони називаються сетерами.

```php
class MyClass
{
	private Cache $cache;

	public function setCache(Cache $cache): void
	{
		$this->cache = $cache;
	}
}

$obj = new MyClass;
$obj->setCache($cache);
```

Цей метод корисний для необов'язкових залежностей, які не потрібні для функціонування класу, оскільки не гарантується, що об'єкт дійсно отримає їх (тобто що користувач викличе метод).

Водночас, цей метод дозволяє неодноразово викликати сеттер для зміни залежності. Якщо це небажано, додайте перевірку в метод, або, починаючи з PHP 8.1, позначте властивість `$cache` прапором `readonly`.

```php
class MyClass
{
	private Cache $cache;

	public function setCache(Cache $cache): void
	{
		if ($this->cache) {
			throw new RuntimeException('The dependency has already been set');
		}
		$this->cache = $cache;
	}
}
```

Виклик сеттера визначається в конфігурації контейнера DI в [розділі setup |services#Setup]. Також тут автоматична передача залежностей використовується autowiring:

```neon
services:
	-
		create: MyClass
		setup:
			- setCache
```


Впровадження через властивості .[#toc-property-injection]
=========================================================

Залежності передаються безпосередньо у властивість:

```php
class MyClass
{
	public Cache $cache;
}

$obj = new MyClass;
$obj->cache = $cache;
```

Цей метод вважається неприйнятним, оскільки властивість має бути оголошена як `public`. Отже, ми не можемо контролювати, чи буде передана залежність справді мати вказаний тип (це було вірно до версії PHP 7.4), і ми втрачаємо можливість реагувати на нову призначену залежність своїм власним кодом, наприклад, щоб запобігти подальшим змінам. Водночас, властивість стає частиною публічного інтерфейсу класу, що може бути небажано.

Налаштування змінної визначається в конфігурації контейнера DI в розділі [section setup |services#Setup]:

```neon
services:
	-
		create: MyClass
		setup:
			- $cache = @\Cache
```


Який шлях обрати? .[#toc-which-way-to-choose]
=============================================

- конструктор підходить для обов'язкових залежностей, які необхідні класу для функціонування
- сеттер, з іншого боку, підходить для необов'язкових залежностей, або залежностей, які можуть бути змінені
- публічні змінні не рекомендуються
