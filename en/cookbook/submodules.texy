Submodules
**********

Sometimes, you create an application, consisting of two applications internally. For isntance, lets say your application contains API. Then it could get useful to use one set of presenters for an actual application requests (e.g. `https://example.com/calendar`) and other set of presenters for API requests (e.g. `https://example.com/api/calendar`). Application responds HTML page with the app contents, on the other hand, API responds with JSON data. But your application is internally separated to modules - here in this example, we are dealing with module calendar.

To do that, you can use [submodules|/configuring#toc-mapping].

Create these presenters:
1. App\Calendar\Presenter\DefaultPresenter
2. App\Api\Calendar\Presenter\DefaultPresenter

Folder structure can look like that:
```
app
└modules
 └calendar
  └presenter
   ├api
   │└DefaultPresenter
   └app
    └DefaultPresenter
```

Setup routes:
```php
$router = new RouteList;

//route all requests, beginning with https://example.com/api
$router->withPath('api')->addRoute('<module>[/<presenter>][/<action>]', [
	'module' => [
		Route::FILTER_IN => function ($module) {
			return 'Api:' . ucfirst($module);
		},
		Route::FILTER_OUT => function ($module) {
			list(, $module) = explode(':', $module);
			return strtolower($module);
		},
	],
	'presenter' => 'Default',
	'action' => 'default',
]);

//route all the other requests
$router->addRoute('<module>[/<presenter>][/<action>]');
```

Configure two mappings:
```neon
application:
  mapping:
    *: App\*\Presenter\*Presenter
    Api: App\Api\*\Presenter\*Presenter
```

Whenever user visits page `https://example.com/api/calendar` - this request gets handled by presenter of classname `App\Api\Calendar\Presenter\DefaultPresenter`. If he visits  https://example.com/calendar, that triggers presenter of classname `App\Calendar\Presenter\DefaultPresenter`.

During the presenter classname generation, Nette matches the first route. From the supplied regex detects, that user is requesting module calendar, but in the filtering rule it extends it to `Api:calendar`. Whenever module contains colon, Nette splits the module string with colon as separator into an array and looks for correct mapping rule, using the first item in the array - in our case it searches for mapping named Api. Second part - calendar - is the normally used to substitute star in mapping. Therefore, matching is
`Api: App\Api\Calendar\Presenter\*Presenter`
Presenter is Default, so resulting classname is `App\Api\Calendar\Presenter\DefaultPresenter`.

Is your application more complex and are you in need of more detailed breakdown of module? You can make your router filtering function as complex as you want. For example, resulting module can change to `Api:Main:calendar`. Module is still exploded by colons and mapping key is still matched using first item - Api. However, the rest of items (Main, Calendar) will join using backslash and will then be used to substitute mapping star. As a result, the classname will be `App\Api\Main\Calendar\Presenter\DefaultPresenter`.
