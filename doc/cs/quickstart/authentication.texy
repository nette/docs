Autentifikace
**************

Nette poskytuje způsob jak naprogramovat autentifikaci na vašich stránkách, ale do ničeho vás nenutí. Implementace je pouze an vás. Nette má interface `Nette\Security\IAuthenticator`, který vyžaduje implementovat pouze jednu metodu nazvanou `authenticate`, která libovolně ověřuje pravost uživatele.

Existuje mnoho možností jak může být uživatel ověřen. Nejčastější způsob je ověření podle hesla (uživatel poskytne své jméno, nebo email a heslo), ale jsou zde i jiné způsoby. Možná znáte tlačítka typu "Přihlásit pomocí Facebooku", nebo přihlášení pomocí Google/Twitter/GitHub na některých stránkách. S Nette můžete mít jakoukoliv metodu ověření jenom chcete. Nebo je můžete kombinovat. Je to jen na vás.

Za normálních okolností si zřejmě napíšete vlastní authenticator, ale pro tento jednoduchý malý blog použijeme `SimpleAuthenticator`, který je v Nette již připraven. Poskytuje přihlášení na základě hesla a uživatelského jména, které je uloženo v konfiguračním souboru. Přidejte tedy *security* sekci do souboru `config.neon` (a nezapomeňte změnit heslo):


/--neon
        nette:
                security:
                        users:
                                admin: secret  # user 'admin', password 'secret'
\--


Nette automaticky vytvoří službu s názvem `authenticator` v DI kontejneru.

.[note]
Více si můžete přečíst o [Dependency Injection zde |en/dependency-injection] a o [konfiguraci zde |en/configuring]


Přihlašovací formulář
===

Nyní máme autentifikaci připravenu a musíme připravit uživatelské rozhraní pro přihlášení. Vytvořme tedy nový presenter s názvem *SignPresenter*, který:

- zobrazí přihlašovací formulář (s přihlašovacím jménem a heslem)
- po odeslání formuláře ověří uživatele
- poskytne možnost odhlášení

Ve výchozím Sandboxu již jeden takový presenter je připraven. Můžeme ho jednoduše použít. Pojďme se tedy podívat do pobsahuje a jak funguje.

Začněme s přihlašovacím formulářem. Již víte jak formuláře v presenterech fungují. Otevřete si tedy presenter `SignPresenter` a najděte metodu `createComponentSignInForm`. Tabude vypadat nějak takto:

/--php
        protected function createComponentSignInForm()
        {
                $form = new Form;
                $form->addText('username', 'Uživatelské jméno:')
                        ->setRequired('Prosím vyplňte své uživatelské jméno.');

                $form->addPassword('password', 'Heslo:')
                        ->setRequired('Prosím vyplňte své heslo.');

                $form->addCheckbox('remember', 'Zůstat přihlášen');

                $form->addSubmit('send', 'Přihlásit');

                // zavolá metodu signInFormSucceeded() při úspěšném odeslání
                $form->onSuccess[] = $this->signInFormSucceeded;
                return $form;
        }
\--

Je zde input pro uživatelské jméno a heslo. Můžete smazat `remember` checkbox, pokud chcete.


View
---

Formulář je vykreslován v šabloně `app/templates/Sign/in.latte`:

/--html
{block #content}
<h1 n:block=title>Sign in</h1>

{control signInForm}
\--


Přihlašovací handler
----

Je zde také handler formuláře připravený pro přihlášení uživatele, který je spuštěn hned po úspěšném odeslání formuláře. Současný handler také rozšiřuje možnost přihlášení o dobu, po kterou zůstane uživatel přihlášen. Nyní to však není nezbytné, takže to můžete smazat.

Handler pouze převezme uživatelské jméno a heslo, které uživatel vyplnil dříve. Po přihlášení dojde opět k přesměrování na úvodní stránku.

Je zde ještě jedna věc - část kódu obalená do `try catch`. Meotda [User::login() | api:Nette\Security\User::login()] může vracet výjimku, pokud uživatelské jméno a heslo nesouhlasí s údaji v konfiguračním souboru. Jak již víme, toto může vyústit v červenou chybovou stránku, nebo v produkčním módu ve zprávu informující o server erroru. To však nechceme. Proto tuto výjimku zachytíme a předáme hezkou, uživatelsky přívětivou chybovou zprávu do zpět formuláře.

Jakmile dojde k chybě ve formuláři, stránka s formulářem se překreslí a nad formulářem se zobrazí hezká zpráva informující uživatele o špatném přihlašovacím jménu nebo heslu.

/--php
        public function signInFormSucceeded($form)
        {
                $values = $form->values;

                try {
                        $this->getUser()->login($values->username, $values->password);
                        $this->redirect('Homepage:');

                } catch (Nette\Security\AuthenticationException $e) {
                        $form->addError('Nesprávné přihlašovací jméno nebo heslo.');
                }
        }
\--


Formulář pro nové příspěvky
===

Prvně zabezpečíme formulář pro přidávání nových příspěvků. Ten je definován v presenteru `PostPresenter` a renderován v šabloně `app/templates/Post/create.latte`. Naším prvním cílem je znemožnit přístup na stránku uživatelům, kteří nejsou přihlášeni.


Šablony presenterů
---

Vytvořme action metodu `actionCreate`, která přesměruje nepřihlášené uživatele na formulář s přihlášením.

/--php
        public function actionCreate()
        {
                if (!$this->user->isLoggedIn()) {
                        $this->redirect('Sign:in');
                }
        }
\--

Stejným způsobem zabezpečíme i editovací stránku. Jednoduše přidáme tyto tři řádky také sem:

/--php
        public function actionEdit($postId)
        {
                if (!$this->user->isLoggedIn()) {
                        $this->redirect('Sign:in');
                }
\--


Skrytí odkazů
----

Neautorizovaný uživatel nemůže vidět stránku *create* ani *edit*, ale stále na ně může vidět odkazy. Ty je vhodné také schovat. Jeden odkaz je v šabloně `app/templates/Homepage/default.latte` a měl by být vidět pouze přihlášeným uživatelům.

Můžeme jej schovat využitím *n:makra* zavoláním `n:if`. Pokud je tato podmínka `false`, celý tag `<a>` včetně obsahu zůstane skrytý.

/--html
<a n:href="Post:create" n:if="$user->loggedIn">Vytvořit příspěvek</a>
\--

this is a shortcut for

/--html
{if $user->loggedIn}<a n:href="Post:create">Editovat příspěvek</a>{/if}
\--

Stejným způsobem skryjte také odkaz v šabloně `app/templates/Post/show.latte`.


Handlery formulářů
---

Poslední a **nejdůležitější věc** je **zabezpečit handlery formulářů**. Protože jsou komponenty znovupoužitelné, mohou být vykresleny v mnoha šablonách. A protože mohou být vykresleny v mnoha šablonách, mohou být také odeslány z mnoha šablon a to i když ve skutečnosti neexistují. To znamená, že i když view `create` není renderován, úpravou URL adresy může být formulář tak jako tak odeslán (přidán/editován příspěvek).

To může být ošetřeno přidáním jednoduchého *if*, který přidáme na začátek metody `postFormSucceeded`:

/--php
        public function postFormSucceeded($form)
        {
                if (!$this->user->isLoggedIn()) {
                        $this->error('Pro vytvoření, nebo editování příspěvku se musíte přihlásit.');
                }
\--

Je to velmi jednoduché, ale nesmíte na to **nikdy zapomenout**, protože je to skutečně rozhodující o bezpečnosti vaší aplikace.


Odkaz na přihlášení
====

Jak se vlastně dostaneme na přihlašovací stránku? Není zde žádný odkaz, který by tam odkazoval. Přidejme tedy jeden do šablony `app/templates/@layout.latte`. Pokuste se najít hezké místo, může to být kdekoliv chcete.

/--html
<ul class="navig">
        <li><a n:href="Homepage:">Homepage</a></li>
        {if $user->loggedIn}
                <li><a n:href="Sign:out">Odhlásit</a></li>
        {else}
                <li><a n:href="Sign:in">Přihlásit</a></li>
        {/if}
</ul>
\--

Pokud není uživatel přihlášen, zobrazí se odkaz "Přihlásit". V opačném případě se zobrazí odkaz "Odhlásit". Tato akce je již také připravena ve výchozím Sandboxu, takže ji můžeme jednoduše použít.

Jelikož uživatele po odhlášení okamžitě přesměrujeme, není potřeba žádná šablona. Odhlášení vypadá takto:

/--php
        public function actionOut()
        {
                $this->getUser()->logout();
                $this->flashMessage('Odhlášení bylo úspěšné.');
                $this->redirect('Homepage:');
        }
\--

Pouze se zavolá metoda `logout()` a následně se zobrazí heszká zpráva potvrzující úspěšné odhlášení.


Shrnutí
=======

Nyní máme odkaz odkazující na nový presenter, který požaduje od uživatelů přihlášení. K přihlášení využíváme *SimpleAuthenticator* a samotné přihlašovací údaje máme v konfiguračním souboru. Jelikož se jedná o velmi jednoduchou aplikaci, nepotřebujeme více přihlašovacích údajů. Již jsou také zabezpečeny všechny akce a formuláře, takže přidávat a editovat příspěvky mohou pouze přihlášení uživatelé.
