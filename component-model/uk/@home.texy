Модель компонента
*****************

.[perex]
Важливим поняттям у Nette є компонент. Ми вставляємо [візуальні інтерактивні компоненти |application:components] на сторінки, форми або всі їхні елементи також є компонентами. Є два основні класи, від яких успадковуються всі ці компоненти,
є частиною пакета `nette/component-model` і відповідають за створення ієрархії дерева компонентів.


Nette\ComponentModel\Component .{toc: Component}
================================================
[api:Nette\ComponentModel\Component] є спільним предком усіх компонентів. Він містить метод `getName()`, що повертає ім'я компонента, і метод `getParent()`, що повертає його батька. Обидва параметри можуть бути задані за допомогою методу `setParent()` - перший параметр - батько, другий - ім'я компонента.


lookup(string $type): ?Component .[method]
------------------------------------------
Шукає в ієрархії об'єкт потрібного класу або інтерфейсу. Наприклад, `$component->lookup(Nette\Application\UI\Presenter::class)` повертає presenter, якщо компонент пов'язаний із ним, незважаючи на кілька рівнів.


lookupPath(string $type): ?string .[method]
-------------------------------------------
Повертає так званий шлях, який являє собою рядок, утворений шляхом конкатенації імен усіх компонентів на шляху між поточним компонентом і компонентом, який ви шукаєте. Так, наприклад, `$component->lookupPath(Nette\Application\UI\Presenter::class)` повертає унікальний ідентифікатор компонента відносно ведучого.


Nette\ComponentModel\Container .{toc: Container}
================================================
[api:Nette\ComponentModel\Container] є батьківським компонентом, тобто компонентом, що містить дочірні компоненти і, таким чином, формує деревоподібну структуру. Він має методи для легкого додавання, вилучення та видалення компонентів. Він є предком, наприклад, форми або класів `Control` і `Presenter`.


getComponent(string $name): ?Component .[method]
------------------------------------------------
Повертає компонент. Спроба виклику невизначеного дочірнього компонента призводить до виклику фабрики [createComponent($name) |api:Nette\ComponentModel\Container::createComponent()]. Метод `createComponent($name)` викликає метод `createComponent<component name>` у поточному компоненті та передає ім'я компонента як параметр. Створений компонент потім передається поточному компоненту як його дочірній компонент. Ми називаємо ці фабрики компонентів, вони можуть бути реалізовані в класах, успадкованих від `Container`.


Ітерація над дочірніми компонентами .[#toc-iterating-over-children]
-------------------------------------------------------------------

Метод [getComponents($deep = false, $type = null) |api:Nette\ComponentModel\Container::getComponents()] використовується для ітерації. Перший параметр визначає, чи слід обходити компоненти в глибину (або рекурсивно). У разі використання `true` ітеруються не тільки всі його дочірні компоненти, а й усі дочірні компоненти його дочірніх компонентів і т.д. Другий параметр слугує додатковим фільтром за класом або інтерфейсом.

```php
foreach ($form->getComponents(true, Nette\Forms\IControl::class) as $control) {
	if (!$control->getRules()->validate()) {
		// ...
	}
}
```


Моніторинг предків .[#toc-monitoring-of-ancestors]
==================================================

Модель компонентів Nette дає змогу дуже динамічно працювати з деревом (ми можемо видаляти, переміщати, додавати компоненти), тому було б помилкою покладатися на те, що після створення компонента батьківський рід, рідний рідний рід і т. д. відомі одразу (у конструкторі). Зазвичай батько взагалі не відомий у момент створення компонента.

Як дізнатися, коли компонент було додано в дерево презентера? Стежити за зміною батька недостатньо, тому що батько батька батька міг бути приєднаний, наприклад, до презентера. У цьому може допомогти метод [monitor($type, $attached, $detached) |api:Nette\ComponentModel\Component::monitor()]. Кожен компонент може контролювати будь-яку кількість класів та інтерфейсів. Підключення або відключення оголошується викликом зворотних викликів `$attached` і `$detached`, відповідно, і передачею об'єкта контрольованого класу.

Приклад: Клас `UploadControl`, що представляє елемент форми для завантаження файлів у Nette Forms, має встановити атрибут форми `enctype` у значення `multipart/form-data`. Але під час створення об'єкта він не повинен бути прив'язаний до жодної форми. Коли модифікувати форму? Рішення просте - створюємо запит на моніторинг у конструкторі:

```php
class UploadControl extends Nette\Forms\Controls\BaseControl
{
	public function __construct($label)
	{
		$this->monitor(Nette\Forms\Form::class, function ($form): void {
			$form->setHtmlAttribute('enctype', 'multipart/form-data');
		});
		// ...
	}

	// ...
}
```

, і коли форма стає доступною, викликається зворотний виклик. (Раніше замість цього використовувалися звичайні методи `attached` і `detached` ).


{{leftbar: nette:@menu-topics}}
