Migrace z Latte v2 na v3
************************

.[perex]
Latte 3 má kompletně přepsaným kompilátor a formálně přesně definovanou gramatiku. Ta by měla co nejvíce odpovídat Latte 2, ale některé konstrukce bude nutné upravit.

V praxi se ukazuje, že většinu šablon není potřeba upravovat. Jak ale případné nekompatibility odhalit?

**Nejprve si nainstalujte přechodovou verzi Latte 2.11.**

Tato verze nepřináší žádné novinky, jen pomocí E_USER_DEPRECATED srozumitelně upozorňuje na případy, u kterých ví, že je nové Latte nebude podporovat. Projít všechny šablony a otestovat, jestli jsou kompatibilní, vám pomůže nástroj [Linter|/develop#linter].

Když vyřešíte všechny nekompatibility, aktualizujte na Latte 3.0. A opět pusťte Linter, aby jste se ujistili, že nový striktní parser všem šablonám porozumí.


Změny v API
===========

Změny v API se týkají jen přidávaní vlastních značek. Zbytek API zůstává stejný jako u verze 2, tj. stejným způsobem se vykreslují šablony, předávají parametry, registrují filtry.

Výjimkou je nahrazení tzv. dynamického filtru `Engine::addFilter(null, ...)` za [zavaděč filtrů |/extending-latte#Zavaděč filtrů], který si liší tím, že vrací vždy callable a registruje se metodou `Engine::addFilterLoader()`.

API pro přidávání vlastních značek je úplně jiné, takže doplňky určené pro Latte 2 s ním nebudou fungovat. Dále viz [#aktualizace doplňků].


Změny syntaxe
=============

Změny jsou následující:

- ve filtrech se jako oddělovač parametrů používá čárka, dříve `|filtr: arg : arg` je nyní `|filtr: arg, arg`
- značka `{label foo}...{/label}` je vždy párová, nepárovou je potřeba psát `{label /}`
- naopak značka `{_'text'}` je vždy nepárová, párovou `{_}...{/}` nahrazuje nové `{translate}...{/translate}`
- pseudořetězce jako `{block foo-$var}` je potřeba psát v uvozovkách `{block "foo-$var"}` nebo doplnit složené závorky `{block foo-{$var}}`
- to se týká i atributů, tj. místo `n:block="foo-$var"` použijte `n:block="foo-{$var}"`.
- je třeba dodržet velikost písmenek u filtrů, které jsou v Latte 3 case sensitive
- značka `{do ...}` nebo `{php ...}` může obsahovat pouze výrazy, pro použití libovolného PHP zaregistrujte [RawPhpExtension |/develop#RawPhpExtension].

A ještě okrajové případy:

- atributy `n:inner-xxx`, `n:tag-xxx` a `n:ifcontent` nelze použít u nepárových HTML elementů
- atribut `n:inner-snippet` musí být psán bez inner-
- musí být ukončené značky  `</script>` a `</style>`
- "odstranění magické proměnné `$iterations`":https://forum.nette.org/cs/35217-latte-3-magicka-promenna-iterations (neplést s `$iterator`!)
- značku `{includeblock file.latte}` nahrazuje `{include file.latte with blocks}`
- `{include "abc"}` by mělo být psáno jako `{include file "abc"}`, pokud `"abc"` neobsahuje tečku a není tak jasné, že jde o soubor


Aktualizace doplňků
===================

S kompletním přepsáním parseru se zcela změnil i způsob psaní vlastních značek. Pokud máte pro Latte vytvořené vlastní značky, bude třeba je napsat znovu pro verzi, viz [dokumentace|/extending-latte#značky].

Pokud používáte doplněk, který přidává značky, je potřeba počkat až autor vydá verzi pro Latte 3. Knihovny `nette/application`, `nette/caching` a `nette/forms` verze 3.1 a také Texy již aktualizovány jsou a fungují jak s Latte 2, tak i novou verzí 3.

Dále pokud manuálně registrujete rozšíření pro Latte z uvedených knihoven, kód pro Latte 2 vypadá zhruba takto:

```php
// starý kód pro Latte 2
$latte->onCompile[] = function ($latte) {
	// nette/application
	Nette\Bridges\ApplicationLatte\UIMacros::install($latte->getCompiler());

	// nette/forms
	Nette\Bridges\FormsLatte\FormMacros::install($latte->getCompiler());

	// nette/caching
	$latte->getCompiler()->addMacro('cache', new Nette\Bridges\CacheLatte\CacheMacro);
};

// nette/application
$latte->addProvider('uiControl', $control);
$latte->addProvider('uiPresenter', $presenter);
$latte->addFilter('translate', [$translator, 'translate']);

// nette/caching
$latte->addProvider('cacheStorage', $cacheStorage);

// ...
```

V Latte 3 se celá věc zjednodušuje, registraci obstará jediná metoda `addExtension()`, která přidá značky, filtry, providery, zkrátka všechno:

```php
// nový kód pro Latte 3
// nette/application
$latte->addExtension(new Nette\Bridges\ApplicationLatte\UIExtension($control));
$latte->addExtension(new Nette\Bridges\ApplicationLatte\TranslatorExtension($translator));

// nette/forms
$latte->addExtension(new Nette\Bridges\FormsLatte\FormsExtension);

// nette/caching
$latte->addExtension(new Nette\Bridges\CacheLatte\CacheExtension($cacheStorage));
```

V případě nette/application jsou rozšíření dvě. UIExtension přidává značky `n:href`, `{link}`, `{control}`, `{snippet}`, atd. TranslatorExtension zase značky pro překlad `{_'text'}` a novou `{translate}...{/translate}`.
Značky pro snippety a překlad se tak přesouvají ze samotného Latte do knihovny `nette/application`.

TranslatorExtension se aktivuje tím, že nastavíte šabloně translator metodou `$template->setTranslator($translator)`. Bez toho značky pro překlad nebudou k dispozici a je potřeba rozšíření zaregistrovat ručně.


Jste autorem doplňků?
=====================

Můžete ve své knihovně mít současně podporu obou verzí Latte. K detekci verze je nejlepší použít konstantu `Latte\Engine::VERSION` a oddělit tak použití `onCompile[]` a `addMacro()` od nového `addExtension()`:

```php
if (version_compare(Latte\Engine::VERSION, '3', '<')) {
	// inicializace Latte 2
	$this->latte->onCompile[] = function ($latte) {
		$latte->addMacro(/* ... */);
	};
} else {
	// inicializace Latte 3
	$this->latte->addExtension(/* ... */);
}
```

Jako příklad zkusíme přepsat následující kód určený pro Latte 2 do podoby pro Latte 3:

```php
// starý kód pro Latte 2
$this->latte->onCompile[] = function (Latte\Engine $latte) {
	$set = new Latte\Macros\MacroSet($latte->getCompiler());
	$set->addMacro('foo', 'echo %escape(MyClass:myFunc(%node.word, %node.array))');
};
```

Latte 3 se rozšiřuje pomocí tzv. [extensions|/creating-extension]. Triviální extension přidávající značku `foo` by vypadalo takto:

```php
// nový kód pro Latte 3
class FooExtension extends Latte\Extension
{
	public function getTags(): array
	{
		return [
			'foo' => [$this, 'createFoo'],
		];
	}

	public function createFoo(Latte\Compiler\Tag $tag): Latte\Compiler\Node
	{
		// ...
	}
}

// registrace
$this->latte->addExtension(new FooExtension);
```

Nový kompilátor je robustnější, neobsahuje dřívější zkratky, takže napsat makro vyžaduje o něco víc řádků kódu. Nelze například předat přímo řetězec s PHP kódem jako v Latte 2, místo toho vytvoříme funkci. Připomeňme, že v Latte 2 by ona funkce vypadala nějak takto:

```php
// Latte 2
$set->addMacro('foo', function (Latte\MacroNode $node, Latte\PhpWriter $writer) {
	return $writer->write('echo %escape(MyClass:myFunc(%node.word, %node.array))');
});
```

Přesto na to Latte 3 jde v podstatě podobně, jen `MacroNode` se jmenuje `Latte\Compiler\Tag` a `PhpWriter` je `Latte\Compiler\PrintContext`. Ale především je tam navíc mezikrok, tedy že funkce nevrací přímo PHP kód, ale vrací objekt `Latte\Compiler\Node` (ten pak je součástí AST stromu) a teprve Node má metodu `print(Latte\Compiler\PrintContext $content): string` která vrací PHP kód:

Mezikrok s vytvořením objektu Node lze zkrátit tím, že vrátíme předpřipravenou "AuxiliaryNode":https://github.com/nette/latte/blob/master/src/Latte/Compiler/Nodes/AuxiliaryNode.php, kde funkčnost vypsání PHP kódu předáme do konstruktoru:

```php
// Latte 3
public function createFoo(Latte\Compiler\Tag $tag): Latte\Compiler\Node
{
	return new Latte\Compiler\Nodes\AuxiliaryNode(
		fn (Latte\Compiler\PrintContext $context) => $context->format('echo ...')
	);
}
```

A nakonec, maska v `$context->format()` už nemá zkratky `%node.***`, předpokládá se, že obsah značky nejprve naparsujete. Takže nejprve využijeme parser a naparsujeme obsah do proměnných, a poté vypíšeme. Celý kód funkce by vypadal takto:

```php
public function createFoo(Latte\Compiler\Tag $tag): Latte\Compiler\Node
{
	// parsování obsahu značky
	$subject = $tag->parser->parseUnquotedStringOrExpression();
	$tag->parser->stream->tryConsume(',');
	$args = $tag->parser->parseArguments();

	// vrácení Node, která vygeneruje PHP kód
	return new Latte\Compiler\Nodes\AuxiliaryNode(
		fn(Latte\Compiler\PrintContext $context) =>
			$context->format('echo %escape(MyClass:myFunc(%node, %node));', $subject, $args)
	);
}
```

{{priority: -1}}
{{leftbar: /@left-menu}}
