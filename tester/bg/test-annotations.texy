Резюмета на тестовете
*********************

.[perex]
Анотациите определят начина, по който тестовете ще се обработват от [програмата за стартиране на тестове от командния ред |running-tests]. Те се записват в началото на тестовия файл.

Анотациите не се различават по големина на буквите. Те нямат ефект и ако тестът се изпълнява ръчно като обикновен PHP скрипт.

Пример:

```php
/**
 * TEST: Basic database query test.
 *
 * @dataProvider files/databases.ini
 * @exitCode 56
 * @phpVersion < 5.5
 */

require __DIR__ . '/../bootstrap.php';
```


Test .[filter]
--------------
Всъщност това не е анотация. Той задава само заглавието на теста, което се показва при неуспех или в регистрите.


@skip .[filter]
---------------
Тестът се прескача. Това е удобно за временно деактивиране на теста.


@phpVersion .[filter]
---------------------
Тестът ще бъде пропуснат, ако не е изпълнен с подходящата версия на PHP. Записваме анотацията като `@phpVersion [operator] version`. Можем да не посочим оператор, по подразбиране е `>=`. Примери:

```php
/**
 * @phpVersion 5.3.3
 * @phpVersion < 5.5
 * @phpVersion != 5.4.5
 */
```


@phpExtension .[filter]
-----------------------
Тестът ще бъде пропуснат, ако не са заредени всички посочени PHP разширения. В една анотация могат да бъдат записани няколко разширения или анотацията може да се използва многократно.

```php
/**
 * @phpExtension pdo, pdo_pgsql, pdo_mysql
 * @phpExtension json
 */
```


@dataProvider .[filter]
-----------------------
Тази анотация е подходяща, когато искаме да стартираме даден тест няколко пъти, но с различни данни. (Да не се бърка с анотацията със същото име за [TestCase |TestCase#dataProvider]).

Записваме анотацията като `@dataProvider file.ini`. Пътят до файла INI е относителен спрямо тестовия файл. Тестът се изпълнява толкова пъти, колкото секции има в INI файла. Да предположим, че INI файлът е `databases.ini`:

```ini
[mysql]
dsn = "mysql:host=127.0.0.1"
user = root
password = ******

[postgresql]
dsn = "pgsql:host=127.0.0.1;dbname=test"
user = postgres
password = ******

[sqlite]
dsn = "sqlite::memory:"
```

и файла `database.phpt` в същата директория:

```php
/**
 * @dataProvider databases.ini
 */

$args = Tester\Environment::loadData();
```

Тестът се изпълнява три пъти и `$args` ще съдържа стойности от разделите `mysql`, `postgresql` или `sqlite`.

Съществува и друга възможност, при която записваме анотациите с въпросителен знак като `@dataProvider? file.ini`. В този случай тестът ще бъде пропуснат, ако файлът INI не съществува.

Все още не са споменати всички възможности за анотации. Можем да напишем условия след файла INI. Тестът ще се изпълни за даден раздел само ако всички условия съвпадат. Нека разширим файла INI:

```ini
[mysql]
dsn = "mysql:host=127.0.0.1"
user = root
password = ******

[postgresql 8.4]
dsn = "pgsql:host=127.0.0.1;dbname=test"
user = postgres
password = ******

[postgresql 9.1]
dsn = "pgsql:host=127.0.0.1;dbname=test;port=5433"
user = postgres
password = ******

[sqlite]
dsn = "sqlite::memory:"
```

и използвайте анотация с условие:

```php
/**
 * @dataProvider  databases.ini  postgresql, >=9.0
 */
```

Тестът се прави само веднъж за раздела `postgresql 9.1`. Другите раздели не отговарят на условията.

По същия начин можем да предадем път до PHP скрипт вместо INI. Тя трябва да връща масив или Traversable. Файл `databases.php`:

```php
return [
	'postgresql 8.4' => [
		'dsn' => '...',
		'user' => '...',
	],

	'postgresql 9.1' => [
		'dsn' => '...',
		'user' => '...',
	],
];
```


@multiple .[filter]
-------------------
Запишете го като `@multiple N`, където `N` е цяло число. Тестът се изпълнява точно N пъти.


@testCase .[filter]
-------------------
Анотацията няма параметри. Използваме го, когато записваме тестовете като класове [TestCase |TestCase]. В този случай програмата за стартиране на тестове от командния ред ще изпълнява отделни методи в отделни процеси и паралелно в няколко нишки. Това може значително да ускори целия процес на тестване.


@exitCode .[filter]
-------------------
Записваме го като `@exitCode N`, където `N` is the exit code of the test. For example if `exit(10)` се извиква в теста, а анотацията записваме като `@exitCode 10`. Ако тестът завърши с различен код, това се счита за неуспех. Изходният код 0 (нула) се проверява, ако пропуснем анотацията


@httpCode .[filter]
-------------------
Анотацията се оценява само ако двоичният файл на PHP е CGI. В противен случай се игнорира. Записваме го като `@httpCode NNN`, където `NNN` е очакваният HTTP код. HTTP код 200 ще бъде проверен, ако пропуснем анотацията. Ако напишем `NNN` като низ, оценен като нула, например `any`, HTTP кодът изобщо няма да бъде проверен.


@outputMatch a @outputMatchFile .[filter]
-----------------------------------------
Поведението на анотациите е в съответствие с `Assert::match()` и `Assert::matchFile()`. Но в стандартния тестови изход се среща един модел. Подходящ случай на употреба е, когато предполагаме, че тестът ще завърши с фатална грешка и трябва да проверим неговия изход.


@phpIni .[filter]
-----------------
Задава стойностите на конфигурацията INI за теста. Например, записваме го като `@phpIni precision=20` и той работи по същия начин, както ако предадем стойността от командния ред с параметъра `-d precision=20`.
