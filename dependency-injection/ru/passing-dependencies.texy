Передача зависимостей
*********************

<div class=perex>

Аргументы, или «зависимости» в терминологии DI, могут быть переданы классам следующими основными способами:

* passing by constructor
* passing by method (called a setter)
* by setting a property
* by the `inject*()` method
* by annotating `inject` on a property

</div>

Первые три метода применимы в целом для всех объектно-ориентированных языков, вторые два специфичны для презентеров Nette. Сейчас мы подробнее рассмотрим каждый из этих вариантов и покажем их на конкретных примерах.


Внедрение через конструктор
===========================

Зависимости передаются в качестве аргументов конструктору при создании объекта:

```php
class MyService
{
	private Cache $cache;

	public function __construct(Cache $service)
	{
		$this->cache = $service;
	}
}

$service = new MyService($cache);
```

Эта форма полезна для обязательных зависимостей, которые абсолютно необходимы классу для функционирования, так как без них экземпляр не может быть создан.

Начиная с версии PHP 8.0, мы можем использовать более короткую форму обозначения, которая функционально эквивалентна:

```php
// PHP 8.0
class MyService
{
	public function __construct(
		private Cache $service,
	) {
	}
}
```

Начиная с версии PHP 8.1, свойство может быть помечено флагом `readonly`, который объявляет, что содержимое свойства не будет изменяться:

```php
// PHP 8.1
class MyService
{
	public function __construct(
		private readonly Cache $service,
	) {
	}
}
```


Внедрение через сеттеры
=======================

Зависимости передаются путем вызова метода, который хранит их в приватном свойстве. Обычное соглашение об именовании этих методов имеет вид `set*()`, поэтому они называются сеттерами.

```php
class MyService
{
	private Cache $cache;

	public function setCache(Cache $service): void
	{
		$this->cache = $service;
	}
}

$service = new MyService;
$service->setCache($cache);
```

Этот метод полезен для необязательных зависимостей, которые не нужны для функционирования класса, поскольку не гарантируется, что объект действительно получит их (т. е. что пользователь вызовет метод).

В то же время, этот метод позволяет неоднократно вызывать сеттер для изменения зависимости. Если это нежелательно, добавьте проверку в метод, или, начиная с PHP 8.1, пометьте свойство `$cache` флагом `readonly`.

```php
class MyService
{
	private Cache $cache;

	public function setCache(Cache $service): void
	{
		if ($this->cache) {
			throw new RuntimeException('The dependency has already been set');
		}
		$this->cache = $service;
	}
}
```


Внедрение через свойства
========================

Зависимости передаются непосредственно в свойство:

```php
class MyService
{
	public Cache $cache;
}

$service = new MyService;
$service->cache = $cache;
```

Этот метод считается неприемлемым, поскольку свойство должно быть объявлено как `public`. Следовательно, мы не можем контролировать, будет ли переданная зависимость действительно иметь указанный тип (это было верно до версии PHP 7.4), и мы теряем возможность реагировать на новую назначенную зависимость своим собственным кодом, например, чтобы предотвратить последующие изменения. В то же время, свойство становится частью публичного интерфейса класса, что может быть нежелательно.


Передача методом `inject*()`
============================

Этот метод специфичен для презентеров в Nette. Это особый случай сеттера, когда метод начинается с префикса `inject`.

```php
class MyPresenter extends Nette\Application\UI\Presenter
{
	/** @var Cache */
	private $cache;

	public function injectCache(Cache $service): void
	{
		$this->cache = $service;
	}
}
```

Основное отличие от сеттера заключается в том, что Nette DI автоматически вызывает названные таким образом методы в презентерах сразу после создания экземпляра, передавая им все необходимые зависимости. Почему они используются в презентерах [обсуждается ниже|#Какой путь выбрать в презентерах?].

Презентер может содержать несколько методов `inject*()`, а каждый метод может иметь любое количество параметров.


Аннотации `Inject`
==================

Ещё один метод, характерный для презентеров в Nette. Это особый случай передачи зависимости публичному свойству.

В этом случае свойство аннотируется как `@inject` в комментарии документации. Тип также может быть указан в комментарии к документации, если вы используете PHP ниже 7.4.

```php
class MyPresenter extends Nette\Application\UI\Presenter
{
	/** @var Cache @inject */
	public $cache;
}
```

Начиная с версии PHP 8.0, свойство может быть помечено атрибутом `Inject`:

```php
use Nette\DI\Attributes\Inject;

class MyPresenter extends Nette\Application\UI\Presenter
{
	#[Inject]
	public Cache $cache;
}
```

Опять же, Nette DI автоматически передаст зависимости свойствам, аннотированным таким образом в презентере, как только экземпляр будет создан.

Этот метод имеет те же недостатки, что и передача зависимостей в публичное свойство. Он используется в презентерах, поскольку не усложняет код и требует минимального набора текста.

---

Указав директиву конфигурации `inject: true`, автоматические вызовы методов `inject*()` и передача зависимостей свойствам, помеченным аннотациями `@inject`, могут быть включены для любого сервиса:

```neon
services:
	foo:
		create: App\Service
		inject: true
```


Какой путь выбрать?
===================

Передача зависимостей через конструктор подходит для обязательных зависимостей, которые абсолютно необходимы классу для функционирования. Передача зависимостей с помощью сеттера, с другой стороны, подходит для необязательных зависимостей или зависимостей, которые могут быть изменены позже. Передача зависимостей путем записи в публичное свойство не подходит.

Общим для всех методов является то, что [автосвязывание |autowiring] работает, конечно, только при создании объектов через контейнер DI или фабрики. Если мы создаем объект, вызывая `new` в нашем собственном коде, мы всегда должны передавать зависимости самостоятельно.


Какой путь выбрать в презентерах?
---------------------------------

В презентерах предпочтительным способом передачи зависимостей является конструктор. Однако, если презентер наследует от общего предка (например, `BasePresenter`),
лучше использовать методы `inject*()` в этом предке. Это происходит потому, что мы сохраняем конструктор свободным для потомков:

```php
abstract class BasePresenter extends Nette\Application\UI\Presenter
{
	/** @var Foo */
	private $foo;

	public function injectBase(Foo $foo): void
	{
		$this->foo = $foo;
	}
}

class MyPresenter extends BasePresenter
{
	/** @var Bar */
	private $bar;

	public function __construct(Bar $bar)
	{
		$this->bar = $bar;
	}
}
```

Также можно использовать аннотацию `@inject`, но важно помнить, что инкапсуляция прерывается.

Внедрение через конструктор не рекомендуется для общих предков, так как во время наследования необходимо получить зависимость всех родительских презентеров и передавать их в `parent::__construct()`:

```php
abstract class BasePresenter extends Nette\Application\UI\Presenter
{
	/** @var Foo */
	private $foo;

	public function __construct(Foo $foo)
	{
		$this->foo = $foo;
	}
}

class MyPresenter extends BasePresenter
{
	/** @var Bar */
	private $bar;

	public function __construct(Foo $foo, Bar $bar)
	{
		parent::__construct($foo);
		$this->bar = $bar;
	}
}
```

Методы `inject*()` также полезны в случаях, когда презентер состоит из нескольких трейтов и каждый из них требует своей зависимости. В этом случае необходимо быть уверенным, что название каждого метода внедрения уникально:

```php
class ArticlePresenter extends Nette\Application\UI\Presenter
{
	use StandardTemplateFilters;
	use RequireLoggedUser;
}

trait StandardTemplateFilters
{
	public function injectStandardTemplateFilters(TemplateBuilder $builder): void
	{
		$this->onRender[] = function () use ($builder) {
			$builder->setupTemplate($this->template);
		};
	}
}

trait RequireLoggedUser
{
	public function injectRequireLoggedUser(): void
	{
		$this->onStartup[] = function () {
			if (!$this->getUser()->isLoggedIn()) {
				$this->redirect('Sign:in', $this->storeRequest());
			}
		};
	}
}
```

Вышеупомянутые трейты используют тот факт, что все методы внедрения вызываются при создании презентера, таким образом выполняя инициализацию, содержащуюся в них. Хотя трейт `RequireLoggedUser` не использует метод для передачи зависимостей вообще.


Передача параметров презентерам
-------------------------------

Если вам нужно получить значение параметра в любом классе, передайте его этому классу. То же самое относится и к презентерам. Параметры, которые не могут быть автоматически переданы, просто записываются в файл конфигурации:

```neon
services:
	- App\Presenters\ImagePresenter("%wwwDir%/media")
```

```php
class ImagePresenter extends Nette\Application\UI\Presenter
{
	private $imageDir;
	private $optimizer;

	public function __construct(string $imageDir, ImageOptimizer $optimizer)
	{
		$this->imageDir = $imageDir;
		$this->optimizer = $optimizer;
	}
}
```

Затем презентеру передается заданная строка в качестве первого параметра конструктора, остальные параметры заполняются с помощью автосвязывания.

Однако при проектировании презентеров будьте осторожны, чтобы не включать логику приложения, которая принадлежит сервисам. Если вам нужно переконфигурировать презентер, это часто признак того, что вы не изучили проблему достаточно.
