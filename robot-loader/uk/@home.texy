RobotLoader: Клас автозавантаження
**********************************
<div class=perex>


RobotLoader - це інструмент, що забезпечує автоматичне завантаження класів для всієї програми, включно з бібліотеками сторонніх розробників.

- позбутися всіх `require`
- завантажуються тільки необхідні скрипти
- не вимагає суворих угод про іменування каталогів або файлів

</div>

Тож ми можемо забути про ці знамениті блоки коду:

```php
require_once 'Utils/Page.php';
require_once 'Utils/Style.php';
require_once 'Utils/Paginator.php';
// ...
```


Встановлення .[#toc-installation]
---------------------------------

```shell
composer require nette/robot-loader
```


Використання .[#toc-usage]
--------------------------

Подібно до того, як робот Google переглядає та індексує сайти, [RobotLoader |api:Nette\Loaders\RobotLoader] переглядає всі PHP-скрипти і записує, які класи та інтерфейси були в них знайдені. Потім ці записи зберігаються в кеші та використовуються під час усіх наступних запитів. Вам просто потрібно вказати, які каталоги індексувати і де зберігати кеш:

```php
$loader = new Nette\Loaders\RobotLoader;

// каталоги, які індексуватимуться RobotLoader (включно з підкаталогами)
$loader->addDirectory(__DIR__ . '/app');
$loader->addDirectory(__DIR__ . '/libs');

// використовувати каталог 'temp' для кешу
$loader->setTempDirectory(__DIR__ . '/temp');
$loader->register(); // Запустити RobotLoader
```

І це все. З цього моменту вам не потрібно використовувати `require`. Чудово, чи не так?

Коли RobotLoader стикається з дублюванням імені класу під час індексування, він викидає виняток і повідомляє вам про це. RobotLoader також автоматично оновлює кеш, коли йому потрібно завантажити невідомий йому клас. Ми рекомендуємо вимкнути це на виробничих серверах, див. [Кешування |#Кэширование].

Якщо ви хочете, щоб RobotLoader пропускав деякі каталоги, використовуйте `$loader->excludeDirectory('temp')` (його можна викликати кілька разів або передати кілька каталогів).

За замовчуванням RobotLoader повідомляє про помилки в PHP-файлах, кидаючи виняток `ParseError`. Його можна відключити за допомогою `$loader->reportParseErrors(false)`.


Додаток Nette .[#toc-nette-application]
---------------------------------------

Усередині програми Nette, де `$configurator` використовується в `Bootstrap.php`, ви можете налаштувати RobotLoader таким чином:

```php
$configurator = new Nette\Bootstrap\Configurator;
// ...
$configurator->setTempDirectory(__DIR__ . '/../temp');
$configurator->createRobotLoader()
	->addDirectory(__DIR__)
	->addDirectory(__DIR__ . '/../libs')
	->register();
```


Аналізатор файлів PHP .[#toc-php-files-analyzer]
------------------------------------------------

RobotLoader також можна використовувати суто для пошуку класів, інтерфейсів і трейтів у PHP-файлах **без** використання функції автозавантаження:

```php
$loader = new Nette\Loaders\RobotLoader;
$loader->addDirectory(__DIR__ . '/app');

// Сканує каталоги на наявність класів / інтерфейсів / трейтів
$loader->rebuild();

// Повертає масив пар клас => ім'я файлу
$res = $loader->getIndexedClasses();
```

Навіть при такому використанні ви можете використовувати кеш. У результаті немодифіковані файли не будуть повторно аналізуватися при повторному скануванні:

```php
$loader = new Nette\Loaders\RobotLoader;
$loader->addDirectory(__DIR__ . '/app');
$loader->setTempDirectory(__DIR__ . '/temp');

// Сканування каталогів із використанням кешу
$loader->refresh();

// Повертає масив пар клас => ім'я файлу
$res = $loader->getIndexedClasses();
```


Кешування .[#toc-caching]
-------------------------

RobotLoader працює дуже швидко, тому що він розумно використовує кеш.

Розробляючи з ним, ви майже не помічаєте, що він працює у фоновому режимі. Він постійно оновлює кеш, оскільки знає, що класи та файли можуть бути створені, видалені, перейменовані тощо. І він не сканує повторно немодифіковані файли.

При використанні на робочому сервері, з іншого боку, ми рекомендуємо відключити оновлення кешу за допомогою `$loader->setAutoRefresh(false)` (це робиться автоматично в додатку Nette), оскільки файли не змінюються. Водночас, необхідно **очистити кеш** під час завантаження нової версії на хостинг.

Звичайно, початкове сканування файлів, коли кеш ще не існує, може зайняти кілька секунд для великих додатків. RobotLoader має вбудований захист від "cache stampede":https://en.wikipedia.org/wiki/Cache_stampede.
Це ситуація, коли виробничий сервер отримує велику кількість одночасних запитів, і оскільки кеш RobotLoader ще не існує, всі вони почнуть сканувати файли. Це збільшує навантаження на процесор і файлову систему.
На щастя, RobotLoader працює таким чином, що за кількох одночасних запитів тільки перший потік індексує файли, створює кеш, решта чекають, а потім використовують кеш.


PSR-4 .[#toc-psr-4]
-------------------

Сьогодні Composer можна використовувати для [автозавантаження |best-practices:composer#Autoloading] відповідно до PSR-4. Простіше кажучи, це система, у якій простори імен та імена класів відповідають структурі каталогів та іменам файлів, тобто `App\Router\RouterFactory` знаходиться у файлі `/path/to/App/Router/RouterFactory.php`.

RobotLoader не прив'язаний до будь-якої фіксованої структури, тому він корисний у ситуаціях, коли вам не підходить структура каталогів, оформлена у вигляді просторів імен у PHP, або коли ви розробляєте застосунок, у якому історично не використовуються такі угоди. Також можна використовувати обидва завантажувачі разом.


{{leftbar: nette:@menu-topics}}
