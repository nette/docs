Globaler Zustand und Singletons
*******************************

.[perex]
Warnung: Die folgenden Konstrukte sind Symptome f√ºr schlecht entworfenen Code:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` oder `static::$var`

Finden Sie eines dieser Konstrukte in Ihrem Code? Wenn ja, dann haben Sie die M√∂glichkeit, ihn zu verbessern. Sie k√∂nnten denken, dass es sich um g√§ngige Konstrukte handelt, die oft in Beispiell√∂sungen verschiedener Bibliotheken und Frameworks zu sehen sind. Wenn das der Fall ist, ist ihr Code-Design mangelhaft.

Wir sprechen hier nicht von einer akademischen Reinheit. Alle diese Konstrukte haben eines gemeinsam: Sie verwenden einen globalen Zustand. Und das hat zerst√∂rerische Auswirkungen auf die Codequalit√§t. Die Klassen t√§uschen √ºber ihre Abh√§ngigkeiten hinweg. Der Code wird unberechenbar. Das verwirrt die Entwickler und mindert ihre Effizienz.

In diesem Kapitel wird erkl√§rt, warum dies der Fall ist und wie man globale Zust√§nde vermeiden kann.


Globale Verkettung .[#toc-global-interlinking]
----------------------------------------------

In einer idealen Welt sollte ein Objekt nur mit Objekten kommunizieren, die [direkt an es √ºbergeben |passing-dependencies] wurden. Wenn ich zwei Objekte `A` und `B` erstelle und nie einen Verweis zwischen ihnen √ºbergebe, dann k√∂nnen weder `A` noch `B` auf den Zustand des anderen zugreifen oder ihn √§ndern. Dies ist eine h√∂chst w√ºnschenswerte Eigenschaft von Code. Es ist so, als h√§tte man eine Batterie und eine Gl√ºhbirne; die Gl√ºhbirne leuchtet erst, wenn man sie √ºber ein Kabel mit der Batterie verbindet.

Dies gilt jedoch nicht f√ºr globale (statische) Variablen oder Singletons. Das Objekt `A` k√∂nnte *drahtlos* auf das Objekt `C` zugreifen und es ohne jegliche Referenz√ºbergabe √§ndern, indem es `C::changeSomething()` aufruft. Wenn das Objekt `B` auch auf das globale `C` zugreift, dann k√∂nnen sich `A` und `B` √ºber `C` gegenseitig beeinflussen.

Die Verwendung globaler Variablen f√ºhrt eine neue Form der *drahtlosen* Kopplung ein, die von au√üen nicht sichtbar ist. Sie schafft einen Nebelschleier, der das Verst√§ndnis und die Verwendung des Codes erschwert. Um die Abh√§ngigkeiten wirklich zu verstehen, m√ºssen Entwickler jede Zeile des Quellcodes lesen, anstatt sich nur mit den Klassenschnittstellen vertraut zu machen. Au√üerdem ist diese Verstrickung v√∂llig unn√∂tig. Globale Zust√§nde werden verwendet, weil sie von √ºberall her leicht zug√§nglich sind und beispielsweise das Schreiben in eine Datenbank √ºber eine globale (statische) Methode `DB::insert()` erm√∂glichen. Wie wir jedoch sehen werden, ist der Nutzen, den er bietet, minimal, w√§hrend die Komplikationen, die er mit sich bringt, schwerwiegend sind.

.[note]
Was das Verhalten angeht, gibt es keinen Unterschied zwischen einer globalen und einer statischen Variable. Sie sind gleicherma√üen sch√§dlich.


Die spukhafte Wirkung in der Ferne .[#toc-the-spooky-action-at-a-distance]
--------------------------------------------------------------------------

"Spukhafte Fernwirkung" - so nannte Albert Einstein 1935 ein Ph√§nomen der Quantenphysik, das ihm eine G√§nsehaut bereitete.
Es handelt sich dabei um die Quantenverschr√§nkung, deren Besonderheit darin besteht, dass die Messung von Informationen √ºber ein Teilchen sofort Auswirkungen auf ein anderes Teilchen hat, selbst wenn sie Millionen von Lichtjahren voneinander entfernt sind.
Dies verst√∂√üt scheinbar gegen das grundlegende Gesetz des Universums, dass sich nichts schneller als das Licht bewegen kann.

In der Software-Welt k√∂nnen wir von einer "spukhaften Fernwirkung" sprechen, wenn wir einen Prozess laufen lassen, von dem wir glauben, dass er isoliert ist (weil wir ihm keine Referenzen √ºbergeben haben), aber unerwartete Wechselwirkungen und Zustands√§nderungen an entfernten Stellen des Systems auftreten, von denen wir dem Objekt nichts gesagt haben. Dies kann nur √ºber den globalen Zustand geschehen.

Stellen Sie sich vor, Sie treten in ein Projektentwicklungsteam ein, das √ºber eine gro√üe, ausgereifte Codebasis verf√ºgt. Ihr neuer Leiter bittet Sie, eine neue Funktion zu implementieren, und wie ein guter Entwickler beginnen Sie damit, einen Test zu schreiben. Da Sie aber neu im Projekt sind, machen Sie viele Tests vom Typ "was passiert, wenn ich diese Methode aufrufe". Und Sie versuchen, den folgenden Test zu schreiben:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // Ihre Kartennummer
	$cc->charge(100);
}
```

Sie f√ºhren den Code aus, vielleicht mehrere Male, und nach einer Weile bemerken Sie auf Ihrem Telefon Benachrichtigungen von der Bank, dass jedes Mal, wenn Sie ihn ausf√ºhren, Ihre Kreditkarte mit 100 Dollar belastet wurde ü§¶‚Äç‚ôÇÔ∏è

Wie um alles in der Welt konnte der Test eine tats√§chliche Belastung verursachen? Es ist nicht einfach, mit einer Kreditkarte zu arbeiten. Sie m√ºssen mit einem Webdienst eines Drittanbieters interagieren, Sie m√ºssen die URL dieses Webdienstes kennen, Sie m√ºssen sich anmelden und so weiter.
Keine dieser Informationen ist in dem Test enthalten. Noch schlimmer ist, dass Sie nicht einmal wissen, wo diese Informationen vorhanden sind und wie Sie externe Abh√§ngigkeiten simulieren k√∂nnen, damit nicht bei jedem Durchlauf erneut 100 Dollar f√§llig werden. Und woher sollten Sie als neuer Entwickler wissen, dass das, was Sie gerade tun wollten, Sie um 100 Dollar √§rmer machen w√ºrde?

Das ist eine gespenstische Aktion aus der Ferne!

Es bleibt Ihnen nichts anderes √ºbrig, als sich durch eine Menge Quellcode zu w√ºhlen und √§ltere und erfahrenere Kollegen zu fragen, bis Sie verstehen, wie die Zusammenh√§nge im Projekt funktionieren.
Das liegt daran, dass man bei einem Blick auf die Schnittstelle der Klasse `CreditCard` den globalen Zustand, der initialisiert werden muss, nicht feststellen kann. Selbst ein Blick in den Quellcode der Klasse verr√§t Ihnen nicht, welche Initialisierungsmethode Sie aufrufen m√ºssen. Bestenfalls k√∂nnen Sie die globale Variable finden, auf die zugegriffen wird, und versuchen, daraus zu erraten, wie sie zu initialisieren ist.

Die Klassen in einem solchen Projekt sind pathologische L√ºgner. Die Zahlungskarte gibt vor, dass man sie einfach instanziieren und die Methode `charge()` aufrufen kann. Insgeheim interagiert sie jedoch mit einer anderen Klasse, `PaymentGateway`. Sogar ihre Schnittstelle sagt, dass sie unabh√§ngig initialisiert werden kann, aber in Wirklichkeit bezieht sie Anmeldedaten aus einer Konfigurationsdatei usw.
Den Entwicklern, die diesen Code geschrieben haben, ist klar, dass `CreditCard` `PaymentGateway` ben√∂tigt. Sie haben den Code auf diese Weise geschrieben. Aber f√ºr jeden, der neu in das Projekt einsteigt, ist dies ein v√∂lliges R√§tsel und behindert das Lernen.

Wie kann man das Problem l√∂sen? Ganz einfach. **Lassen Sie die API Abh√§ngigkeiten deklarieren.

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Beachten Sie, dass die Beziehungen innerhalb des Codes pl√∂tzlich offensichtlich sind. Indem Sie erkl√§ren, dass die Methode `charge()` `PaymentGateway` ben√∂tigt, m√ºssen Sie niemanden fragen, wie der Code voneinander abh√§ngig ist. Sie wissen, dass Sie eine Instanz der Methode erstellen m√ºssen, und wenn Sie dies versuchen, sto√üen Sie auf die Tatsache, dass Sie Zugriffsparameter bereitstellen m√ºssen. Ohne sie w√ºrde der Code nicht einmal laufen.

Und das Wichtigste ist, dass Sie jetzt das Zahlungs-Gateway simulieren k√∂nnen, damit Sie nicht jedes Mal, wenn Sie einen Test durchf√ºhren, 100 Dollar bezahlen m√ºssen.

Der globale Status bewirkt, dass Ihre Objekte heimlich auf Dinge zugreifen k√∂nnen, die nicht in ihren APIs deklariert sind, und macht Ihre APIs damit zu pathologischen L√ºgnern.

Sie haben vielleicht noch nie dar√ºber nachgedacht, aber immer wenn Sie einen globalen Zustand verwenden, schaffen Sie geheime drahtlose Kommunikationskan√§le. Unheimliche Remote-Aktionen zwingen Entwickler dazu, jede Codezeile zu lesen, um m√∂gliche Interaktionen zu verstehen, verringern die Produktivit√§t der Entwickler und verwirren neue Teammitglieder.
Wenn Sie derjenige sind, der den Code erstellt hat, kennen Sie die tats√§chlichen Abh√§ngigkeiten, aber jeder, der nach Ihnen kommt, ist ahnungslos.

Schreiben Sie keinen Code, der globale Zust√§nde verwendet, sondern √ºbergeben Sie lieber Abh√§ngigkeiten. Das hei√üt, Dependency Injection.


Die Zerbrechlichkeit des globalen Staates .[#toc-brittleness-of-the-global-state]
---------------------------------------------------------------------------------

Bei Code, der globale Zust√§nde und Singletons verwendet, ist es nie sicher, wann und von wem dieser Zustand ge√§ndert wurde. Dieses Risiko ist bereits bei der Initialisierung gegeben. Der folgende Code soll eine Datenbankverbindung erstellen und das Zahlungs-Gateway initialisieren, aber er l√∂st immer wieder eine Ausnahme aus, und die Suche nach der Ursache ist extrem m√ºhsam:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Sie m√ºssen den Code im Detail durchgehen, um herauszufinden, dass das Objekt `PaymentGateway` drahtlos auf andere Objekte zugreift, von denen einige eine Datenbankverbindung ben√∂tigen. Sie m√ºssen also die Datenbank vor `PaymentGateway` initialisieren. Der Nebel des globalen Zustands verbirgt dies jedoch vor Ihnen. Wie viel Zeit w√ºrden Sie sparen, wenn die API der einzelnen Klassen nicht l√ºgen und ihre Abh√§ngigkeiten deklarieren w√ºrde?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Ein √§hnliches Problem ergibt sich bei der Verwendung des globalen Zugriffs auf eine Datenbankverbindung:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Beim Aufruf der Methode `save()` ist nicht sicher, ob bereits eine Datenbankverbindung erstellt wurde und wer f√ºr deren Erstellung verantwortlich ist. Wenn wir zum Beispiel die Datenbankverbindung spontan √§ndern wollten, vielleicht zu Testzwecken, m√ºssten wir wahrscheinlich zus√§tzliche Methoden wie `DB::reconnect(...)` oder `DB::reconnectForTest()` erstellen.

Betrachten wir ein Beispiel:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

Wo k√∂nnen wir sicher sein, dass beim Aufruf von `$article->save()` wirklich die Testdatenbank verwendet wird? Was w√§re, wenn die Methode `Foo::doSomething()` die globale Datenbankverbindung √§ndern w√ºrde? Um das herauszufinden, m√ºssten wir den Quellcode der Klasse `Foo` und wahrscheinlich vieler anderer Klassen untersuchen. Dieser Ansatz w√ºrde jedoch nur eine kurzfristige Antwort liefern, da sich die Situation in der Zukunft √§ndern kann.

Was w√§re, wenn wir die Datenbankverbindung in eine statische Variable innerhalb der Klasse `Article` verschieben?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Das √§ndert √ºberhaupt nichts. Das Problem ist ein globaler Zustand und es spielt keine Rolle, in welcher Klasse es sich versteckt. In diesem Fall, wie auch im vorherigen, haben wir keine Ahnung, in welche Datenbank geschrieben wird, wenn die Methode `$article->save()` aufgerufen wird. Jeder am entfernten Ende der Anwendung k√∂nnte die Datenbank jederzeit mit `Article::setDb()` √§ndern. Unter unseren H√§nden.

Der globale Zustand macht unsere Anwendung **extrem anf√§llig**.

Es gibt jedoch eine einfache M√∂glichkeit, mit diesem Problem umzugehen. Lassen Sie die API einfach Abh√§ngigkeiten deklarieren, um die ordnungsgem√§√üe Funktionalit√§t zu gew√§hrleisten.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Auf diese Weise wird die Sorge vor versteckten und unerwarteten √Ñnderungen an Datenbankverbindungen beseitigt. Jetzt wissen wir genau, wo der Artikel gespeichert ist, und keine Code-√Ñnderungen in einer anderen, nicht verwandten Klasse k√∂nnen die Situation mehr ver√§ndern. Der Code ist nicht mehr anf√§llig, sondern stabil.

Schreiben Sie keinen Code, der globale Zust√§nde verwendet, sondern √ºbergeben Sie lieber Abh√§ngigkeiten. Daher Dependency Injection.


Singleton .[#toc-singleton]
---------------------------

Singleton ist ein Entwurfsmuster, das gem√§√ü der [Definition |https://en.wikipedia.org/wiki/Singleton_pattern] aus der ber√ºhmten Gang of Four-Publikation eine Klasse auf eine einzige Instanz beschr√§nkt und globalen Zugriff auf diese bietet. Die Implementierung dieses Musters √§hnelt normalerweise dem folgenden Code:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// und andere Methoden, die die Funktionen der Klasse ausf√ºhren
}
```

Leider f√ºhrt das Singleton einen globalen Zustand in die Anwendung ein. Und wie wir oben gezeigt haben, ist ein globaler Zustand unerw√ºnscht. Deshalb wird das Singleton als Antipattern betrachtet.

Verwenden Sie keine Singletons in Ihrem Code und ersetzen Sie sie durch andere Mechanismen. Sie brauchen Singletons wirklich nicht. Wenn Sie jedoch die Existenz einer einzigen Instanz einer Klasse f√ºr die gesamte Anwendung garantieren m√ºssen, √ºberlassen Sie dies dem [DI-Container |container].
Erstellen Sie also ein Anwendungssingleton oder einen Dienst. Dadurch wird die Klasse nicht mehr f√ºr ihre eigene Einzigartigkeit sorgen (d. h. sie wird keine `getInstance()` -Methode und keine statische Variable haben) und nur ihre Funktionen ausf√ºhren. Damit wird das Prinzip der einzigen Verantwortung nicht mehr verletzt.


Globaler Zustand vs. Tests .[#toc-global-state-versus-tests]
------------------------------------------------------------

Beim Schreiben von Tests gehen wir davon aus, dass jeder Test eine isolierte Einheit ist und dass kein externer Zustand in ihn eintritt. Und kein Zustand verl√§sst die Tests. Wenn ein Test abgeschlossen ist, sollte jeder mit dem Test verbundene Zustand automatisch vom Garbage Collector entfernt werden. Dadurch werden die Tests isoliert. Daher k√∂nnen wir die Tests in beliebiger Reihenfolge ausf√ºhren.

Wenn jedoch globale Zust√§nde/Singletons vorhanden sind, sind alle diese sch√∂nen Annahmen hinf√§llig. Ein Zustand kann einen Test betreten und verlassen. Pl√∂tzlich kann die Reihenfolge der Tests eine Rolle spielen.

Um Singletons √ºberhaupt testen zu k√∂nnen, m√ºssen Entwickler oft ihre Eigenschaften lockern, indem sie beispielsweise zulassen, dass eine Instanz durch eine andere ersetzt wird. Solche L√∂sungen sind bestenfalls Hacks, die schwer zu wartenden und schwer zu verstehenden Code produzieren. Jeder Test oder jede Methode `tearDown()`, die einen globalen Zustand beeinflusst, muss diese √Ñnderungen r√ºckg√§ngig machen.

Der globale Zustand ist das gr√∂√üte Problem bei Unit-Tests!

Wie kann man das Problem l√∂sen? Ganz einfach. Schreiben Sie keinen Code, der Singletons verwendet, sondern ziehen Sie es vor, Abh√§ngigkeiten zu √ºbergeben. Das hei√üt, dependency injection.


Globale Konstanten .[#toc-global-constants]
-------------------------------------------

Der globale Status ist nicht auf die Verwendung von Singletons und statischen Variablen beschr√§nkt, sondern kann auch f√ºr globale Konstanten gelten.

Konstanten, deren Wert uns keine neuen (`M_PI`) oder n√ºtzlichen (`PREG_BACKTRACK_LIMIT_ERROR`) Informationen liefert, sind eindeutig in Ordnung.
Umgekehrt sind Konstanten, die dazu dienen, Informationen innerhalb des Codes *drahtlos* weiterzugeben, nichts anderes als eine versteckte Abh√§ngigkeit. Wie `LOG_FILE` im folgenden Beispiel.
Die Verwendung der Konstante `FILE_APPEND` ist v√∂llig korrekt.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

In diesem Fall sollten wir den Parameter im Konstruktor der Klasse `Foo` deklarieren, um ihn zum Bestandteil der API zu machen:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Jetzt k√∂nnen wir Informationen √ºber den Pfad zur Protokollierungsdatei √ºbergeben und ihn bei Bedarf leicht √§ndern, was das Testen und Warten des Codes erleichtert.


Globale Funktionen und statische Methoden .[#toc-global-functions-and-static-methods]
-------------------------------------------------------------------------------------

Wir m√∂chten betonen, dass die Verwendung von statischen Methoden und globalen Funktionen an sich nicht problematisch ist. Wir haben die Unangemessenheit der Verwendung von `DB::insert()` und √§hnlichen Methoden erl√§utert, aber es ging immer um den globalen Zustand, der in einer statischen Variablen gespeichert wird. Die Methode `DB::insert()` erfordert das Vorhandensein einer statischen Variablen, weil sie die Datenbankverbindung speichert. Ohne diese Variable w√§re es unm√∂glich, die Methode zu implementieren.

Die Verwendung von deterministischen statischen Methoden und Funktionen, wie `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` und viele andere, ist mit der Dependency Injection vollkommen vereinbar. Diese Funktionen liefern immer die gleichen Ergebnisse f√ºr die gleichen Eingabeparameter und sind daher vorhersehbar. Sie verwenden keinen globalen Zustand.

Allerdings gibt es in PHP Funktionen, die nicht deterministisch sind. Dazu geh√∂rt z.B. die Funktion `htmlspecialchars()`. Ihr dritter Parameter, `$encoding`, wird, wenn er nicht angegeben wird, standardm√§√üig mit dem Wert der Konfigurationsoption `ini_get('default_charset')` belegt. Es wird daher empfohlen, diesen Parameter immer anzugeben, um ein unvorhersehbares Verhalten der Funktion zu vermeiden. Nette tut dies konsequent.

Einige Funktionen, wie `strtolower()`, `strtoupper()` und √§hnliche, haben sich in der j√ºngsten Vergangenheit nicht deterministisch verhalten und waren von der Einstellung `setlocale()` abh√§ngig. Dies f√ºhrte zu zahlreichen Komplikationen, vor allem bei der Arbeit mit der t√ºrkischen Sprache.
Das liegt daran, dass die t√ºrkische Sprache zwischen Gro√ü- und Kleinschreibung `I` mit und ohne Punkt unterscheidet. So gab `strtolower('I')` das Zeichen `ƒ±` und `strtoupper('i')` das Zeichen `ƒ∞` zur√ºck, was dazu f√ºhrte, dass Anwendungen eine Reihe von mysteri√∂sen Fehlern verursachten.
Dieses Problem wurde jedoch in der PHP-Version 8.2 behoben, und die Funktionen sind nun nicht mehr vom Gebietsschema abh√§ngig.

Dies ist ein sch√∂nes Beispiel daf√ºr, wie der globale Zustand Tausende von Entwicklern auf der ganzen Welt geplagt hat. Die L√∂sung bestand darin, ihn durch Dependency Injection zu ersetzen.


Wann ist es m√∂glich, einen globalen Status zu verwenden? .[#toc-when-is-it-possible-to-use-global-state]
--------------------------------------------------------------------------------------------------------

Es gibt bestimmte Situationen, in denen es m√∂glich ist, globale Zust√§nde zu verwenden. Zum Beispiel beim Debuggen von Code, wenn Sie den Wert einer Variablen ausgeben oder die Dauer eines bestimmten Programmteils messen m√ºssen. In solchen F√§llen, die tempor√§re Aktionen betreffen, die sp√§ter aus dem Code entfernt werden, ist es legitim, einen global verf√ºgbaren Dumper oder eine Stoppuhr zu verwenden. Diese Werkzeuge sind nicht Teil des Codeentwurfs.

Ein weiteres Beispiel sind die Funktionen f√ºr die Arbeit mit regul√§ren Ausdr√ºcken `preg_*`, die intern kompilierte regul√§re Ausdr√ºcke in einem statischen Cache im Speicher ablegen. Wenn Sie denselben regul√§ren Ausdruck mehrmals in verschiedenen Teilen des Codes aufrufen, wird er nur einmal kompiliert. Der Cache spart Leistung und ist au√üerdem f√ºr den Benutzer v√∂llig unsichtbar, so dass eine solche Verwendung als legitim angesehen werden kann.


Zusammenfassung .[#toc-summary]
-------------------------------

Wir haben gezeigt, warum es Sinn macht

1) Entfernen Sie alle statischen Variablen aus dem Code
2) Deklarieren Sie Abh√§ngigkeiten
3) Und verwenden Sie Dependency Injection

Wenn Sie √ºber den Entwurf von Code nachdenken, sollten Sie bedenken, dass jedes `static $foo` ein Problem darstellt. Damit Ihr Code eine DI-konforme Umgebung wird, ist es unerl√§sslich, den globalen Zustand vollst√§ndig zu beseitigen und durch Dependency Injection zu ersetzen.

W√§hrend dieses Prozesses kann es vorkommen, dass Sie eine Klasse aufteilen m√ºssen, weil sie mehr als eine Verantwortung hat. Machen Sie sich keine Gedanken dar√ºber; streben Sie das Prinzip der einen Verantwortung an.

*Ich m√∂chte Mi≈°ko Hevery danken, dessen Artikel wie [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] die Grundlage f√ºr dieses Kapitel bilden.*
