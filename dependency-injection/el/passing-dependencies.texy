Πέρασμα εξαρτήσεων
******************
<div class=perex>


Τα επιχειρήματα, ή "εξαρτήσεις" στην ορολογία DI, μπορούν να μεταβιβαστούν σε κλάσεις με τους ακόλουθους κύριους τρόπους:

* περνώντας από τον κατασκευαστή
* πέρασμα μέσω μεθόδου (που ονομάζεται setter)
* με τον καθορισμό μιας ιδιότητας
* μέσω μεθόδου, σημείωσης ή χαρακτηριστικού *inject*

</div>

Οι τρεις πρώτες μέθοδοι εφαρμόζονται γενικά σε όλες τις αντικειμενοστραφείς γλώσσες, η τέταρτη είναι ειδική για τους παρουσιαστές της Nette, γι' αυτό και εξετάζεται σε [ξεχωριστό κεφάλαιο |best-practices:inject-method-attribute]. Θα εξετάσουμε τώρα πιο προσεκτικά καθεμία από αυτές τις επιλογές και θα τις παρουσιάσουμε με συγκεκριμένα παραδείγματα.


Έγχυση κατασκευαστή .[#toc-constructor-injection]
=================================================

Οι εξαρτήσεις περνούν ως ορίσματα στον κατασκευαστή κατά τη δημιουργία του αντικειμένου:

```php
class MyService
{
	private Cache $cache;

	public function __construct(Cache $service)
	{
		$this->cache = $service;
	}
}

$service = new MyService($cache);
```

Αυτή η μορφή είναι χρήσιμη για τις υποχρεωτικές εξαρτήσεις που η κλάση χρειάζεται οπωσδήποτε για να λειτουργήσει, καθώς χωρίς αυτές δεν μπορεί να δημιουργηθεί η περίπτωση.

Από την PHP 8.0, μπορούμε να χρησιμοποιήσουμε μια συντομότερη μορφή συμβολισμού που είναι λειτουργικά ισοδύναμη:

```php
// PHP 8.0
class MyService
{
	public function __construct(
		private Cache $service,
	) {
	}
}
```

Από την PHP 8.1, μια ιδιότητα μπορεί να επισημανθεί με μια σημαία `readonly` που δηλώνει ότι τα περιεχόμενα της ιδιότητας δεν θα αλλάξουν:

```php
// PHP 8.1
class MyService
{
	public function __construct(
		private readonly Cache $service,
	) {
	}
}
```

Το DI container περνάει τις εξαρτήσεις στον κατασκευαστή αυτόματα χρησιμοποιώντας [την αυτόματη σύνδεση (autowiring |autowiring]). Τα επιχειρήματα που δεν μπορούν να περάσουν με αυτόν τον τρόπο (π.χ. συμβολοσειρές, αριθμοί, booleans) [γράφονται στη διαμόρφωση |services#Arguments].


Έγχυση ρυθμιστή .[#toc-setter-injection]
========================================

Οι εξαρτήσεις μεταβιβάζονται με την κλήση μιας μεθόδου που τις αποθηκεύει σε μια ιδιωτική ιδιότητα. Η συνήθης σύμβαση ονοματοδοσίας για αυτές τις μεθόδους είναι της μορφής `set*()`, γι' αυτό και ονομάζονται setters.

```php
class MyService
{
	private Cache $cache;

	public function setCache(Cache $service): void
	{
		$this->cache = $service;
	}
}

$service = new MyService;
$service->setCache($cache);
```

Η μέθοδος αυτή είναι χρήσιμη για προαιρετικές εξαρτήσεις που δεν είναι απαραίτητες για τη λειτουργία της κλάσης, καθώς δεν είναι εγγυημένο ότι το αντικείμενο θα τις λάβει πραγματικά (δηλαδή ότι ο χρήστης θα καλέσει τη μέθοδο).

Ταυτόχρονα, η μέθοδος αυτή επιτρέπει την επανειλημμένη κλήση του setter για την αλλαγή της εξάρτησης. Αν αυτό δεν είναι επιθυμητό, προσθέστε έναν έλεγχο στη μέθοδο ή, από την PHP 8.1, σημειώστε την ιδιότητα `$cache` με τη σημαία `readonly`.

```php
class MyService
{
	private Cache $cache;

	public function setCache(Cache $service): void
	{
		if ($this->cache) {
			throw new RuntimeException('The dependency has already been set');
		}
		$this->cache = $service;
	}
}
```

Η κλήση του setter ορίζεται στη διαμόρφωση του δοχείου DI στην [ενότητα setup |services#Setup]. Επίσης, εδώ χρησιμοποιείται η αυτόματη μεταβίβαση εξαρτήσεων από την αυτόματη σύνδεση:

```neon
services:
	-
		create: MyService
		setup:
			- setCache
```


Property Injection .[#toc-property-injection]
=============================================

Οι εξαρτήσεις περνούν απευθείας στην ιδιότητα:

```php
class MyService
{
	public Cache $cache;
}

$service = new MyService;
$service->cache = $cache;
```

 `public`Ως εκ τούτου, δεν έχουμε κανέναν έλεγχο για το αν η μεταβιβαζόμενη εξάρτηση θα είναι πράγματι του καθορισμένου τύπου (αυτό ίσχυε πριν από την PHP 7.4) και χάνουμε τη δυνατότητα να αντιδράσουμε στη νέα ανατεθείσα εξάρτηση με το δικό μας κώδικα, για παράδειγμα για να αποτρέψουμε μεταγενέστερες αλλαγές. Ταυτόχρονα, η ιδιότητα γίνεται μέρος της δημόσιας διεπαφής της κλάσης, κάτι που μπορεί να μην είναι επιθυμητό.

Η ρύθμιση της μεταβλητής ορίζεται στη διαμόρφωση του δοχείου DI στην [ενότητα setup |services#Setup]:

```neon
services:
	-
		create: MyService
		setup:
			- $cache = @\Cache
```


Ποιον τρόπο να επιλέξω; .[#toc-which-way-to-choose]
===================================================

- ο κατασκευαστής είναι κατάλληλος για τις υποχρεωτικές εξαρτήσεις που χρειάζεται η κλάση για να λειτουργήσει
- ο setter, από την άλλη πλευρά, είναι κατάλληλος για προαιρετικές εξαρτήσεις ή εξαρτήσεις που μπορούν να αλλάξουν
- οι δημόσιες μεταβλητές δεν συνιστώνται
