Components
**********

/--div .[perex]
Components are foundation of reusable code. They make your work easier and allows to profit from community work. Components are wonderful.
We'll explain

- how to write components
- what are signals
- how to send flash messages
- how to use AJAX
\--

Component is a renderable object. It can be form, menu, poll etc. Within one page there can be as much components as you wish. At http://addons.nette.org/cs you can find open-source components which were put there by volunteers from the Nette Framework community.

You can find an example of a component and it's use in page in the [distribution package | installation] of Nette in the folder `examples/Fifteen`

A component is descendant of class [api:Nette\Application\UI\Control]:

/--php
use Nette\Application\UI\Control;

class PollControl extends Control
{
}
\--

.[note]
When talking about components, we usually mean descendants of class [Control |api:Nette\Application\UI\Control]. Using the term "controls" would be more accurate, but the term "Components" is used for language reasons from Nette's early age.

Templates
=========
Component has factory for its [template | templating]. It creates template, passes several variables (shown below) and registers [default helpers]. Rendering is our job and it is done in method `render()`. This is where we choose the file from which will be the template loaded. `render()` method is also the right place to register variables used in the template. Template can be put inside the same folder as component and with the same file name.

/--php
public function render()
{
	$template = $this->template;
	$template->setFile(dirname(__FILE__) . '/PollControl.latte');
	// insert some parameters to the template
	$template->param = 'some value';
	// render it
	$template->render();
}
\--

Links
=====
Method `link()` is made for linking to signals (explained below). Links are rendered using macro `{link}` in the template.

Use in component:
/--php
$url = $this->link('click!', $x, $y);
\--

Use in template:
/--html
<a n:href="click! $x, $y"> ... </a>
\--

Using exclamation mark for signals is obligatory in presenters. In components it is optional because components does not have actions.

Flash messages
==============
Component has its own storage of flash messages independent on presenter. These messages inform about result of operations which are **followed by redirection**.

Sending is done by method [flashMessage |api:Nette\Application\UI\Control::flashMessage()]. The first parameter is message's text and second (optional) parameter is its type (error, warning, info, etc.). Method `flashMessage()` returns an instance of flash message to whom you can pass informations.

Example:
/--php
public function deleteFormSubmitted(Form $form)
{
    ... delete record using model ...

    // pass flash message
    $this->flashMessage('Item was deleted.');

    $this->redirect(...); // and redirect
}
\--

Template receives this messages automatically in variable `$flashes`. This variable contains an array of objects (`stdClass`) which contains properties `message`, `type` and can contain extra information mentioned above.

Example:
/--php
{foreach $flashes as $flash}
<div class="flash {$flash->type}">{$flash->message}</div>
{/foreach}
\--

If `flashMessage()` is saved and redirection occurs, the same parameter `$flashes` will be present in the template. Messages then stay *alive* for the next three seconds - to prevent their loss in case that page loading was not successful and user refreshed the request. If someone refreshes the page (F5) twice in a row the flash message persists, if s/he clicks elsewhere it disappears.

Signal (subrequest)
======================
Signal (subrequest) is a communication with server under the level of normal view. Signals are actions without change of view. Only presenter can change view therefore components work only with signals. `$component->link()` links to signal, `$presenter->link()` usually links to view (unless an exclamation mark is used - `$presenter->link('signal!')`). But component can call `$component->presenter->link('view')`.

Signal causes reload of the page like the original request (with the exception of AJAX) and invokes method `signalRecieved($signal)` whose default implementation in class `PresenterComponent` tries to call method composed of words `handle{Signal}`.
Next processing relies on given object. Objects which are descendants of `PresenterComponent` (i.e. `Control` and `Presenter`) tries to call `handle{Signal}` with relevant parameters.
In other words: the definition of method `handle{Signal}` is taken and all parameters which where received in the request are matched with method's parameters. It means that parameter `id` from URL is matched to method's parameter `$id`, `something` to `$something` and so on.

Example signal handler:

/--php
public function handleClick($x, $y)
{
    if (!$this->isClickable($x, $y)) {
        throw new Nette\Application\UI\BadSignalException('Action not allowed.');
    }

    ... processing of signal ...
}
\--

If method `handle{Signal}` doesn't exist a [api:Nette\Application\UI\BadSignalException] is caused by `signalRecieved`.

.[note]
Signal can be received by any component, presenter of object which implements interface `ISignalReceiver`.

Main receivers of signals are `Presenters` and visual components extending `Control` (these are **automatically invalidate** which is important for AJAX). Signal is a sign for object that it has to do something - poll counts in a vote from user, box with news has to unfold, form was sent and has to process data and so on.

.[note]
Signal is always called on current presenter and view therefore it is impossible to point it elsewhere.

URL for signal is created using the method `PresenterComponent::link()`. As parameter `$destination` we pass string `{signal}!` and as `$args` an array of arguments which we want to pass to signal handler. Signal parameters are attached to URL of current presenter/view. **Parameter `?do` in URL determines the signal called.**

Its format is `{signal}` or `{signalReceiver}-{signal}`. `{signalReceiver}` is name of component in presenter. This is why hyphen (inaccurately dash) can't be presenter in name of components - it is used to divide name of component and signal.

Methods `isSignalReceiver()` verifies whether component (first argument) is receiver of signal (second argument). Second argument can be omitted - then it finds out if component is receiver of any signal. If the second parameter is `TRUE` it verifies whether component or its descendants are receiver of signal.

In any phase preceding `handle{Signal}` can be signal performed manually by calling method `$this->processSignal()` which takes responsibility for signal execution. Takes receiver component (if not set it is presenter itself) and sends it the signal.

Example:
/--php
if ($this->isSignalReceiver($this, 'paging') || $this->isSignalReceiver($this, 'sorting')) {
    $this->processSignal();
}
\--

The signal is executed and it won't be called again.

Subrequest vs. request
----------------------
Difference between signal and request:

* subrequest keeps all components
* request keeps only persistent components

Invalidation and snippets
=========================
During processing of signal can occur changes which require re-rendering of component. Three methods takes care about this: `invalidateControl()`, `validateControl()` and `isControlValid()`. They are basic elements of using AJAX with Nette.

Nette also offers more precise differentiation of validity with use of [snippets | ajax]

Snippets can be invalidated one by one (any component can have as many snippets as needed). If whole component is invalidated than each of its snippets is invalidated too. Component is considered invalid if any of its children (components) is invalid.

More information can be found on [the page about AJAX | ajax].

Persistent parameters
=====================
It is often needed to keep some parameter for the whole time of working with component. It can be for example number of page in pagination. This parameter is marked as persistent using [annotation | php-language-enhancements#anotace] `@persistent`.

/--php
class PollControl extends Control
{
    /** @persistent */
    public $page = 1;

    ...
}
\--

This parameter will be automatically passed in every link as a `GET` parameter until user leaves the page with this component.

.[caution]
Never rely on persistent parameters because they can be easily faked (by overwriting the URL). Verify for example if the page number is within correct interval.
