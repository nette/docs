Vytváříme Extension
*******************

.[perex]
Tzv. *rozšíření* může definovat vlastní značky, filtry, funkce, providery, atd. (viz [jak se rozšiřuje Latte |extending-latte]), a to pomocí jedné opakovatelně použitelné třídy.

Rozšíření tedy vytváříme tehdy, pokud chceme své úpravy Latte znovu použít v různých projektech nebo je sdílet s ostatními.
Je užitečné vytvářet rozšíření pro každý váš webový projekt, které bude obsahovat všechny specifické značky a filtry, které chcete v šablonách projektu využívat.


Rozšíření je třída, která dědí od [Latte\Extension |https://api.nette.org/latte/master/Latte/Extension.html]. Může implementovat kteroukoliv z následujících metod:

```php
abstract class Extension
{
	/**
	 * Initializes before template is compiler.
	 */
	public function beforeCompile(Engine $engine): void;

	/**
	 * Returns a list of parsers for Latte tags.
	 * @return array<string, callable>
	 */
	public function getTags(): array;

	/**
	 * Returns a list of parsers for Latte tags.
	 * @return array<string, callable>
	 */
	public function getPasses(): array;

	/**
	 * Returns a list of |filters.
	 * @return array<string, callable>
	 */
	public function getFilters(): array;

	/**
	 * Returns a list of functions used in templates.
	 * @return array<string, callable>
	 */
	public function getFunctions(): array;

	/**
	 * Returns a list of providers.
	 * @return array<mixed>
	 */
	public function getProviders(): array;

	/**
	 * Returns a value to distinguish multiple versions of the template.
	 */
	public function getCacheKey(Engine $engine): mixed;

	/**
	 * Initializes before template is rendered.
	 */
	public function beforeRender(Engine $engine): void;
}
```

Do Latte se registruje pomocí `addExtension()`:

```php
$latte = new Latte\Engine;
$latte->addExtension(/* ... */);
```

Pokud zaregistrujete víc rozšíření a ty vrátí stejně pojmenované tagy, filtry nebo funkce, vyhrává poslední přidané rozšíření. Jinými slovy, vaše rozšíření přepíše značku/filtr/funkce z nativního "CoreExtension":https://github.com/nette/latte/blob/master/src/Latte/Essential/CoreExtension.php.


beforeCompile(Engine $engine): void .[method]
---------------------------------------------

Volá se na začátku kompilace, tedy když chceme kreslit šablonu co ještě není v cache.


getTags(): array .[method]
--------------------------

Vrací asociativní pole *název tagu => callback*, který značku parsuje. Název může být i 'n:abc', tedy n:attribut:

todo: Priorita


getPasses(): array .[method]
----------------------------

Vrací asociativní pole *název => callback*, což je tzv. node visitor, který po dokončení parsování bude moci upravovat AST strom (tvoří jej tzv. nody).

todo: Priorita


getFilters(): array .[method]
-----------------------------

Vrací asociativní pole *název filtru => callback* se všemi filtry.


getFunctions(): array .[method]
-------------------------------

Vrací asociativní pole *název funkce => callback* se všemi funkcemi.


getProviders(): array .[method]
-------------------------------


getCacheKey(Engine $engine): mixed .[method]
--------------------------------------------


beforeRender(Engine $engine): void .[method]
--------------------------------------------

Volá před každým vykreslením šablony.


How does Latte work?
====================

Callback vrácený `getTags()` je funkce, která má za úkol zpracovat značku, tj. buď `{foo ...}` nebo `n:foo="..."`. Což znamená, že naparsuje a zkontroluje argumenty a vrátí nějaký *node* (potomek "Latte\Compiler\Node":https://github.com/nette/latte/blob/master/src/Latte/Compiler/Node.php), který se stane součástí AST stromu. Jako příklad si můžeme ukázat funkci "zpracovávající značku `{do ...}`":https://github.com/nette/latte/blob/master/src/Latte/Essential/Nodes/DoNode.php#L26-L32. Jako parametr dostává objekt Tag, kde jsou všechny informace o tagu (jestli je to n:attribut nebo ne, na jakém je řádku, přístup k parseru argumentů apod.) a vrací objekt `Latte\Essential\Nodes\DoNode`. Připadalo mi elegantní tyhle funkce umístit přímo nodů, které vracejí, jakožto statické metody (tj. `DoNode::create()`), ale nemusí to tak být, viz funkce pro značky "`{l} a {r}`":https://github.com/nette/latte/blob/master/src/Latte/Essential/CoreExtension.php#L65-L66.

Funkce obvykle volají metody `$tag->expectArguments()` (vyhoď výjimku, pokud značka nemá argumenty), `$tag->parser->parseExpression()` (naparsuj PHP výraz v argumentu), a `$tag->parser->parseFilters()` (naparsuj část s filtry neboli modifikátor).

Pokud je značka párová (`{foo ...} ... {/foo}`), tak funkce navíc udělá to, že předá zpět řízení parseru a nechá ho naparsovat celý vnitřek, který ji poté vrátí, a ona s ním nějak naloží, obvykle uloží do proměnné. Tohle dělá `yield`, "viz třeba tady":https://github.com/nette/latte/blob/master/src/Latte/Essential/Nodes/CaptureNode.php#L46.

Takže výstupem CaptureNode::create() je objekt "CaptureNode":https://github.com/nette/latte/blob/master/src/Latte/Essential/Nodes/CaptureNode.php, který v property `$variable` obsahuje argument (jako objekt ExpressionNode), v property `$filter` použitý filter (jako objekt FilterNode nebo null) a v property `$content` vnitřní obsah (jako objekt AreaNode).

Všechno jsou to Node.

Když po skončení parsování přijde na řadu procházení a úpravy AST stromu (což dělají funkce vrácené z `getPasses()`), a narazí se na tento CaptureNode, ten řekne procházeči, že má pokračovat do hloubky do nodů uložených v properites `$variable`, `$filter` a `$content`. A právě to oznamuje funkce `getIterator()`.

No a nakonec se celý node vykreslí do PHP podoby, což dělá "funkce `print()`":https://github.com/nette/latte/blob/master/src/Latte/Essential/Nodes/CaptureNode.php#L58-L76. K dispozici má objekt `PrintContext`, kde je užitečná metoda "format()":https://github.com/nette/latte/blob/master/src/Latte/Compiler/PrintContext.php#L85, něco jako printf, ale zaměřená pro účely generování PHP kódu.

Ještě se vrátím k tomu yield. Že je značka párová (tedy že funkce používá yield) není potřeba nikde uvádět, protože Latte si to zjistí z reflexe. Yield standardně naparsuje a vrátí celý obsah mezi otevírací a koncovou značkou, ale lze mu také předat jako argument seznam značek, na kterých se má zastavit. Tak třeba v případě `{try} .A. {else} .B. {/try}` "ho necháme zastavit":https://github.com/nette/latte/blob/master/src/Latte/Essential/Nodes/TryNode.php#L28-L37 na `{else}` a vrátit jen část `.A.`. Krom ní vrací i zmíněný objekt Tag, popisovač značky, tentokrát pro značku `{else}` (v kódu `TryNode` se ukládá do proměnné `$nextTag`). Následně se yield volá ještě jednou, aby vrátilo část `.B.`.

Pokud by tam `{else}` nebylo, vrátí první yield celý vnitřek a `$nextTag` bude obsahovat objekt Tag pro koncovou značku `{/try}`. Nebo taky null, pokud `{/try}` neexistuje, třeba když je použito jako atribut `n:try="..."`.





{{composer: latte/latte}}
