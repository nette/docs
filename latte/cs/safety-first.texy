Latte je synonymum bezpečnosti
******************************

<div class=perex>

Latte jako jediný šablonovací systém pro PHP poskytuje účinnou ochranu proti kritické zranitelnosti Cross-site Scripting (XSS). A to díky tzv. kontextově sensitivnímu escapování. Povíme si,

- v čem spočívá XSS a proč je tak nebezpečný
- proč jsou šablony Twig, Blade a spol. slepé a lze v nich snadno udělat bezpečnostní díru
- jak je možné, že je Latte v obraně před XSS tak efektivní

</div>


Cross-site Scripting (XSS)
==========================

Cross-site Scripting (zkráceně XSS) je jednou z nejčastějších zranitelností webových stránek a přitom velmi nebezpečnou. Umožní útočníkovi vložit do cizí stránky škodlivý skript (tzv. malware), který se spustí v prohlížeči nic netušícího uživatele.

Co všechno může takový skript napáchat? Může například odeslat útočníkovi libovolný obsah z napadené stránky, včetně citlivých údajů zobrazených po přihlášení. Může stránku pozměnit nebo provádět další požadavky jménem uživatele.
Pokud by se například jednalo o webmail, může si přečíst citlivé zprávy, pozměnit zobrazovaný obsah nebo přenastavit konfiguraci, např. zapnout přeposílání kopií všech zpráv na útočníkovu adresu, aby získal přístup i k budoucím emailům.

Proto také XSS figuruje na předních místech žebříčků nejnebezpečnějších zranitelností. Pokud se na webové stránce zranitelnost objeví, je nutné ji co nejdříve odstranit, aby se zabránilo zneužití.


Jak zranitelnost vzniká?
------------------------

Chyba vzniká v místě, kde se webová stránka generuje a vypisují se proměnné. Představte si, že vytváříte stránku s vyhledáváním, a na začátku bude odstavec s hledaným výrazem v podobě:

```php
echo '<p>Výsledky vyhledávání pro <em>' . $search . '</em></p>';
```

Útočník může do vyhledávacího políčka a potažmo do proměnné `$search` zapsat libovolný řetězec, tedy i HTML kód jako `<script>alert("Hacked!")</script>`. Protože výstup není nijak ošetřen, stane se součástí zobrazené stránky:

```html
<p>Výsledky vyhledávání pro <em><script>alert("Hacked!")</script></em></p>
```

Prohlížeč místo toho, aby vypsal hledaný řetězec, spustí JavaScript. A tím přebírá vládu nad stránkou útočník.

Můžete namítnout, že vložením kódu do proměnné sice dojde ke spuštění JavaScriptu, ale jen v útočníkově prohlížeči. Jak se dostane k oběti? Z tohoto pohledu rozlišujeme několik typů XSS. V našem příkladu s vyhledáváním hovoříme o *reflected XSS*.
Zde je ještě potřeba navést oběť, aby klikla na odkaz, který bude obsahovat škodlivý kód v parametru:

```
https://example.com/?search=<script>alert("Hacked!")</script>
```

Navedení uživatele na odkaz sice vyžaduje určité sociální inženýrství, ale není to nic složitého. Uživatelé na odkazy, ať už v emailech nebo na sociálních sítích, klikají bez větších rozmyslů. A že je v adrese něco podezřelého se dá zamaskovat pomocí zkracovače URL, uživatel pak vidí jen `bit.ly/xxx`.

Nicméně existuje i druhá a mnohem nebezpečnější forma útoku označovaná jako *stored XSS* nebo *persistent XSS*, kdy se útočníkovi podaří uložit škodlivý kód na server tak, aby byl automaticky vkládán do některých stránek.

Příkladem jsou stránky, kam uživatelé píší komentáře. Útočník pošle příspěvek obsahující kód a ten se uloží na server. Pokud stránky nejsou dostatečně zabezpečené, bude se pak spouštět v prohlížeči každého návštěvníka.

Mohlo by se zdát, že jádro útoku spočívá v tom dostat do stránky řetězec `<script>`. Ve skutečnosti "způsobů vložení JavaScriptu je mnoho":https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html.
Ukážeme si třeba příklad vložení pomocí HTML atributu. Mějme fotogalerii, kde lze vkládat k obrázkům popisek, který se vypíše v atributu `alt`:

```php
echo '<img src="' . $imageFile . '" alt="' . $imageAlt . '">';
```

Útočníkovi stačí jako popisek vložit šikovně sestavený řetězec `" onload="alert('Hacked!')` a když vypsání nebude ošetřeno, výsledný kód bude vypadat takto:

```html
<img src="photo0145.webp" alt="" onload="alert('Hacked!')">
```

Součástí stránky se nyní stává podvržený atribut `onload`. Prohlížeč spustí kód zapsaný v atributu hned jak obrázek stáhne.


Jak se bránit XSS?
------------------

Jakékoliv pokusy útok detekovat pomocí blacklistu, jako například blokovat řetězec `<script>` apod., jsou nedostačující. Základem funkční obrany je **důsledná sanitizace všech dat vypisovaných uvnitř stránky.**

Především jde o nahrazení všech znaků se speciálním významem za jiné odpovídající sekvence, čemuž se slangově říká **escapování** (první znak sekvence se nazývá únikovým, odtud pojmenování).
Třeba v textu HTML má speciální význam znak `<`, který když nemá být interpretován jako začátek tagu, musíme jej nahradit vizuálně odpovídající sekvencí, tzv. HTML entitou `&lt;`.
A prohlížeč vypíše menšítko.

**Velmi důležité je rozlišovat kontext, ve kterém data vypisujeme**. Protože v různých kontextech se řetězce různě sanitizují. A v různých kontextech mohou mít speciální význam různé znaky.
Například se liší escapování v textu HTML, v atributech HTML, uvnitř některých speciálních elementů, v komentářích atd.

Ošetření je nejlepší provádět těsně před vypsáním ve stránce, čímž zajistíme, že se opravdu provede a provede se právě jednou. Nejlepší je, pokud ošetření obstará **automaticky** přímo šablonovací systém.
Protože pokud ošetření neprobíhá automaticky, může na něj programátor zapomenout. A jedno opomenutí znamená, že web je zranitelný.

XSS se netýká jen vypisování dat v šablonách, ale i dalších částí aplikace, které musí správně zacházet s nedůvěryhodnými daty. Například je nutné, aby JavaScript ve vaší aplikaci nepoužíval ve spojitosti s nimi `innerHTML`, ale pouze `innerText` nebo `textContent`.
Speciální pozor je potřeba dávat na funkce, které vyhodnocují řetězce jako JavaScript, což je `eval()`, ale taky `setTimeout()`, případně použití funkce `setAttribute()` s eventovými atributy jako `onload` apod.

**Obrana ve 3 bodech:**

1) musí rozlišovat kontext, ve kterém se data vypisují
2) sanitizuje data podle pravidel daného kontextu (tedy kontextově sensitivně)
3) dělá to automaticky


Kontextově sensitivní escapování
================================

Latte vidí šablonu stejně jako vy. Chápe HTML, rozeznává značky, atributy atd. A díky tomu rozlišuje jednotlivé kontexty a podle nich volí sanitizační funkce. Tomu se právě říká kontextově sensitivní escapování.

Kolik takových kontextů je v samotném HTML? Byli byste překvapeni, ale jsou jich desítky. Tady uvádíme jen část z nich, které Latte rozlišuje při vypsání proměnné `{$text}`:

```php .{file:Latte}
- v textu: <span>{$text}</span>
- v tagu: <span {$text} ></span>
- v atributu: <span title='{$text}'></span>
- v atributu bez uvozovek: <span title={$text}></span>
- v atributu obsahujícím URL: <a href="{$text}"></a>
- v atributu obsahujícím JavaScript: <img onload="{$text}">
- v atributu obsahujícím CSS: <span style="{$text}"></span>
- v JavaScriptu: <script>var = {$text}</script>
- v CSS: <style>body { content: {$text}; }</style>
- v komentáři: <!-- {$text} -->
```

V každém z těchto kontextů se proměnná ošetřuje trošku jiným způsobem. Například zatímco v HTML textu mají speciální význam znaky `<` a `&`, v HTML komentáři je tomu úplně jinak a je třeba dodržet "specifická pravidla":https://html.spec.whatwg.org/multipage/syntax.html#comments.
Liší se také escapování v HTML a XML. Atd. V příkladech níže najdete celou řadu ukázek, jak Latte znalosti kontextu využívá.


Cesta slepých ptáků
-------------------

Ačkoliv rozlišování kontextu je nezbytným předpokladem obrany před XSS, **Latte je jediný šablonovací systém pro PHP, který to umí.** Jak tedy funguje automatické escapování v ostatních systémemch?

Šablonovací systémy, jako je Twig, Laravel Blade a další, nevidí v šabloně žádnou HTML strukturu. Nevidí tudíž ani kontexty. Oproti Latte jsou slepé. Zpracovávají jen vlastní značky, vše ostatní je pro ně nepodstatný tok znaků:

<div class="juxtapose juxtapose--dark-handle" data-startingposition="80" data-animation="juxtapose-wiper">

```twig .{file:Twig šablona, jak ji vidí samotný Twig}
░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░
░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░{{ text }}░░░░
```

```twig .{file:Twig šablona, jak ji vidí designer}
- v textu: <span>{{ text }}</span>
- v tagu: <span {{ text }} ></span>
- v atributu: <span title='{{ text }}'></span>
- v atributu bez uvozovek: <span title={{ text }}></span>
- v atributu obsahujícím URL: <a href="{{ text }}"></a>
- v atributu obsahujícím JavaScript: <img onload="{{ text }}">
- v atributu obsahujícím CSS: <span style="{{ text }}"></span>
- v JavaScriptu: <script>var = {{ text }}</script>
- v CSS: <style>body { content: {{ text }}; }</style>
- v komentáři: <!-- {{ text }} -->
```

</div>

Automatické escapování bez znalosti kontextu je bullshit, který **vytváří falešný dojem bezpečí**.

Slepé systémy jen mechanicky převádějí znaky `< > & ' "` na HTML entity, což je sice ve většině případů užití platný způsob escapování, ale zdaleka ne vždy. Nemohou odhalit ani zabránit vzniku různých bezpečnostní děr, jak si ukážeme dále.


Jak hacknout slepé systémy
==========================

Na několika praktických příkladech si ukážeme, jak je rozlišování kontextů důležité a proč slepé šablonovací systémy neposkytují dostatečnou ochranu před XSS, na rozdíl od Latte.
Jako zástupce slepého systému použijeme v ukázkách Twig, ale totéž platí i pro ostatní systémy.


Zranitelnost atributem
----------------------

Pokusíme se do stránky injektovat škodlivý kód pomocí HTML atributu, jak jsme si [ukazovali výše|#Jak zranitelnost vzniká]. Mějme šablonu v Twigu vykreslující obrázek:

```twig .{file:Twig}
<img src={{ imageFile }} alt={{ imageAlt }}>
```

Všimněte si, že okolo hodnot atributů nejsou uvozovky. Kodér na ně mohl zapomenout, což se prostě stává. Například v Reactu se kód píše takto, bez uvozovek, a kodér, který střídá jazyky, pak na uvozovky může snadno zapomenout.

Útočník jako popisek obrázku vloží šikovně sestavený řetězec `foo onload=alert('Hacked!')`. Už víme, že Twig nemůže poznat, jestli se proměnná vypisuje v toku HTML textu, uvnitř atributu, HTML komentáře, atd., zkrátka nerozlišuje kontexty. A jen mechanicky převádí znaky `< > & ' "` na HTML entity.
Takže výsledný kód bude vypadat takto:

```html
<img src=photo0145.webp alt=foo onload=alert(&#039;Hacked!&#039;)>
```

**A vznikla bezpečností díra!**

Součástí stránky se stal podvržený atribut `onload` a prohlížeč ihned po stažení obrázku jej spustí.

Nyní se podíváme, jak si se stejnou šablonou poradí Latte:

```latte .{file:Latte}
<img src={$imageFile} alt={$imageAlt}>
```

Latte vidí šablonu stejně jako vy. Na rozdíl od Twigu chápe HTML a ví, že proměnná se vypisuje jako hodnota atributu, který není v uvozovkách. Proto je doplní. Když útočník vloží stejný popisek, výsledný kód bude vypadat takto:

```html
<img src="photo0145.webp" alt="foo onload=alert(&apos;Hacked!&apos;)">
```

**Latte úspěšně zabránilo XSS.**


Vypsání proměnné v JavaScript
-----------------------------

Díky kontextově sensitivnímu escapování je možné zcela nativně používat PHP proměnné uvnitř JavaScriptu.

```latte
<p onclick="alert({$movie})">{$movie}</p>

<script>var movie = {$movie};</script>
```

Pokud bude proměnná `$movie` obsahovat řetězec `'Amarcord & 8 1/2'`, vygeneruje se následující výstup. Všimněte si, že uvnitř HTML se použije jiné escapování, než uvnitř JavaScriptu a ještě jiné v atributu `onclick`:

```latte
<p onclick="alert(&quot;Amarcord &amp; 8 1\/2&quot;)">Amarcord &amp; 8 1/2</p>

<script>var movie = "Amarcord & 8 1\/2";</script>
```


Kontrola odkazů
---------------

Latte automaticky kontroluje, zda proměnná použitá v atributech `src` nebo `href` obsahuje webovou URL (tj. protokol HTTP) a předchází vypsání odkazů, které mohou představovat bezpečnostní riziko.

```latte
{var $link = 'javascript:attack()'}

<a href="{$link}">klikni</a>
```

Vypíše:

```latte
<a href="">klikni</a>
```

Kontrola se dá vypnout pomocí filtru [nocheck|filters#nocheck].
