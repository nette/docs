Stan globalny i singletony
**************************

.[perex]
OstrzeÅ¼enie: PoniÅ¼sze konstrukcje sÄ… objawami Åºle zaprojektowanego kodu:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` lub `static::$var`

Czy napotkaÅ‚eÅ› ktÃ³rÄ…Å› z tych konstrukcji w swoim kodzie? JeÅ›li tak, to masz okazjÄ™ je poprawiÄ‡. MoÅ¼na by pomyÅ›leÄ‡, Å¼e sÄ… to powszechne konstrukcje, czÄ™sto spotykane w przykÅ‚adowych rozwiÄ…zaniach rÃ³Å¼nych bibliotek i frameworkÃ³w. JeÅ›li tak jest, ich projekt kodu jest wadliwy.

Nie mÃ³wimy tutaj o jakiejÅ› akademickiej czystoÅ›ci. Wszystkie te konstrukcje majÄ… jednÄ… wspÃ³lnÄ… cechÄ™: wykorzystujÄ… stan globalny. Ma to destrukcyjny wpÅ‚yw na jakoÅ›Ä‡ kodu. Klasy wprowadzajÄ… w bÅ‚Ä…d co do swoich zaleÅ¼noÅ›ci. Kod staje siÄ™ nieprzewidywalny. Dezorientuje to programistÃ³w i zmniejsza ich wydajnoÅ›Ä‡.

W tym rozdziale wyjaÅ›nimy, dlaczego tak siÄ™ dzieje i jak uniknÄ…Ä‡ stanu globalnego.


Globalne powiÄ…zania .[#toc-global-interlinking]
-----------------------------------------------

W idealnym Å›wiecie obiekt powinien komunikowaÄ‡ siÄ™ tylko z obiektami, ktÃ³re zostaÅ‚y [mu bezpoÅ›rednio przekazane |passing-dependencies]. JeÅ›li utworzÄ™ dwa obiekty `A` i `B` i nigdy nie przekaÅ¼Ä™ miÄ™dzy nimi referencji, to ani `A`, ani `B` nie bÄ™dÄ… mogÅ‚y uzyskaÄ‡ dostÄ™pu do stanu drugiego obiektu ani go zmodyfikowaÄ‡. Jest to bardzo poÅ¼Ä…dana wÅ‚aÅ›ciwoÅ›Ä‡ kodu. Przypomina to posiadanie baterii i Å¼arÃ³wki; Å¼arÃ³wka nie zaÅ›wieci siÄ™, dopÃ³ki nie poÅ‚Ä…czysz jej z bateriÄ… za pomocÄ… przewodu.

Nie dotyczy to jednak zmiennych globalnych (statycznych) lub singletonÃ³w. Obiekt `A` moÅ¼e *bezprzewodowo* uzyskaÄ‡ dostÄ™p do obiektu `C` i zmodyfikowaÄ‡ go bez przekazywania referencji, poprzez wywoÅ‚anie `C::changeSomething()`. JeÅ›li obiekt `B` ma rÃ³wnieÅ¼ dostÄ™p do globalnego `C`, to `A` i `B` mogÄ… wpÅ‚ywaÄ‡ na siebie nawzajem poprzez `C`.

UÅ¼ywanie zmiennych globalnych wprowadza nowÄ… formÄ™ *bezprzewodowego* sprzÄ™Å¼enia, ktÃ³re nie jest widoczne z zewnÄ…trz. Tworzy to zasÅ‚onÄ™ dymnÄ…, ktÃ³ra komplikuje zrozumienie i uÅ¼ywanie kodu. Aby naprawdÄ™ zrozumieÄ‡ zaleÅ¼noÅ›ci, programiÅ›ci muszÄ… przeczytaÄ‡ kaÅ¼dÄ… linijkÄ™ kodu ÅºrÃ³dÅ‚owego, a nie tylko zapoznaÄ‡ siÄ™ z interfejsami klas. Co wiÄ™cej, to uwikÅ‚anie jest caÅ‚kowicie niepotrzebne. Stan globalny jest uÅ¼ywany, poniewaÅ¼ jest Å‚atwo dostÄ™pny z dowolnego miejsca i umoÅ¼liwia, na przykÅ‚ad, zapis do bazy danych za pomocÄ… globalnej (statycznej) metody `DB::insert()`. Jednak, jak zobaczymy, korzyÅ›ci, jakie oferuje, sÄ… minimalne, podczas gdy komplikacje, ktÃ³re wprowadza, sÄ… powaÅ¼ne.

.[note]
Pod wzglÄ™dem zachowania nie ma rÃ³Å¼nicy miÄ™dzy zmiennÄ… globalnÄ… a statycznÄ…. SÄ… one rÃ³wnie szkodliwe.


Upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡ .[#toc-the-spooky-action-at-a-distance]
----------------------------------------------------------------------

"Upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡" - tak Albert Einstein nazwaÅ‚ sÅ‚ynne zjawisko w fizyce kwantowej, ktÃ³re w 1935 roku przyprawiÅ‚o go o dreszcze.
Chodzi o splÄ…tanie kwantowe, ktÃ³rego osobliwoÅ›Ä‡ polega na tym, Å¼e gdy mierzymy informacjÄ™ o jednej czÄ…stce, natychmiast wpÅ‚ywamy na innÄ… czÄ…stkÄ™, nawet jeÅ›li sÄ… one oddalone od siebie o miliony lat Å›wietlnych.
Co pozornie narusza podstawowe prawo wszechÅ›wiata, Å¼e nic nie moÅ¼e podrÃ³Å¼owaÄ‡ szybciej niÅ¼ Å›wiatÅ‚o.

W Å›wiecie oprogramowania "upiornym dziaÅ‚aniem na odlegÅ‚oÅ›Ä‡" moÅ¼emy nazwaÄ‡ sytuacjÄ™, w ktÃ³rej uruchamiamy proces, o ktÃ³rym myÅ›limy, Å¼e jest izolowany (bo nie przekazaliÅ›my mu Å¼adnych referencji), ale nieoczekiwane interakcje i zmiany stanu zachodzÄ… w odlegÅ‚ych miejscach systemu, o ktÃ³rych nie powiedzieliÅ›my obiektowi. MoÅ¼e to nastÄ…piÄ‡ tylko poprzez stan globalny.

WyobraÅº sobie, Å¼e doÅ‚Ä…czasz do zespoÅ‚u rozwijajÄ…cego projekt, ktÃ³ry ma duÅ¼Ä…, dojrzaÅ‚Ä… bazÄ™ kodu. TwÃ³j nowy lider prosi ciÄ™ o wdroÅ¼enie nowej funkcji i, jak dobry deweloper, zaczynasz od napisania testu. Ale poniewaÅ¼ jesteÅ› nowy w projekcie, robisz wiele testÃ³w eksploracyjnych "co siÄ™ stanie, jeÅ›li zadzwoniÄ™ do tej metody" typu. I prÃ³bujesz napisaÄ‡ nastÄ™pujÄ…cy test:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // numer karty
	$cc->charge(100);
}
```

Uruchamiasz kod, moÅ¼e kilka razy, i po jakimÅ› czasie zauwaÅ¼asz na swoim telefonie powiadomienia z banku, Å¼e przy kaÅ¼dym uruchomieniu 100$ zostaÅ‚o pobrane z Twojej karty kredytowej ğŸ¤¦â€â™‚ï¸

Jak u licha test mÃ³gÅ‚ spowodowaÄ‡ faktyczne obciÄ…Å¼enie? Nie jest Å‚atwo operowaÄ‡ kartÄ… kredytowÄ…. Musisz wejÅ›Ä‡ w interakcjÄ™ z usÅ‚ugÄ… internetowÄ… strony trzeciej, musisz znaÄ‡ adres URL tej usÅ‚ugi internetowej, musisz siÄ™ zalogowaÄ‡ i tak dalej.
Å»adna z tych informacji nie jest zawarta w teÅ›cie. Co gorsza, nie wiesz nawet, gdzie te informacje sÄ… obecne, a zatem jak kpiÄ‡ z zewnÄ™trznych zaleÅ¼noÅ›ci, aby kaÅ¼dy bieg nie powodowaÅ‚ ponownego naliczania 100 USD. A jako nowy deweloper, jak miaÅ‚eÅ› wiedzieÄ‡, Å¼e to, co zamierzasz zrobiÄ‡, doprowadzi do tego, Å¼e bÄ™dziesz uboÅ¼szy o 100 dolarÃ³w?

To jest upiorne dziaÅ‚anie na odlegÅ‚oÅ›Ä‡!

Nie masz wyboru, musisz przekopaÄ‡ siÄ™ przez wiele kodu ÅºrÃ³dÅ‚owego, pytajÄ…c starszych i bardziej doÅ›wiadczonych kolegÃ³w, aÅ¼ zrozumiesz, jak dziaÅ‚ajÄ… poÅ‚Ä…czenia w projekcie.
Wynika to z faktu, Å¼e patrzÄ…c na interfejs klasy `CreditCard`, nie moÅ¼na okreÅ›liÄ‡ stanu globalnego, ktÃ³ry musi zostaÄ‡ zainicjalizowany. Nawet patrzÄ…c na kod ÅºrÃ³dÅ‚owy klasy nie dowiesz siÄ™, ktÃ³rÄ… metodÄ™ inicjalizacji naleÅ¼y wywoÅ‚aÄ‡. W najlepszym przypadku moÅ¼esz znaleÅºÄ‡ zmiennÄ… globalnÄ…, do ktÃ³rej uzyskuje siÄ™ dostÄ™p, i sprÃ³bowaÄ‡ zgadnÄ…Ä‡, jak jÄ… zainicjalizowaÄ‡ z tego.

Klasy w takim projekcie sÄ… patologicznymi kÅ‚amcami. Karta pÅ‚atnicza udaje, Å¼e moÅ¼na jÄ… po prostu zainicjowaÄ‡ i wywoÅ‚aÄ‡ metodÄ™ `charge()`. Jednak potajemnie wspÃ³Å‚dziaÅ‚a z innÄ… klasÄ…, `PaymentGateway`. Nawet jej interfejs mÃ³wi, Å¼e moÅ¼e byÄ‡ inicjalizowana niezaleÅ¼nie, ale w rzeczywistoÅ›ci Å›ciÄ…ga poÅ›wiadczenia z jakiegoÅ› pliku konfiguracyjnego i tak dalej.
Dla programistÃ³w, ktÃ³rzy napisali ten kod, jest jasne, Å¼e `CreditCard` potrzebuje `PaymentGateway`. Napisali kod w ten sposÃ³b. Ale dla kaÅ¼dego nowego w projekcie jest to kompletna tajemnica i utrudnia naukÄ™.

Jak naprawiÄ‡ tÄ™ sytuacjÄ™? Åatwo. **PozwÃ³l API zadeklarowaÄ‡ zaleÅ¼noÅ›ci**.

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

ZauwaÅ¼, jak zaleÅ¼noÅ›ci wewnÄ…trz kodu sÄ… nagle oczywiste. DeklarujÄ…c, Å¼e metoda `charge()` potrzebuje `PaymentGateway`, nie musisz nikogo pytaÄ‡, w jaki sposÃ³b kod jest wspÃ³Å‚zaleÅ¼ny. Wiesz, Å¼e musisz stworzyÄ‡ jego instancjÄ™, a kiedy prÃ³bujesz to zrobiÄ‡, natrafiasz na fakt, Å¼e musisz dostarczyÄ‡ parametry dostÄ™pu. Bez nich kod nawet by siÄ™ nie uruchomiÅ‚.

I co najwaÅ¼niejsze, moÅ¼esz teraz kpiÄ‡ z bramki pÅ‚atnoÅ›ci, wiÄ™c nie zostaniesz obciÄ…Å¼ony 100 $ za kaÅ¼dym razem, gdy uruchomisz test.

Stan globalny powoduje, Å¼e twoje obiekty mogÄ… potajemnie uzyskaÄ‡ dostÄ™p do rzeczy, ktÃ³re nie sÄ… zadeklarowane w ich interfejsach API, a w rezultacie czyni twoje interfejsy API patologicznymi kÅ‚amcami.

ByÄ‡ moÅ¼e wczeÅ›niej nie myÅ›laÅ‚eÅ› o tym w ten sposÃ³b, ale zawsze, gdy uÅ¼ywasz stanu globalnego, tworzysz tajne kanaÅ‚y komunikacji bezprzewodowej. PrzeraÅ¼ajÄ…ce zdalne dziaÅ‚anie zmusza programistÃ³w do czytania kaÅ¼dej linijki kodu, aby zrozumieÄ‡ potencjalne interakcje, zmniejsza produktywnoÅ›Ä‡ programistÃ³w i dezorientuje nowych czÅ‚onkÃ³w zespoÅ‚u.
JeÅ›li jesteÅ› tym, ktÃ³ry stworzyÅ‚ kod, znasz prawdziwe zaleÅ¼noÅ›ci, ale kaÅ¼dy, kto przyjdzie po tobie, nie ma pojÄ™cia.

Nie pisz kodu, ktÃ³ry uÅ¼ywa globalnego stanu, wolÄ… przekazaÄ‡ zaleÅ¼noÅ›ci. To jest zastrzyk zaleÅ¼noÅ›ci.


KruchoÅ›Ä‡ globalnego paÅ„stwa .[#toc-brittleness-of-the-global-state]
-------------------------------------------------------------------

W kodzie, ktÃ³ry uÅ¼ywa stanu globalnego i singletonÃ³w, nigdy nie ma pewnoÅ›ci, kiedy i przez kogo ten stan zostaÅ‚ zmieniony. To ryzyko pojawia siÄ™ juÅ¼ podczas inicjalizacji. PoniÅ¼szy kod ma za zadanie utworzyÄ‡ poÅ‚Ä…czenie z bazÄ… danych i zainicjalizowaÄ‡ bramkÄ™ pÅ‚atniczÄ…, ale ciÄ…gle rzuca wyjÄ…tek, a znalezienie przyczyny jest niezwykle Å¼mudne:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

Musisz szczegÃ³Å‚owo przejrzeÄ‡ kod, aby znaleÅºÄ‡, Å¼e obiekt `PaymentGateway` uzyskuje dostÄ™p do innych obiektÃ³w bezprzewodowo, z ktÃ³rych niektÃ³re wymagajÄ… poÅ‚Ä…czenia z bazÄ… danych. Musisz wiÄ™c zainicjalizowaÄ‡ bazÄ™ danych przed `PaymentGateway`. Jednak zasÅ‚ona dymna stanu globalnego ukrywa to przed tobÄ…. Ile czasu zaoszczÄ™dziÅ‚byÅ›, gdyby API kaÅ¼dej klasy nie kÅ‚amaÅ‚o i nie deklarowaÅ‚o swoich zaleÅ¼noÅ›ci?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Podobny problem pojawia siÄ™ podczas korzystania z globalnego dostÄ™pu do poÅ‚Ä…czenia z bazÄ… danych:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

Podczas wywoÅ‚ywania metody `save()` nie ma pewnoÅ›ci, czy poÅ‚Ä…czenie z bazÄ… danych zostaÅ‚o juÅ¼ utworzone i kto jest odpowiedzialny za jego utworzenie. Na przykÅ‚ad, gdybyÅ›my chcieli zmieniÄ‡ poÅ‚Ä…czenie z bazÄ… danych w locie, byÄ‡ moÅ¼e w celach testowych, prawdopodobnie musielibyÅ›my stworzyÄ‡ dodatkowe metody, takie jak `DB::reconnect(...)` lub `DB::reconnectForTest()`.

RozwaÅ¼my przykÅ‚ad:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

SkÄ…d moÅ¼emy mieÄ‡ pewnoÅ›Ä‡, Å¼e testowa baza danych jest naprawdÄ™ uÅ¼ywana podczas wywoÅ‚ywania metody `$article->save()`? Co by byÅ‚o, gdyby metoda `Foo::doSomething()` zmieniÅ‚a globalne poÅ‚Ä…czenie z bazÄ… danych? Aby siÄ™ tego dowiedzieÄ‡, musielibyÅ›my zbadaÄ‡ kod ÅºrÃ³dÅ‚owy klasy `Foo` i prawdopodobnie wielu innych klas. Jednak takie podejÅ›cie daÅ‚oby tylko krÃ³tkotrwaÅ‚Ä… odpowiedÅº, poniewaÅ¼ sytuacja moÅ¼e siÄ™ zmieniÄ‡ w przyszÅ‚oÅ›ci.

Co by siÄ™ staÅ‚o, gdybyÅ›my przenieÅ›li poÅ‚Ä…czenie z bazÄ… danych do zmiennej statycznej wewnÄ…trz klasy `Article`?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

To w ogÃ³le niczego nie zmienia. Problem jest stanem globalnym i nie ma znaczenia, w ktÃ³rej klasie siÄ™ ukrywa. W tym przypadku, podobnie jak w poprzednim, nie mamy pojÄ™cia, do jakiej bazy danych jest zapisywana w momencie wywoÅ‚ania metody `$article->save()`. Ktokolwiek na odlegÅ‚ym koÅ„cu aplikacji mÃ³gÅ‚by w kaÅ¼dej chwili zmieniÄ‡ bazÄ™ danych za pomocÄ… `Article::setDb()`. Pod naszymi rÄ™kami.

Stan globalny sprawia, Å¼e nasza aplikacja jest **ekstremalnie krucha**.

Istnieje jednak prosty sposÃ³b na poradzenie sobie z tym problemem. Wystarczy kazaÄ‡ API zadeklarowaÄ‡ zaleÅ¼noÅ›ci, aby zapewniÄ‡ odpowiedniÄ… funkcjonalnoÅ›Ä‡.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Takie podejÅ›cie eliminuje obawy o ukryte i nieoczekiwane zmiany w poÅ‚Ä…czeniach z bazÄ… danych. Teraz mamy pewnoÅ›Ä‡, gdzie przechowywany jest artykuÅ‚ i Å¼adne modyfikacje kodu wewnÄ…trz innej niepowiÄ…zanej klasy nie mogÄ… juÅ¼ zmieniÄ‡ sytuacji. Kod nie jest juÅ¼ kruchy, ale stabilny.

Nie pisz kodu, ktÃ³ry korzysta z globalnego stanu, wolisz przekazaÄ‡ zaleÅ¼noÅ›ci. A wiÄ™c dependency injection.


Singleton .[#toc-singleton]
---------------------------

Singleton to wzorzec projektowy, ktÃ³ry z [definicji |https://en.wikipedia.org/wiki/Singleton_pattern] ze sÅ‚ynnej publikacji Gang of Four ogranicza klasÄ™ do pojedynczej instancji i oferuje do niej globalny dostÄ™p. Implementacja tego wzorca zazwyczaj przypomina nastÄ™pujÄ…cy kod:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// oraz inne metody realizujÄ…ce funkcje klasy
}
```

Niestety, singleton wprowadza do aplikacji stan globalny. A jak pokazaliÅ›my powyÅ¼ej, stan globalny jest niepoÅ¼Ä…dany. Dlatego wÅ‚aÅ›nie singleton jest uwaÅ¼any za antypattern.

Nie uÅ¼ywaj singletonÃ³w w swoim kodzie i zastÄ…p je innymi mechanizmami. NaprawdÄ™ nie potrzebujesz singletonÃ³w. JeÅ›li jednak musisz zagwarantowaÄ‡ istnienie pojedynczej instancji klasy dla caÅ‚ej aplikacji, zostaw to [kontenerowi DI |container].
W ten sposÃ³b utwÃ³rz singleton aplikacji, czyli usÅ‚ugÄ™. DziÄ™ki temu klasa przestanie zapewniaÄ‡ wÅ‚asnÄ… unikalnoÅ›Ä‡ (tzn. Nie bÄ™dzie miaÅ‚a metody `getInstance()` i zmiennej statycznej) i bÄ™dzie wykonywaÄ‡ tylko swoje funkcje. Tym samym przestanie naruszaÄ‡ zasadÄ™ pojedynczej odpowiedzialnoÅ›ci.


Stan globalny a testy .[#toc-global-state-versus-tests]
-------------------------------------------------------

PiszÄ…c testy, zakÅ‚adamy, Å¼e kaÅ¼dy test jest izolowanÄ… jednostkÄ… i Å¼e nie wchodzi do niego Å¼aden zewnÄ™trzny stan. I Å¼aden stan nie opuszcza testÃ³w. Kiedy test siÄ™ koÅ„czy, wszelkie stany zwiÄ…zane z testem powinny byÄ‡ automatycznie usuwane przez garbage collector. To sprawia, Å¼e testy sÄ… odizolowane. Dlatego moÅ¼emy uruchamiaÄ‡ testy w dowolnej kolejnoÅ›ci.

JednakÅ¼e, jeÅ›li obecne sÄ… globalne stany/singletony, wszystkie te miÅ‚e zaÅ‚oÅ¼enia ulegajÄ… zaÅ‚amaniu. Stan moÅ¼e wejÅ›Ä‡ i wyjÅ›Ä‡ z testu. Nagle okazuje siÄ™, Å¼e kolejnoÅ›Ä‡ wykonywania testÃ³w moÅ¼e mieÄ‡ znaczenie.

Aby w ogÃ³le testowaÄ‡ singletony, programiÅ›ci czÄ™sto muszÄ… rozluÅºniÄ‡ ich wÅ‚aÅ›ciwoÅ›ci, byÄ‡ moÅ¼e pozwalajÄ…c na zastÄ…pienie jednej instancji innÄ…. Takie rozwiÄ…zania sÄ… w najlepszym wypadku hackami, ktÃ³re produkujÄ… kod trudny do utrzymania i zrozumienia. KaÅ¼dy test lub metoda `tearDown()`, ktÃ³ra wpÅ‚ywa na jakikolwiek stan globalny, musi cofnÄ…Ä‡ te zmiany.

Globalny stan jest najwiÄ™kszym bÃ³lem gÅ‚owy w testach jednostkowych!

Jak naprawiÄ‡ tÄ™ sytuacjÄ™? Proste. Nie pisz kodu, ktÃ³ry uÅ¼ywa singletonÃ³w, wolisz przekazywaÄ‡ zaleÅ¼noÅ›ci. Czyli dependency injection.


StaÅ‚e globalne .[#toc-global-constants]
---------------------------------------

Stan globalny nie jest ograniczony do uÅ¼ywania singletonÃ³w i zmiennych statycznych, ale moÅ¼e rÃ³wnieÅ¼ dotyczyÄ‡ staÅ‚ych globalnych.

StaÅ‚e, ktÃ³rych wartoÅ›Ä‡ nie dostarcza nam Å¼adnych nowych (`M_PI`) lub uÅ¼ytecznych (`PREG_BACKTRACK_LIMIT_ERROR`) informacji sÄ… oczywiÅ›cie OK.
I odwrotnie, staÅ‚e, ktÃ³re sÅ‚uÅ¼Ä… jako sposÃ³b na *bezprzewodowe* przekazywanie informacji wewnÄ…trz kodu, sÄ… niczym wiÄ™cej niÅ¼ ukrytÄ… zaleÅ¼noÅ›ciÄ…. Jak `LOG_FILE` w poniÅ¼szym przykÅ‚adzie.
UÅ¼ywanie staÅ‚ej `FILE_APPEND` jest caÅ‚kowicie poprawne.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

W tym przypadku powinniÅ›my zadeklarowaÄ‡ parametr w konstruktorze klasy `Foo`, aby uczyniÄ‡ go czÄ™Å›ciÄ… interfejsu API:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Teraz moÅ¼emy przekazaÄ‡ informacjÄ™ o Å›cieÅ¼ce do pliku logowania i Å‚atwo jÄ… zmieniÄ‡ w razie potrzeby, co uÅ‚atwi testowanie i utrzymanie kodu.


Funkcje globalne i metody statyczne .[#toc-global-functions-and-static-methods]
-------------------------------------------------------------------------------

Chcemy podkreÅ›liÄ‡, Å¼e uÅ¼ywanie metod statycznych i funkcji globalnych samo w sobie nie jest problematyczne. WyjaÅ›niliÅ›my niewÅ‚aÅ›ciwoÅ›Ä‡ uÅ¼ywania `DB::insert()` i podobnych metod, ale zawsze chodziÅ‚o o stan globalny przechowywany w zmiennej statycznej. Metoda `DB::insert()` wymaga istnienia zmiennej statycznej, poniewaÅ¼ przechowuje ona poÅ‚Ä…czenie z bazÄ… danych. Bez tej zmiennej implementacja metody byÅ‚aby niemoÅ¼liwa.

Stosowanie deterministycznych metod i funkcji statycznych, takich jak `DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` i wielu innych, jest doskonale zgodne z wstrzykiwaniem zaleÅ¼noÅ›ci. Funkcje te zawsze zwracajÄ… te same wyniki z tych samych parametrÃ³w wejÅ›ciowych i dlatego sÄ… przewidywalne. Nie uÅ¼ywajÄ… one Å¼adnego stanu globalnego.

W PHP istniejÄ… jednak funkcje, ktÃ³re nie sÄ… deterministyczne. NaleÅ¼y do nich na przykÅ‚ad funkcja `htmlspecialchars()`. Jej trzeci parametr, `$encoding`, jeÅ›li nie zostanie okreÅ›lony, domyÅ›lnie przyjmuje wartoÅ›Ä‡ opcji konfiguracyjnej `ini_get('default_charset')`. Dlatego zaleca siÄ™ zawsze podawaÄ‡ ten parametr, aby uniknÄ…Ä‡ ewentualnego nieprzewidywalnego zachowania funkcji. Nette konsekwentnie to robi.

NiektÃ³re funkcje, takie jak `strtolower()`, `strtoupper()`, i tym podobne, miaÅ‚y w niedawnej przeszÅ‚oÅ›ci niedeterministyczne zachowanie i zaleÅ¼aÅ‚y od ustawienia `setlocale()`. PowodowaÅ‚o to wiele komplikacji, najczÄ™Å›ciej podczas pracy z jÄ™zykiem tureckim.
Dzieje siÄ™ tak dlatego, Å¼e jÄ™zyk turecki rozrÃ³Å¼nia duÅ¼e i maÅ‚e litery `I` z i bez kropki. Tak wiÄ™c `strtolower('I')` zwracaÅ‚ znak `Ä±`, a `strtoupper('i')` zwracaÅ‚ znak `Ä°`, co prowadziÅ‚o do aplikacji powodujÄ…cych wiele tajemniczych bÅ‚Ä™dÃ³w.
Jednak ten problem zostaÅ‚ naprawiony w PHP w wersji 8.2 i funkcje nie sÄ… juÅ¼ zaleÅ¼ne od locale.

Jest to Å‚adny przykÅ‚ad tego, jak stan globalny nÄ™kaÅ‚ tysiÄ…ce programistÃ³w na caÅ‚ym Å›wiecie. RozwiÄ…zaniem byÅ‚o zastÄ…pienie go zastrzykiem zaleÅ¼noÅ›ci.


Kiedy moÅ¼na uÅ¼yÄ‡ stanu globalnego? .[#toc-when-is-it-possible-to-use-global-state]
----------------------------------------------------------------------------------

IstniejÄ… pewne specyficzne sytuacje, w ktÃ³rych moÅ¼liwe jest uÅ¼ycie stanu globalnego. Na przykÅ‚ad, gdy debugujemy kod i musimy zrzuciÄ‡ wartoÅ›Ä‡ zmiennej lub zmierzyÄ‡ czas trwania okreÅ›lonej czÄ™Å›ci programu. W takich przypadkach, ktÃ³re dotyczÄ… dziaÅ‚aÅ„ tymczasowych, ktÃ³re pÃ³Åºniej zostanÄ… usuniÄ™te z kodu, uzasadnione jest uÅ¼ycie dostÄ™pnego globalnie dumpera lub stopera. NarzÄ™dzia te nie sÄ… czÄ™Å›ciÄ… projektu kodu.

Innym przykÅ‚adem sÄ… funkcje do pracy z wyraÅ¼eniami regularnymi `preg_*`, ktÃ³re wewnÄ™trznie przechowujÄ… skompilowane wyraÅ¼enia regularne w statycznej pamiÄ™ci podrÄ™cznej w pamiÄ™ci. Gdy wywoÅ‚ujesz to samo wyraÅ¼enie regularne wiele razy w rÃ³Å¼nych czÄ™Å›ciach kodu, jest ono kompilowane tylko raz. Cache oszczÄ™dza wydajnoÅ›Ä‡, a takÅ¼e jest caÅ‚kowicie niewidoczny dla uÅ¼ytkownika, wiÄ™c takie uÅ¼ycie moÅ¼na uznaÄ‡ za uzasadnione.


Podsumowanie .[#toc-summary]
----------------------------

PokazaliÅ›my, dlaczego to ma sens

1) UsuÅ„ z kodu wszystkie zmienne statyczne
2) ZadeklarowaÄ‡ zaleÅ¼noÅ›ci
3) I uÅ¼ywaÄ‡ zastrzyku zaleÅ¼noÅ›ci

RozwaÅ¼ajÄ…c projekt kodu, pamiÄ™taj, Å¼e kaÅ¼dy `static $foo` reprezentuje problem. Aby twÃ³j kod byÅ‚ Å›rodowiskiem respektujÄ…cym DI, konieczne jest caÅ‚kowite wyeliminowanie stanu globalnego i zastÄ…pienie go zastrzykiem zaleÅ¼noÅ›ci.

Podczas tego procesu moÅ¼e siÄ™ okazaÄ‡, Å¼e musisz podzieliÄ‡ klasÄ™, poniewaÅ¼ ma ona wiÄ™cej niÅ¼ jednÄ… odpowiedzialnoÅ›Ä‡. Nie przejmuj siÄ™ tym; dÄ…Å¼ do zasady jednej odpowiedzialnoÅ›ci.

*ChciaÅ‚bym podziÄ™kowaÄ‡ MiÅ¡ko Hevery'emu, ktÃ³rego artykuÅ‚y takie jak [Flaw: Brittle Global State & Singletons |http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] stanowiÄ… podstawÄ™ tego rozdziaÅ‚u.*
