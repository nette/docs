Bootstrap
*********

<div class=perex>

Bootstrap este codul de pornire care iniÈ›ializeazÄƒ mediul, creeazÄƒ un container de injecÈ›ie a dependenÈ›elor (DI) È™i porneÈ™te aplicaÈ›ia. Vom discuta despre:

- cum sÄƒ vÄƒ configuraÈ›i aplicaÈ›ia utilizÃ¢nd fiÈ™iere NEON
- cum sÄƒ gestionaÈ›i modurile de producÈ›ie È™i de dezvoltare
- cum sÄƒ creaÈ›i containerul DI

</div>


AplicaÈ›iile, fie cÄƒ sunt bazate pe web sau scripturi Ã®n linie de comandÄƒ, Ã®ncep printr-o anumitÄƒ formÄƒ de iniÈ›ializare a mediului. Ãn vremurile vechi, putea fi un fiÈ™ier numit eg `include.inc.php` care se ocupa de acest lucru È™i care era inclus Ã®n fiÈ™ierul iniÈ›ial.
Ãn aplicaÈ›iile moderne Nette, acesta a fost Ã®nlocuit de clasa `Bootstrap`, care, ca parte a aplicaÈ›iei, poate fi gÄƒsitÄƒ Ã®n fiÈ™ierul `app/Bootstrap.php`. Acesta ar putea arÄƒta de exemplu astfel:

```php
use Nette\Bootstrap\Configurator;

class Bootstrap
{
	private Configurator $configurator;
	private string $rootDir;

	public function __construct()
	{
		$this->rootDir = dirname(__DIR__);
		// Configuratorul este responsabil de configurarea mediului È™i a serviciilor aplicaÈ›iei.
		$this->configurator = new Configurator;
		// SetaÈ›i directorul pentru fiÈ™ierele temporare generate de Nette (de exemplu, È™abloane compilate)
		$this->configurator->setTempDirectory($this->rootDir . '/temp');
	}

	public function bootWebApplication(): Nette\DI\Container
	{
		$this->initializeEnvironment();
		$this->setupContainer();
		return $this->configurator->createContainer();
	}

	private function initializeEnvironment(): void
	{
		// Nette este inteligent, iar modul de dezvoltare se activeazÄƒ automat,
		// sau Ã®l puteÈ›i activa pentru o anumitÄƒ adresÄƒ IP prin decomentarea urmÄƒtoarei linii:
		// $this->configurator->setDebugMode('secret@23.75.345.200');

		// ActiveazÄƒ Tracy: instrumentul suprem de depanare "swiss army knife".
		$this->configurator->enableTracy($this->rootDir . '/log');

		// RobotLoader: ÃncarcÄƒ automat toate clasele din directorul dat
		$this->configurator->createRobotLoader()
			->addDirectory(__DIR__)
			->register();
	}

	private function setupContainer(): void
	{
		// ÃncarcÄƒ fiÈ™ierele de configurare
		$this->configurator->addConfig($this->rootDir . '/config/common.neon');
	}
}
```


index.php .[#toc-index-php]
===========================

Ãn cazul aplicaÈ›iilor web, fiÈ™ierul principal este `index.php`, care este localizat Ã®n [directorul public |directory-structure#public-directory-www] `www/`. Astfel, clasa Bootstrap va iniÈ›ializa mediul È™i va produce un container DI. Ea obÈ›ine apoi serviciul `Application` din acesta, care porneÈ™te aplicaÈ›ia web:

```php
$bootstrap = new App\Bootstrap;
// IniÈ›ializarea mediului + crearea unui container DI
$container = $bootstrap->bootWebApplication();
// Containerul DI creeazÄƒ un obiect Nette\Application\Application
$application = $container->getByType(Nette\Application\Application::class);
// PorniÈ›i aplicaÈ›ia Nette È™i trataÈ›i cererea de intrare
$application->run();
```

DupÄƒ cum puteÈ›i vedea, clasa [api:Nette\Bootstrap\Configurator], pe care o vom prezenta acum mai Ã®n detaliu, ajutÄƒ la configurarea mediului È™i la crearea unui container de injecÈ›ie a dependenÈ›elor (DI).


Modul de dezvoltare vs. modul de producÈ›ie .[#toc-development-vs-production-mode]
=================================================================================

Nette se comportÄƒ diferit Ã®n funcÈ›ie de faptul dacÄƒ ruleazÄƒ pe un server de dezvoltare sau de producÈ›ie:

ğŸ› ï¸ Modul de dezvoltare:
	- AfiÈ™eazÄƒ bara de depanare Tracy cu informaÈ›ii utile (de exemplu, interogÄƒri SQL, timp de execuÈ›ie, utilizarea memoriei).
	- AfiÈ™eazÄƒ o paginÄƒ de erori detaliatÄƒ cu urmele apelurilor funcÈ›iilor È™i conÈ›inutul variabilelor atunci cÃ¢nd apare o eroare.
	- ActualizeazÄƒ automat memoria cache atunci cÃ¢nd sunt modificate È™abloanele Latte, fiÈ™ierele de configurare etc.


ğŸš€ Modul de producÈ›ie:
	- Nu afiÈ™eazÄƒ nicio informaÈ›ie de depanare; toate erorile sunt Ã®nregistrate.
	- AfiÈ™eazÄƒ o paginÄƒ `ErrorPresenter` sau o paginÄƒ genericÄƒ "Server Error" atunci cÃ¢nd apare o eroare.
	- Cache-ul nu este niciodatÄƒ reÃ®mprospÄƒtat automat!
	- Optimizat pentru vitezÄƒ È™i securitate.


Modul este determinat automat, astfel Ã®ncÃ¢t, Ã®n majoritatea cazurilor, nu este nevoie sÄƒ Ã®l configuraÈ›i sau sÄƒ Ã®l comutaÈ›i manual:

- Modul de dezvoltare: Activ pe localhost (adresa IP `127.0.0.1` sau `::1`), cu excepÈ›ia cazului Ã®n care se utilizeazÄƒ un proxy (adicÄƒ, pe baza antetelor sale HTTP).
- Modul de producÈ›ie: Activ peste tot.

DacÄƒ doriÈ›i sÄƒ activaÈ›i modul de dezvoltare Ã®n alte cazuri, de exemplu, pentru programatorii care acceseazÄƒ de la o anumitÄƒ adresÄƒ IP, puteÈ›i utiliza `setDebugMode()`:

```php
$this->configurator->setDebugMode('23.75.345.200'); // una sau mai multe adrese IP
```

VÄƒ recomandÄƒm cu siguranÈ›Äƒ sÄƒ combinaÈ›i o adresÄƒ IP cu un cookie. Vom stoca un token secret Ã®n cookie-ul `nette-debug`, de exemplu `secret1234`, iar modul de dezvoltare va fi activat pentru programatorii cu aceastÄƒ combinaÈ›ie de IP È™i cookie.

```php
$this->configurator->setDebugMode('secret1234@23.75.345.200');
```

De asemenea, putem dezactiva complet modul de dezvoltare, chiar È™i pentru localhost:

```php
$this->configurator->setDebugMode(false);
```

ReÈ›ineÈ›i cÄƒ valoarea `true` activeazÄƒ modul dezvoltator din greu, ceea ce nu ar trebui sÄƒ se Ã®ntÃ¢mple niciodatÄƒ pe un server de producÈ›ie.


Instrumentul de depanare Tracy .[#toc-debugging-tool-tracy]
===========================================================

Pentru o depanare mai uÈ™oarÄƒ, vom porni minunata unealtÄƒ [Tracy |tracy:]. Ãn modul dezvoltator, acesta vizualizeazÄƒ erorile, iar Ã®n modul de producÈ›ie Ã®nregistreazÄƒ erorile Ã®n directorul specificat:

```php
$this->configurator->enableTracy($this->rootDir . '/log');
```


Temporary Files .[#toc-temporary-files]
=======================================

Nette utilizeazÄƒ memoria cache pentru DI container, RobotLoader, È™abloane etc. Prin urmare, este necesar sÄƒ setaÈ›i calea cÄƒtre directorul Ã®n care va fi stocatÄƒ memoria cache:

```php
$this->configurator->setTempDirectory($this->rootDir . '/temp');
```

Pe Linux sau macOS, setaÈ›i [permisiunile de scriere |nette:troubleshooting#Setting directory permissions] pentru directoarele `log/` È™i `temp/`.


RobotLoader .[#toc-robotloader]
===============================

De obicei, vom dori sÄƒ Ã®ncÄƒrcÄƒm automat clasele folosind [RobotLoader |robot-loader:], aÈ™a cÄƒ trebuie sÄƒ Ã®l pornim È™i sÄƒ Ã®l lÄƒsÄƒm sÄƒ Ã®ncarce clasele din directorul Ã®n care se aflÄƒ `Bootstrap.php` (adicÄƒ `__DIR__`) È™i din toate subdirectoarele sale:

```php
$this->configurator->createRobotLoader()
	->addDirectory(__DIR__)
	->register();
```

O modalitate alternativÄƒ este de a utiliza doar Ã®ncÄƒrcarea automatÄƒ [Composer |best-practices:composer] PSR-4.


Fusul orar .[#toc-timezone]
===========================

Configurator vÄƒ permite sÄƒ specificaÈ›i un fus orar pentru aplicaÈ›ia dumneavoastrÄƒ.

```php
$this->configurator->setTimeZone('Europe/Prague');
```


Configurarea containerului DI .[#toc-di-container-configuration]
================================================================

O parte a procesului de pornire constÄƒ Ã®n crearea unui container DI, adicÄƒ a unei fabrici de obiecte, care reprezintÄƒ inima Ã®ntregii aplicaÈ›ii. Acesta este de fapt o clasÄƒ PHP generatÄƒ de Nette È™i stocatÄƒ Ã®ntr-un director de cache. Fabrica produce obiectele cheie ale aplicaÈ›iei, iar fiÈ™ierele de configurare o instruiesc cum sÄƒ le creeze È™i sÄƒ le configureze È™i, astfel, influenÈ›Äƒm comportamentul Ã®ntregii aplicaÈ›ii.

FiÈ™ierele de configurare sunt de obicei scrise Ã®n [formatul NEON |neon:format]. PuteÈ›i citi [ce poate fi configurat aici |nette:configuring].

.[tip]
Ãn modul de dezvoltare, containerul este actualizat automat de fiecare datÄƒ cÃ¢nd modificaÈ›i codul sau fiÈ™ierele de configurare. Ãn modul de producÈ›ie, acesta este generat o singurÄƒ datÄƒ, iar modificÄƒrile fiÈ™ierelor nu sunt verificate pentru a maximiza performanÈ›a.

FiÈ™ierele de configurare sunt Ã®ncÄƒrcate utilizÃ¢nd `addConfig()`:

```php
$this->configurator->addConfig($this->rootDir . '/config/common.neon');
```

Metoda `addConfig()` poate fi apelatÄƒ de mai multe ori pentru a adÄƒuga mai multe fiÈ™iere.

```php
$configDir = $this->rootDir . '/config';
$this->configurator->addConfig($configDir . '/common.neon');
$this->configurator->addConfig($configDir . '/services.neon');
if (PHP_SAPI === 'cli') {
	$this->configurator->addConfig($configDir . '/cli.php');
}
```

Numele `cli.php` nu este o greÈ™ealÄƒ de tipar, deoarece configuraÈ›ia poate fi scrisÄƒ È™i Ã®ntr-un fiÈ™ier PHP, care o returneazÄƒ sub forma unei matrice.

Alternativ, putem folosi [secÈ›iunea`includes`  |dependency-injection:configuration#including files] pentru a Ã®ncÄƒrca mai multe fiÈ™iere de configurare.

DacÄƒ Ã®n fiÈ™ierele de configurare apar elemente cu aceleaÈ™i chei Ã®n cadrul fiÈ™ierelor de configurare, acestea vor fi [suprascrise sau fuzionate |dependency-injection:configuration#Merging] Ã®n cazul array-urilor. Ultimul fiÈ™ier inclus are o prioritate mai mare decÃ¢t cel anterior. FiÈ™ierul Ã®n care este listatÄƒ secÈ›iunea `includes` are o prioritate mai mare decÃ¢t fiÈ™ierele incluse Ã®n el.


Parametrii statici .[#toc-static-parameters]
--------------------------------------------

Parametrii utilizaÈ›i Ã®n fiÈ™ierele de configurare pot fi definiÈ›i [Ã®n secÈ›iunea `parameters` |dependency-injection:configuration#parameters] È™i, de asemenea, pot fi trecuÈ›i (sau suprascriÈ™i) prin metoda `addStaticParameters()` (are pseudonimul `addParameters()`). Este important ca valorile diferite ale parametrilor sÄƒ determine generarea de containere DI suplimentare, adicÄƒ de clase suplimentare.

```php
$this->configurator->addStaticParameters([
	'projectId' => 23,
]);
```

Ãn fiÈ™ierele de configurare, putem scrie notaÈ›ia obiÈ™nuitÄƒ `%projectId%` pentru a accesa parametrul numit `projectId`.


Parametrii dinamici .[#toc-dynamic-parameters]
----------------------------------------------

De asemenea, putem adÄƒuga parametri dinamici la container, valorile lor diferite, spre deosebire de parametrii statici, nu vor determina generarea de noi containere DI.

```php
$this->configurator->addDynamicParameters([
	'remoteIp' => $_SERVER['REMOTE_ADDR'],
]);
```

Variabilele de mediu ar putea fi puse cu uÈ™urinÈ›Äƒ la dispoziÈ›ie prin intermediul parametrilor dinamici. Le putem accesa prin intermediul `%env.variable%` Ã®n fiÈ™ierele de configurare.

```php
$this->configurator->addDynamicParameters([
	'env' => getenv(),
]);
```


Parametrii impliciÈ›i .[#toc-default-parameters]
-----------------------------------------------

PuteÈ›i utiliza urmÄƒtorii parametri statici Ã®n fiÈ™ierele de configurare:

- `%appDir%` este calea absolutÄƒ cÄƒtre directorul fiÈ™ierului `Bootstrap.php`
- `%wwwDir%` este calea absolutÄƒ cÄƒtre directorul care conÈ›ine fiÈ™ierul de intrare `index.php`
- `%tempDir%` este calea absolutÄƒ cÄƒtre directorul pentru fiÈ™ierele temporare
- `%vendorDir%` este calea absolutÄƒ cÄƒtre directorul Ã®n care Composer instaleazÄƒ bibliotecile
- `%rootDir%` este calea absolutÄƒ cÄƒtre directorul rÄƒdÄƒcinÄƒ al proiectului
- `%debugMode%` indicÄƒ dacÄƒ aplicaÈ›ia se aflÄƒ Ã®n modul de depanare
- `%consoleMode%` indicÄƒ dacÄƒ cererea a venit prin linia de comandÄƒ


Servicii importate .[#toc-imported-services]
--------------------------------------------

Acum mergem mai departe. DeÈ™i scopul unui container DI este acela de a crea obiecte, Ã®n mod excepÈ›ional poate fi nevoie sÄƒ se introducÄƒ un obiect existent Ã®n container. Facem acest lucru prin definirea serviciului cu atributul `imported: true`.

```neon
services:
	myservice:
		type: App\Model\MyCustomService
		imported: true
```

CreaÈ›i o nouÄƒ instanÈ›Äƒ È™i inseraÈ›i-o Ã®n bootstrap:

```php
$this->configurator->addServices([
	'myservice' => new App\Model\MyCustomService('foobar'),
]);
```


Diferite medii .[#toc-different-environments]
=============================================

Nu ezitaÈ›i sÄƒ personalizaÈ›i clasa `Bootstrap` Ã®n funcÈ›ie de nevoile dumneavoastrÄƒ. PuteÈ›i adÄƒuga parametri la metoda `bootWebApplication()` pentru a face diferenÈ›a Ã®ntre proiectele web. Alternativ, puteÈ›i adÄƒuga alte metode, cum ar fi `bootTestEnvironment()` pentru a iniÈ›ializa mediul pentru testele unitare, `bootConsoleApplication()` pentru scripturile apelate din linia de comandÄƒ È™i aÈ™a mai departe.

```php
public function bootTestEnvironment(): Nette\DI\Container
{
	Tester\Environment::setup(); // IniÈ›ializarea Nette Tester
	$this->setupContainer();
	return $this->configurator->createContainer();
}

public function bootConsoleApplication(): Nette\DI\Container
{
	$this->configurator->setDebugMode(false);
	$this->initializeEnvironment();
	$this->setupContainer();
	return $this->configurator->createContainer();
}
```
