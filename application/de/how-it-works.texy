Wie funktionieren Anwendungen?
******************************

<div class=perex>

Sie lesen gerade das grundlegende Dokument der Nette-Dokumentation. Sie werden das gesamte Funktionsprinzip von Webanwendungen kennenlernen. SchÃ¶n von A bis Z, von dem Moment der Entstehung bis zum letzten Atemzug des PHP-Skripts. Nach dem Lesen werden Sie wissen:

- wie das Ganze funktioniert
- was Bootstrap, Presenter und DI-Container sind
- wie die Verzeichnisstruktur aussieht

</div>


Verzeichnisstruktur
===================

Ã–ffnen Sie das Beispiel-Skelett einer Webanwendung namens [WebProject|https://github.com/nette/web-project] und beim Lesen kÃ¶nnen Sie sich die Dateien ansehen, von denen die Rede ist.

Die Verzeichnisstruktur sieht ungefÃ¤hr so aus:

/--pre
<b>web-project/</b>
â”œâ”€â”€ <b>app/</b>                      â† Verzeichnis mit der Anwendung
â”‚   â”œâ”€â”€ <b>Core/</b>                 â† grundlegende Klassen, die fÃ¼r den Betrieb notwendig sind
â”‚   â”‚   â””â”€â”€ <b>RouterFactory.php</b> â† Konfiguration der URL-Adressen
â”‚   â”œâ”€â”€ <b>Presentation/</b>         â† Presenter, Templates & Co.
â”‚   â”‚   â”œâ”€â”€ <b>@layout.latte</b>     â† Layout-Template
â”‚   â”‚   â””â”€â”€ <b>Home/</b>             â† Verzeichnis des Home-Presenters
â”‚   â”‚       â”œâ”€â”€ <b>HomePresenter.php</b> â† Klasse des Home-Presenters
â”‚   â”‚       â””â”€â”€ <b>default.latte</b> â† Template der default-Aktion
â”‚   â””â”€â”€ <b>Bootstrap.php</b>         â† Startklasse Bootstrap
â”œâ”€â”€ <b>assets/</b>                   â† Ressourcen (SCSS, TypeScript, Quellbilder)
â”œâ”€â”€ <b>bin/</b>                      â† Skripte, die von der Kommandozeile ausgefÃ¼hrt werden
â”œâ”€â”€ <b>config/</b>                   â† Konfigurationsdateien
â”‚   â”œâ”€â”€ <b>common.neon</b>
â”‚   â””â”€â”€ <b>services.neon</b>
â”œâ”€â”€ <b>log/</b>                      â† protokollierte Fehler
â”œâ”€â”€ <b>temp/</b>                     â† temporÃ¤re Dateien, Cache, â€¦
â”œâ”€â”€ <b>vendor/</b>                   â† Bibliotheken, die mit Composer installiert wurden
â”‚   â”œâ”€â”€ ...
â”‚   â””â”€â”€ <b>autoload.php</b>          â† Autoloading aller installierten Pakete
â”œâ”€â”€ <b>www/</b>                      â† Ã¶ffentliches Verzeichnis oder Document-Root des Projekts
â”‚   â”œâ”€â”€ <b>assets/</b>               â† kompilierte statische Dateien (CSS, JS, Bilder, ...)
â”‚   â”œâ”€â”€ <b>.htaccess</b>             â† mod_rewrite-Regeln
â”‚   â””â”€â”€ <b>index.php</b>             â† initiale Datei, mit der die Anwendung gestartet wird
â””â”€â”€ <b>.htaccess</b>                 â† verbietet den Zugriff auf alle Verzeichnisse auÃŸer www
\--

Die Verzeichnisstruktur kÃ¶nnen Sie beliebig Ã¤ndern, Ordner umbenennen oder verschieben, sie ist vÃ¶llig flexibel. Nette verfÃ¼gt zudem Ã¼ber eine intelligente Autodetektion und erkennt automatisch den Speicherort der Anwendung einschlieÃŸlich ihrer URL-Basis.

Bei etwas grÃ¶ÃŸeren Anwendungen kÃ¶nnen wir die Ordner mit Presentern und Templates [in Unterverzeichnisse aufteilen |directory-structure#Presenter und Templates] und Klassen in Namespaces, die wir Module nennen.

Das Verzeichnis `www/` stellt das sogenannte Ã¶ffentliche Verzeichnis oder Document-Root des Projekts dar. Sie kÃ¶nnen es umbenennen, ohne etwas Weiteres auf Anwendungsseite einstellen zu mÃ¼ssen. Es ist nur notwendig, [das Hosting zu konfigurieren |nette:troubleshooting#Wie Ã¤ndert oder entfernt man das Verzeichnis www aus der URL], damit der Document-Root auf dieses Verzeichnis zeigt.

WebProject kÃ¶nnen Sie sich auch direkt inklusive Nette herunterladen, und zwar mittels [Composer |best-practices:composer]:

```shell
composer create-project nette/web-project
```

Unter Linux oder macOS setzen Sie fÃ¼r die Verzeichnisse `log/` und `temp/` [Schreibrechte |nette:troubleshooting#Einstellung der Verzeichnisberechtigungen].

Die Anwendung WebProject ist startbereit, es muss Ã¼berhaupt nichts konfiguriert werden und Sie kÃ¶nnen sie direkt im Browser anzeigen, indem Sie auf den Ordner `www/` zugreifen.


HTTP-Anfrage
============

Alles beginnt in dem Moment, in dem der Benutzer im Browser eine Seite Ã¶ffnet. Also wenn der Browser beim Server mit einer HTTP-Anfrage anklopft. Die Anfrage zielt auf eine einzige PHP-Datei, die sich im Ã¶ffentlichen Verzeichnis `www/` befindet, und das ist `index.php`. Nehmen wir an, es handelt sich um eine Anfrage an die Adresse `https://example.com/product/123`. Dank geeigneter [Serverkonfiguration |nette:troubleshooting#Wie konfiguriert man den Server fÃ¼r schÃ¶ne URLs Pretty URLs] wird auch diese URL auf die Datei `index.php` abgebildet und diese wird ausgefÃ¼hrt.

Ihre Aufgabe ist es:

1) die Umgebung zu initialisieren
2) die Factory zu erhalten
3) die Nette-Anwendung zu starten, die die Anfrage bearbeitet

Welche Factory denn? Wir stellen doch keine Traktoren her, sondern Webseiten! Bleiben Sie dran, das wird gleich erklÃ¤rt.

Mit â€Initialisierung der Umgebungâ€œ meinen wir zum Beispiel, dass [Tracy|tracy:] aktiviert wird, ein groÃŸartiges Werkzeug zur Protokollierung oder Visualisierung von Fehlern. Auf dem Produktionsserver protokolliert es Fehler, auf dem Entwicklungsserver zeigt es sie direkt an. Zur Initialisierung gehÃ¶rt also auch die Entscheidung, ob die Website im Produktions- oder Entwicklungsmodus lÃ¤uft. Dazu verwendet Nette eine [intelligente Autodetektion |bootstrapping#Entwicklungs- vs. Produktionsmodus]: Wenn Sie die Website auf localhost starten, lÃ¤uft sie im Entwicklungsmodus. Sie mÃ¼ssen also nichts konfigurieren und die Anwendung ist direkt bereit sowohl fÃ¼r die Entwicklung als auch fÃ¼r den Live-Einsatz. Diese Schritte werden durchgefÃ¼hrt und sind im Kapitel Ã¼ber die [Bootstrap-Klasse|bootstrapping] ausfÃ¼hrlich beschrieben.

Der dritte Punkt (ja, den zweiten haben wir Ã¼bersprungen, aber wir kommen darauf zurÃ¼ck) ist der Start der Anwendung. Die Bearbeitung von HTTP-Anfragen Ã¼bernimmt in Nette die Klasse `Nette\Application\Application` (weiter `Application`), wenn wir also sagen, die Anwendung starten, meinen wir konkret den Aufruf der Methode mit dem treffenden Namen `run()` auf einem Objekt dieser Klasse.

Nette ist ein Mentor, der Sie dazu anleitet, saubere Anwendungen nach bewÃ¤hrten Methoden zu schreiben. Und eine der absolut bewÃ¤hrtesten heiÃŸt **Dependency Injection**, abgekÃ¼rzt DI. An dieser Stelle mÃ¶chten wir Sie nicht mit der ErklÃ¤rung von DI belasten, dafÃ¼r gibt es ein [eigenes Kapitel|dependency-injection:introduction], wesentlich ist die Konsequenz, dass uns SchlÃ¼sselobjekte Ã¼blicherweise von einer Objekt-Factory erstellt werden, die **DI-Container** (abgekÃ¼rzt DIC) genannt wird. Ja, das ist die Factory, von der vorhin die Rede war. Und sie stellt uns auch das `Application`-Objekt her, deshalb benÃ¶tigen wir zuerst den Container. Wir erhalten ihn mittels der Klasse `Configurator` und lassen ihn das `Application`-Objekt erstellen, rufen darauf die Methode `run()` auf und damit startet die Nette-Anwendung. Genau das geschieht in der Datei [index.php |bootstrapping#index.php].


Nette Application
=================

Die Klasse Application hat eine einzige Aufgabe: auf eine HTTP-Anfrage zu antworten.

Anwendungen, die in Nette geschrieben sind, gliedern sich in viele sogenannte Presenter (in anderen Frameworks kÃ¶nnen Sie auf den Begriff Controller stoÃŸen, es handelt sich um dasselbe), das sind Klassen, von denen jede eine bestimmte Webseite reprÃ¤sentiert: z.B. die Homepage; ein Produkt im E-Shop; ein Anmeldeformular; ein Sitemap-Feed usw. Eine Anwendung kann von einem bis zu Tausenden von Presentern haben.

Die Application beginnt damit, den sogenannten Router zu bitten, zu entscheiden, welchem der Presenter die aktuelle Anfrage zur Bearbeitung Ã¼bergeben werden soll. Der Router entscheidet, wessen Verantwortung das ist. Er schaut sich die Eingabe-URL `https://example.com/product/123` an und entscheidet auf Basis seiner Konfiguration, dass dies die Arbeit z.B. fÃ¼r den **Presenter** `Product` ist, von dem er als **Aktion** die Anzeige (`show`) des Produkts mit `id: 123` verlangen wird. Das Paar Presenter + Aktion wird Ã¼blicherweise durch einen Doppelpunkt getrennt als `Product:show` geschrieben.

Also hat der Router die URL in das Paar `Presenter:action` + Parameter transformiert, in unserem Fall `Product:show` + `id: 123`. Wie ein solcher Router aussieht, kÃ¶nnen Sie sich in der Datei `app/Core/RouterFactory.php` ansehen und wir beschreiben ihn detailliert im Kapitel [Routing].

Gehen wir weiter. Die Application kennt nun den Namen des Presenters und kann weitermachen. Indem sie ein Objekt der Klasse `ProductPresenter` erstellt, was der Code des Presenters `Product` ist. Genauer gesagt, bittet sie den DI-Container, den Presenter zu erstellen, denn fÃ¼r das Erstellen ist er da.

Der Presenter kann etwa so aussehen:

```php
class ProductPresenter extends Nette\Application\UI\Presenter
{
	public function __construct(
		private ProductRepository $repository,
	) {
	}

	public function renderShow(int $id): void
	{
		// Wir holen Daten aus dem Modell und Ã¼bergeben sie an das Template
		$this->template->product = $this->repository->getProduct($id);
	}
}
```

Die Bearbeitung der Anfrage Ã¼bernimmt der Presenter. Und die Aufgabe lautet klar: fÃ¼hre die Aktion `show` mit `id: 123` aus. Was in der Sprache der Presenter bedeutet, dass die Methode `renderShow()` aufgerufen wird und im Parameter `$id` den Wert `123` erhÃ¤lt.

Ein Presenter kann mehrere Aktionen bedienen, also mehrere Methoden `render<Aktion>()` haben. Wir empfehlen jedoch, Presenter mit einer oder mÃ¶glichst wenigen Aktionen zu entwerfen.

Also, die Methode `renderShow(123)` wurde aufgerufen, deren Code zwar ein fiktives Beispiel ist, aber Sie kÃ¶nnen daran sehen, wie Daten an das Template Ã¼bergeben werden, nÃ¤mlich durch Schreiben in `$this->template`.

AnschlieÃŸend gibt der Presenter eine Antwort zurÃ¼ck. Das kann eine HTML-Seite, ein Bild, ein XML-Dokument, das Senden einer Datei von der Festplatte, JSON oder auch eine Weiterleitung auf eine andere Seite sein. Wichtig ist, dass wenn wir nicht explizit sagen, wie geantwortet werden soll (was der Fall bei `ProductPresenter` ist), die Antwort das Rendern eines Templates mit einer HTML-Seite sein wird. Warum? Weil wir in 99 % der FÃ¤lle ein Template rendern wollen, daher nimmt der Presenter dieses Verhalten als Standard an und mÃ¶chte uns die Arbeit erleichtern. Das ist der Sinn von Nette.

Wir mÃ¼ssen nicht einmal angeben, welches Template gerendert werden soll, den Pfad dazu leitet er selbst ab. Im Falle der Aktion `show` versucht er einfach, das Template `show.latte` im Verzeichnis der Klasse `ProductPresenter` zu laden. Ebenso versucht er, das Layout in der Datei `@layout.latte` zu finden (mehr dazu unter [Template-Suche |templates#Finden von Vorlagen]).

Und anschlieÃŸend rendert er die Templates. Damit ist die Aufgabe des Presenters und der gesamten Anwendung erfÃ¼llt und das Werk vollendet. Wenn das Template nicht existiert, wird eine Seite mit dem Fehler 404 zurÃ¼ckgegeben. Mehr Ã¼ber Presenter erfahren Sie auf der Seite [Presenter |presenters].

[* request-flow.svg *]

Zur Sicherheit versuchen wir, den gesamten Prozess mit einer etwas anderen URL zu rekapitulieren:

1) Die URL lautet `https://example.com`
2) Wir booten die Anwendung, der DI-Container wird erstellt und `Application::run()` wird gestartet
3) Der Router dekodiert die URL als Paar `Home:default`
4) Ein Objekt der Klasse `HomePresenter` wird erstellt
5) Die Methode `renderDefault()` wird aufgerufen (falls sie existiert)
6) Das Template z.B. `default.latte` mit dem Layout z.B. `@layout.latte` wird gerendert


Vielleicht sind Sie jetzt auf viele neue Begriffe gestoÃŸen, aber wir glauben, dass sie Sinn ergeben. Die Entwicklung von Anwendungen in Nette ist unglaublich entspannt.


Templates
=========

Wo wir schon bei Templates sind, in Nette wird das Template-System [Latte |latte:] verwendet. Daher auch die Endungen `.latte` bei den Templates. Latte wird zum einen verwendet, weil es das sicherste Template-System fÃ¼r PHP ist, und zum anderen auch das intuitivste System. Sie mÃ¼ssen nicht viel Neues lernen, Sie kommen mit PHP-Kenntnissen und ein paar Tags aus. Alles erfahren Sie [in der Dokumentation |templates].

Im Template werden [Links erstellt |creating-links] zu anderen Presentern & Aktionen wie folgt:

```latte
<a n:href="Product:show $productId">Produktdetail</a>
```

Einfach statt der realen URL schreiben Sie das bekannte Paar `Presenter:action` und geben eventuelle Parameter an. Der Trick liegt im `n:href`, das besagt, dass dieses Attribut von Nette verarbeitet wird. Und es generiert:

```latte
<a href="/product/456">Produktdetail</a>
```

Die Generierung der URL Ã¼bernimmt der bereits erwÃ¤hnte Router. Denn Router in Nette sind auÃŸergewÃ¶hnlich, da sie nicht nur Transformationen von URL zum Paar Presenter:Aktion durchfÃ¼hren kÃ¶nnen, sondern auch umgekehrt, also aus dem Namen des Presenters + Aktion + Parametern eine URL generieren. Dadurch kÃ¶nnen Sie in Nette die Formen der URLs in der gesamten fertigen Anwendung vollstÃ¤ndig Ã¤ndern, ohne ein einziges Zeichen im Template oder Presenter zu Ã¤ndern. Nur durch die Anpassung des Routers. Dadurch funktioniert auch die sogenannte Kanonisierung, was eine weitere einzigartige Eigenschaft von Nette ist, die zu besserem SEO (Optimierung der Auffindbarkeit im Internet) beitrÃ¤gt, indem sie automatisch die Existenz von doppeltem Inhalt unter verschiedenen URLs verhindert. Viele Programmierer finden das erstaunlich.


Interaktive Komponenten
=======================

Ãœber Presenter mÃ¼ssen wir Ihnen noch eine Sache verraten: Sie haben ein eingebautes Komponentensystem. Etwas Ã„hnliches kennen Ã„ltere vielleicht aus Delphi oder ASP.NET Web Forms, auf etwas entfernt Ã„hnlichem bauen React oder Vue.js auf. In der Welt der PHP-Frameworks ist dies eine absolut einzigartige Angelegenheit.

Komponenten sind eigenstÃ¤ndige wiederverwendbare Einheiten, die wir in Seiten (also Presenter) einfÃ¼gen. Das kÃ¶nnen [Formulare |forms:in-presenter], [Datagrids |https://componette.org/contributte/datagrid/], MenÃ¼s, Abstimmungsumfragen sein, eigentlich alles, was sinnvoll wiederverwendet werden kann. Wir kÃ¶nnen eigene Komponenten erstellen oder einige aus dem [riesigen Angebot |https://componette.org] an Open-Source-Komponenten verwenden.

Komponenten beeinflussen grundlegend den Ansatz zur Anwendungsentwicklung. Sie erÃ¶ffnen Ihnen neue MÃ¶glichkeiten, Seiten aus vorgefertigten Einheiten zusammenzusetzen. Und auÃŸerdem haben sie etwas mit [Hollywood gemeinsam |components#Hollywood Style].


DI-Container und Konfiguration
==============================

Der DI-Container oder die Objekt-Factory ist das Herz der gesamten Anwendung.

Keine Sorge, es ist keine magische Blackbox, wie es vielleicht aus den vorherigen Zeilen scheinen mag. Eigentlich ist es eine ziemlich langweilige PHP-Klasse, die Nette generiert und im Cache-Verzeichnis speichert. Sie hat viele Methoden namens `createServiceAbcd()` und jede von ihnen kann ein bestimmtes Objekt erstellen und zurÃ¼ckgeben. Ja, es gibt auch eine Methode `createServiceApplication()`, die `Nette\Application\Application` erstellt, das wir in der Datei `index.php` zum Starten der Anwendung benÃ¶tigten. Und es gibt Methoden, die einzelne Presenter erstellen. Und so weiter.

Objekte, die der DI-Container erstellt, werden aus irgendeinem Grund Dienste genannt.

Was an dieser Klasse wirklich besonders ist, ist, dass nicht Sie sie programmieren, sondern das Framework. Es generiert tatsÃ¤chlich den PHP-Code und speichert ihn auf der Festplatte. Sie geben nur Anweisungen, welche Objekte der Container erstellen kÃ¶nnen soll und wie genau. Und diese Anweisungen sind in [Konfigurationsdateien |bootstrapping#Konfiguration des DI-Containers] geschrieben, fÃ¼r die das Format [NEON|neon:format] verwendet wird und die daher auch die Erweiterung `.neon` haben.

Konfigurationsdateien dienen rein dazu, den DI-Container zu instruieren. Wenn ich also zum Beispiel im Abschnitt [session |http:configuration#Session] die Option `expiration: 14 days` angebe, ruft der DI-Container beim Erstellen des Objekts `Nette\Http\Session`, das die Session reprÃ¤sentiert, dessen Methode `setExpiration('14 days')` auf und damit wird die Konfiguration RealitÃ¤t.

Es gibt fÃ¼r Sie ein ganzes Kapitel, das beschreibt, was alles [konfiguriert |nette:configuring] werden kann und wie man [eigene Dienste definiert |dependency-injection:services].

Sobald Sie etwas tiefer in die Erstellung von Diensten eintauchen, werden Sie auf das Wort [Autowiring |dependency-injection:autowiring] stoÃŸen. Das ist ein Feature, das Ihnen das Leben unglaublich vereinfacht. Es kann Objekte automatisch dorthin Ã¼bergeben, wo Sie sie benÃ¶tigen (z.B. in den Konstruktoren Ihrer Klassen), ohne dass Sie etwas tun mÃ¼ssen. Sie werden feststellen, dass der DI-Container in Nette ein kleines Wunder ist.


Wohin als nÃ¤chstes?
===================

Wir sind die Grundprinzipien von Anwendungen in Nette durchgegangen. Bisher sehr oberflÃ¤chlich, aber bald werden Sie in die Tiefe vordringen und mit der Zeit wunderbare Webanwendungen erstellen. Wohin soll es als nÃ¤chstes gehen? Haben Sie schon das Tutorial [Meine erste Anwendung schreiben|quickstart:] ausprobiert?

Neben dem oben Beschriebenen verfÃ¼gt Nette Ã¼ber ein ganzes Arsenal an [nÃ¼tzlichen Klassen|utils:], eine [Datenbankschicht|database:], usw. Versuchen Sie doch mal, einfach so durch die Dokumentation zu klicken. Oder den [Blog|https://blog.nette.org]. Sie werden viele interessante Dinge entdecken.

MÃ¶ge Ihnen das Framework viel Freude bereiten ğŸ’™
