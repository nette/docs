HTTP-запит
**********

.[perex]
Nette інкапсулює HTTP-запит в об'єкти зі зрозумілим API, забезпечуючи при цьому фільтр санації.

HTTP-запит представляється об'єктом [api:Nette\Http\Request]. Якщо ви працюєте з Nette, цей об'єкт автоматично створюється фреймворком, і ви можете передати його вам за допомогою [ін'єкції залежностей |dependency-injection:passing-dependencies]. У презентаторах вам просто потрібно викликати метод `$this->getHttpRequest()`. Якщо ви працюєте поза Nette Framework, ви можете створити об'єкт за допомогою [RequestFactory |#RequestFactory].

Основною перевагою Nette є те, що при створенні об'єкта він автоматично очищає всі вхідні параметри GET, POST, COOKIE, а також URL-адресу від контрольних символів і невірних послідовностей UTF-8. Після цього ви можете спокійно працювати з цими даними. Очищені дані згодом використовуються в презентаціях і формах.

→ [Встановлення та вимоги |@home#Installation]


Nette\Http\Request .[#toc-nette-http-request]
=============================================

Цей об'єкт є незмінним. У нього немає сеттерів, є тільки один так званий wither `withUrl()`, який не змінює об'єкт, а повертає новий екземпляр зі зміненим значенням.


withUrl(Nette\Http\UrlScript $url): Nette\Http\Request .[method]
----------------------------------------------------------------
Повертає клон з іншим URL.


getUrl(): Nette\Http\UrlScript .[method]
----------------------------------------
Повертає URL запиту у вигляді об'єкта [UrlScript |urls#UrlScript].

```php
$url = $httpRequest->getUrl();
echo $url; // https://nette.org/en/documentation?action=edit
echo $url->getHost(); // nette.org
```

Попередження: Браузери не надсилають фрагмент на сервер, тому `$url->getFragment()` поверне порожній рядок.


getQuery(?string $key=null): string|array|null .[method]
--------------------------------------------------------
Повертає параметри GET-запиту:

```php
$all = $httpRequest->getQuery(); // масив усіх URL параметрів
$id = $httpRequest->getQuery('id'); // повертає GET-параметр 'id' (або null)
```


getPost(?string $key=null): string|array|null .[method]
-------------------------------------------------------
Повертає параметри POST-запиту:

```php
$all = $httpRequest->getPost(); // масив усіх POST-параметрів
$id = $httpRequest->getPost('id'); // повертає POST-параметр 'id' (або null)
```


getFile(string|string[] $key): Nette\Http\FileUpload|array|null .[method]
-------------------------------------------------------------------------
Повертає [вивантаження |#Uploaded-Files] як об'єкт [api:Nette\Http\FileUpload]:

```php
$file = $httpRequest->getFile('avatar');
if ($file?->hasFile()) { // чи був завантажений якийсь файл?
	$file->getUntrustedName(); // ім'я файлу, відправленого користувачем
	$file->getSanitizedName(); // ім'я без небезпечних символів
}
```

Вкажіть масив ключів для доступу до структури піддерева.

```php
//<input type="file" name="my-form[details][avatar]" multiple>
$file = $request->getFile(['my-form', 'details', 'avatar']);
```

Оскільки ви не можете довіряти даним ззовні і тому не покладаєтеся на форму структури, цей метод безпечніший, ніж `$request->getFiles()['my-form']['details']['avatar']`який може зазнати невдачі.


getFiles(): array .[method]
---------------------------
Повертає дерево [файлів вивантаження |#Uploaded-Files] в нормалізованій структурі, кожен аркуш якого є екземпляром [api:Nette\Http\FileUpload]:

```php
$files = $httpRequest->getFiles();
```


getCookie(string $key): string|array|null .[method]
---------------------------------------------------
Повертає cookie або `null`, якщо він не існує.

```php
$sessId = $httpRequest->getCookie('sess_id');
```


getCookies(): array .[method]
-----------------------------
Повертає всі файли cookie:

```php
$cookies = $httpRequest->getCookies();
```


getMethod(): string .[method]
-----------------------------
Повертає метод HTTP, за допомогою якого було зроблено запит.

```php
echo $httpRequest->getMethod(); // GET, POST, HEAD, PUT
```


isMethod(string $method): bool .[method]
----------------------------------------
Перевіряє метод HTTP, за допомогою якого було зроблено запит. Параметр не чутливий до регістру.

```php
if ($httpRequest->isMethod('GET')) // ...
```


getHeader(string $header): ?string .[method]
--------------------------------------------
Повертає HTTP-заголовок або `null`, якщо він не існує. Параметр не чутливий до регістру:

```php
$userAgent = $httpRequest->getHeader('User-Agent');
```


getHeaders(): array .[method]
-----------------------------
Повертає всі HTTP-заголовки у вигляді асоціативного масиву:

```php
$headers = $httpRequest->getHeaders();
echo $headers['Content-Type'];
```


isSecured(): bool .[method]
---------------------------
Чи зашифровано з'єднання (HTTPS)? Можливо, вам буде потрібно налаштувати [проксі-сервер |configuration#HTTP-Proxy] для правильної роботи.


isSameSite(): bool .[method]
----------------------------
Запит виходить із того самого (під)домену та ініційований натисканням на посилання? Для визначення цього Nette використовує cookie `_nss` (раніше `nette-samesite`).


isAjax(): bool .[method]
------------------------
Це AJAX-запит?


getRemoteAddress(): ?string .[method]
-------------------------------------
Повертає IP-адресу користувача. Для правильної роботи може знадобитися налаштування [проксі-сервера |configuration#HTTP-Proxy].


getRemoteHost(): ?string .[method deprecated]
---------------------------------------------
Повертає DNS-трансляцію IP-адреси користувача. Для правильної роботи може знадобитися налаштування [проксі-сервера |configuration#HTTP-Proxy].


getBasicCredentials(): ?array .[method]
---------------------------------------
Повертає облікові дані [базової HTTP-аутентифікації |https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication].

```php
[$user, $password] = $httpRequest->getBasicCredentials();
```


getRawBody(): ?string .[method]
-------------------------------
Повертає тіло HTTP-запиту:

```php
$body = $httpRequest->getRawBody();
```


detectLanguage(array $langs): ?string .[method]
-----------------------------------------------
Визначає мову. Як параметр `$lang` ми передаємо масив мов, які підтримує додаток, і він повертає ту, якій віддає перевагу браузер. Це не магія, метод просто використовує заголовок `Accept-Language`. Якщо збіг не досягнуто, повертається `null`.

```php
// Заголовок, що надсилається браузером: Accept-Language: cs,en-us;q=0.8,en;q=0.5,sl;q=0.3

$langs = ['hu', 'pl', 'en']; // мови, що підтримуються в застосунку
echo $httpRequest->detectLanguage($langs); // en
```


RequestFactory .[#toc-requestfactory]
=====================================

Клас [api:Nette\Http\RequestFactory] використовується для створення екземпляра `Nette\Http\Request`, який представляє поточний HTTP-запит. (Якщо ви працюєте з Nette, об'єкт HTTP-запиту створюється фреймворком автоматично).

```php
$factory = new Nette\Http\RequestFactory;
$httpRequest = $factory->fromGlobals();
```

Метод `fromGlobals()` створює об'єкт запиту на основі поточних глобальних змінних PHP (`$_GET`, `$_POST`, `$_COOKIE`, `$_FILES` і `$_SERVER`). При створенні об'єкта він автоматично очищає всі вхідні параметри GET, POST, COOKIE, а також URL від контрольних символів і невірних послідовностей UTF-8, що забезпечує безпеку при подальшій роботі з цими даними.

RequestFactory можна налаштувати перед викликом `fromGlobals()`:

- за допомогою методу `$factory->setBinary()` можна відключити автоматичне очищення вхідних параметрів від контрольних символів і неприпустимих послідовностей UTF-8.
- за допомогою методу `$factory->setProxy(...)` вказується IP-адреса [проксі-сервера |configuration#HTTP proxy], яка необхідна для коректного визначення IP-адреси користувача.

RequestFactory дозволяє визначати фільтри, які автоматично перетворюють частини URL-запиту. Ці фільтри видаляють з URL-адрес небажані символи, які могли бути вставлені, наприклад, через некоректну реалізацію систем коментування на різних сайтах:

```php
// видалення пробілів зі шляху
$requestFactory->urlFilters['path']['%20'] = '';

// видалення крапки, коми або правої дужки з кінця URI
$requestFactory->urlFilters['url']['['[.,)]$'] = '';

// очищення шляху від подвійних слешів (фільтр за замовчуванням)
$requestFactory->urlFilters['path']['/{2,}'] = '/';
```

Перший ключ `'path'` або `'url'` визначає, до якої частини URL-адреси буде застосовано фільтр. Другий ключ - це регулярний вираз для пошуку, а значення - заміна, яка буде використана замість знайденого тексту.


Завантажені файли .[#toc-uploaded-files]
========================================

Метод `Nette\Http\Request::getFiles()` повертає дерево завантажених файлів у нормалізованій структурі, кожен аркуш якого є екземпляром [api:Nette\Http\FileUpload]. Ці об'єкти інкапсулюють дані, представлені елементом `<input type=file>` елементом форми.

Структура відображає іменування елементів у HTML. У найпростішому прикладі це може бути один іменований елемент форми, представлений як:

```latte
<input type="file" name="avatar">
```

У цьому випадку `$request->getFiles()` повертає масив:

```php
[
	'avatar' => /* FileUpload instance */
]
```

Об'єкт `FileUpload` створюється, навіть якщо користувач не завантажив жодного файлу або завантаження не вдалося. Метод `hasFile()` повертає true, якщо файл було надіслано:

```php
$request->getFile('avatar')?->hasFile();
```

У разі введення з використанням нотації масиву для імені:

```latte
<input type="file" name="my-form[details][avatar]">
```

дерево, що повертається, має такий вигляд:

```php
[
	'my-form' => [
		'details' => [
			'avatar' => /* FileUpload instance */
		],
	],
]
```

Ви також можете створювати масиви файлів:

```latte
<input type="file" name="my-form[details][avatars][] multiple">
```

У такому разі структура має такий вигляд:

```php
[
	'my-form' => [
		'details' => [
			'avatars' => [
				0 => /* FileUpload instance */,
				1 => /* FileUpload instance */,
				2 => /* FileUpload instance */,
			],
		],
	],
]
```

Найкращий спосіб доступу до індексу 1 вкладеного масиву такий:

```php
$file = $request->getFile(['my-form', 'details', 'avatars', 1]);
if ($file instanceof FileUpload) {
	// ...
}
```

Оскільки ви не можете довіряти даним ззовні і тому не покладаєтеся на форму структури, цей метод є безпечнішим, ніж `$request->getFiles()['my-form']['details']['avatars'][1]`який може не спрацювати.


Огляд методів `FileUpload` .{toc: FileUpload}
---------------------------------------------


hasFile(): bool .[method]
-------------------------
Повертає `true`, якщо користувач завантажив файл.


isOk(): bool .[method]
----------------------
Повертає `true`, якщо файл було завантажено успішно.


getError(): int .[method]
-------------------------
Повертає код помилки, пов'язаний із завантаженим файлом. Це може бути одна з констант [UPLOAD_ERR_XXX |http://php.net/manual/en/features.file-upload.errors.php]. Якщо файл було завантажено успішно, повертається `UPLOAD_ERR_OK`.


move(string $dest) .[method]
----------------------------
Переміщує завантажений файл у нове місце. Якщо файл призначення вже існує, його буде перезаписано.

```php
$file->move('/path/to/files/name.ext');
```


getContents(): ?string .[method]
--------------------------------
Повертає вміст завантаженого файлу. Якщо завантаження не було успішним, повертається `null`.


getContentType(): ?string .[method]
-----------------------------------
Визначає MIME-тип вмісту завантажуваного файлу на основі його сигнатури. Якщо завантаження не було успішним або визначення не вдалося, повертається `null`.

.[caution]
Потрібне розширення PHP `fileinfo`.


getUntrustedName(): string .[method]
------------------------------------
Повертає вихідне ім'я файлу, передане браузером.

.[caution]
Не довіряйте значенню, що повертається цим методом. Клієнт може надіслати шкідливе ім'я файлу з наміром зіпсувати або зламати ваш додаток.


getSanitizedName(): string .[method]
------------------------------------
Повертає саніроване ім'я файлу. Воно містить тільки символи ASCII `[a-zA-Z0-9.-]`. Якщо ім'я не містить таких символів, повертається 'unknown'. Якщо файл є зображенням JPEG, PNG, GIF або WebP, повертається правильне розширення файлу.

.[caution]
Потрібне розширення PHP `fileinfo`.


getSuggestedExtension(): ?string .[method]{data-version:3.2.4}
--------------------------------------------------------------
Повертає відповідне розширення файлу (без крапки), що відповідає виявленому MIME-типу.

.[caution]
Вимагає розширення PHP `fileinfo`.


getUntrustedFullPath(): string .[method]
----------------------------------------
Повертає вихідний повний шлях, вказаний браузером під час завантаження каталогу. Повний шлях доступний тільки в PHP 8.1 і вище. У попередніх версіях цей метод повертає недовірене ім'я файлу.

.[caution]
Не довіряйте значенню, що повертається цим методом. Клієнт може надіслати шкідливе ім'я файлу з наміром зіпсувати або зламати ваш додаток.


getSize(): int .[method]
------------------------
Повертає розмір завантаженого файлу. Якщо завантаження не було успішним, повертається `0`.


getTemporaryFile(): string .[method]
------------------------------------
Повертає шлях до тимчасового місця розташування завантаженого файлу. Якщо завантаження не було успішним, повертається `''`.


isImage(): bool .[method]
-------------------------
Повертає `true`, якщо завантажений файл є зображенням JPEG, PNG, GIF або WebP. Виявлення засноване на його сигнатурі. Цілісність усього файлу не перевіряється. Ви можете дізнатися, чи не пошкоджено зображення, наприклад, спробувавши [завантажити його |#toImage].

.[caution]
Потрібне розширення PHP `fileinfo`.


getImageSize(): ?array .[method]
--------------------------------
Повертає пару `[width, height]` з розмірами завантаженого зображення. Якщо завантаження не було успішним або це не дійсне зображення, повертається `null`.


toImage(): Nette\Utils\Image .[method]
--------------------------------------
Завантажує зображення як об'єкт [Image |utils:images]. Якщо завантаження не було успішним або зображення не є дійсним, викидається виняток `Nette\Utils\ImageException`.
