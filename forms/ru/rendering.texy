Рендеринг форм
**************

Внешний вид форм может сильно отличаться. На самом деле, есть две крайности. Первая — это необходимость заново создавать набор очень похожих форм, практически не прилагая усилий. Как правило, это формы в бэкенде.

С другой стороны — крошечные сладкие формы, каждая из которых — произведение искусства. Их макет лучше всего написать на языке HTML. Конечно, помимо этих крайностей, существует множество форм, находящихся между ними.


Рендерер по умолчанию
=====================

Рендерер автоматически рендерит форму. Он устанавливается методом `setRenderer()` на форме и получает управление при вызове `$form->render()`. Если мы не установили пользовательский рендерер, то используется [api:Nette\Forms\Rendering\DefaultFormRenderer]. Всё, что вам нужно написать, это:

```php
$form->render();
```

или в [#Latte]:

```latte
{control form}
```

и форма живая. Все поля ввода отображаются в таблице HTML. Вывод может выглядеть следующим образом:

```latte
<table>
<tr class="required">
	<th><label class="required" for="frm-name">Имя:</label></th>

	<td><input type="text" class="text" name="name" id="frm-name" value=""></td>
</tr>

<tr class="required">
	<th><label class="required" for="frm-age">Возраст:</label></th>

	<td><input type="text" class="text" name="age" id="frm-age" value=""></td>
</tr>

<tr>
	<th><label>Пол:</label></th>
	...
```

*Хорошо отформатировано, не так ли.? :-)*

Использовать таблицу или нет — решать вам, многие веб-дизайнеры предпочитают другую разметку, например, список. Мы можем настроить `DefaultFormRenderer` так, чтобы он вообще не выводил таблицу. Мы просто должны установить соответствующие «обёртки» ([$wrappers |api:Nette\Forms\Rendering\DefaultFormRenderer::$wrappers]). Первый индекс всегда представляет область, а второй — элемент. Все соответствующие области показаны на рисунке:

[* form-areas-en.webp *]

По умолчанию группа `controls` обёрнута тегом `<table>`, и каждая `pair` представляет собой строку таблицы `<tr>`, содержащую пару `label` и `control` (ячейки `<th>` и `<td>`). Давайте изменим все эти элементы обёртки. Мы завернем `controls` в `<dl>`, оставим `pair` сам по себе, поместим `label` в `<dt>` и поместим `control` в `<dd>`:

```php
$renderer = $form->getRenderer();
$renderer->wrappers['controls']['container'] = 'dl';
$renderer->wrappers['pair']['container'] = null;
$renderer->wrappers['label']['container'] = 'dt';
$renderer->wrappers['control']['container'] = 'dd';

$form->render();
```

В результате получается следующий фрагмент:

```latte
<dl>
	<dt><label class="required" for="frm-name">Имя:</label></dt>

	<dd><input type="text" class="text" name="name" id="frm-name" value=""></dd>


	<dt><label class="required" for="frm-age">Возраст:</label></dt>

	<dd><input type="text" class="text" name="age" id="frm-age" value=""></dd>


	<dt><label>Пол:</label></dt>
	...
</dl>
```

Обёртки могут влиять на многие атрибуты. Например:

- добавлять специальные классы CSS к каждому элементу формы
- различать чётные и нечётные строки
- делать обязательные и необязательные элементы разными
- определять, будут ли сообщения об ошибках отображаться над формой или рядом с каждым элементом


Поддержка Bootstrap
===================

Вы можете найти [примеры |https://github.com/nette/forms/tree/master/examples] настройки форм для [Twitter Bootstrap 2 |https://github.com/nette/forms/blob/a0bc775b96b30780270bdec06396ca985168f11a/examples/bootstrap2-rendering.php#L58], [Bootstrap 3 |https://github.com/nette/forms/blob/a0bc775b96b30780270bdec06396ca985168f11a/examples/bootstrap3-rendering.php#L58] и [Bootstrap 4 |https://github.com/nette/forms/blob/96b3e90/examples/bootstrap4-rendering.php]


Latte
=====

[Движок шаблонов Latte|latte:] значительно облегчает рендеринг форм и их элементов:

```latte
{form myForm}
<table>
<tr n:foreach="$form->controls as $name => $field">
	<th>{label $name /}<th>
	<td>{input $name}</td>
	<td n:ifcontent>{inputError $name}</td>
</tr>
</table>
{/form}
```

Тег `{form}` или `<form n:name>` начинает отрисовку заданной формы. Она также создает локальную переменную `$form` с объектом формы. Закрывающий тег `{/form}` или `</form>` отображает все недорисованные скрытые поля перед завершением формы.

Тег `{input}` отображает любой элемент, включая поля выбора и текстовые области. `{label}` является опционально парным тегом, т. е. `{label}Возраст{/label}`, в этом случае текст также переводится. Тег `{inputError}` печатает сообщение об ошибке при вводе формы.

Также можно «вдохнуть жизнь» в необработанный HTML-ввод с тегом атрибута `n:name`, который связывает его с вводом формы, используя его идентификацию:

```latte
<form n:name=myForm>
	<p>Name: <input size="50" n:name="name"></p>
	<p>Password: <input size="30" n:name="password"></p>
</form>
```

Если вам нужно только отобразить внутреннее содержимое формы без HTML-тегов `<form>` и `</form>`, например, в AJAX-запросе, вы можете открывать и закрывать форму с помощью `{formContext formName} ... {/formContext}`. Он работает аналогично `{form}` в логическом смысле, здесь он позволяет вам использовать другие теги для рисования элементов формы, но в то же время он ничего не рисует.


Код формы `{formPrint}`
-----------------------

Вы также можете генерировать код Latte для формы с помощью тега `{formPrint}`. Если поместить его в шаблон, то вместо обычного шаблона будет отображаться код формы. Затем просто выберите и скопируйте код в свой проект.


Ручной рендеринг
================

Для лучшего контроля над генерируемым кодом можно отрисовывать формы вручную. Разместите форму внутри парных тегов `{form myForm}` и `{/form}`. Входные данные могут быть отображены с помощью тега `{input myInput}`, который отображает входные данные, и `{label myInput /}`, который отображает его метку.

```latte
{form signForm}

<!-- Простая визуализация ошибок -->
<ul class="errors" n:if="$form->hasErrors()">
	<li n:foreach="$form->errors as $error">{$error}</li>
</ul>

<table>
<tr class="required">
	<th>{label name /}</th>
	<td>{input name}</td>
</tr>

<!-- Если вам нужен ручной рендеринг списка радиокнопок -->
<p>{input radioList:itemKey} | {input radioList:itemKeyTwo}</p>

...

</table>
{/form}
```

Вы также можете легко связать форму с шаблоном с помощью атрибута `n:name`.

```php
protected function createComponentSignInForm(): Form
{
	$form = new Form;
	$form->addText('user')->setRequired();
	$form->addPassword('password')->setRequired();
	$form->addSubmit('send');
	return $form;
}
```

```latte
<form n:name=signInForm class=form>
	<p><label n:name=user>Имя пользователя: <input n:name=user size=20></label>
	<p><label n:name=password>Пароль: <input n:name=password></label>
	<p><input n:name=send class="btn btn-default">
</form>
```

Вы также можете использовать `n:name` с элементами `<select>`, `<button>` или `<textarea>` и содержимым.

Вы можете отобразить RadioList, Checkbox или CheckboxList элементами HTML по отдельности. Это называется частичным рендерингом:

```latte
{foreach $form[gender]->items as $key => $label}
	<label n:name="gender:$key"><input n:name="gender:$key"> {$label}</label>
{/foreach}
```

Или вы можете использовать основные теги `{input gender:$key}` и `{label gender:$key}`. Хитрость заключается в использовании двоеточия. Для простого флажка используйте `{input myCheckbox:}`.

Тег `formContainer` помогает в отрисовке вводимых данных внутри контейнера формы.

```latte
{form signForm}
<table>
	<th>Какие новости вы хотите получать:</th>
	<td>
		{formContainer emailNews}
		<ul>
			<li>{input sport} {label sport /}</li>
			<li>{input science} {label science /}</li>
		</ul>
		{/formContainer}
	</td>
	...
</table>
{/form}
```

Как задать дополнительные атрибуты для элементов HTML? Методы `getControl()` и `getLabel()` возвращают элемент как объект `Nette\Utils\Html`, который можно [легко настроить |utils:html-elements]. В Latte:

```latte
{form signForm class: 'big'}
<table>
<tr class="required">
	<th>{label name /}</th>
	<td>{input name cols: 40, autofocus: true}</td>
</tr>
```


Группировка элементов ввода
===========================

Поля ввода можно объединить в наборы визуальных полей, создав группу:

```php
$form->addGroup('Персональные данные');
```

Создание новой группы активирует её — все добавленные далее элементы добавляются в эту группу. Вы можете построить форму следующим образом:

```php
$form = new Form;
$form->addGroup('Персональные данные');
$form->addText('name', 'Ваше имя:');
$form->addInteger('age', 'Ваш возраст:');
$form->addEmail('email', 'Имейл:');

$form->addGroup('Адрес доставки');
$form->addCheckbox('send', 'Отправить по адресу');
$form->addText('street', 'Улица:');
$form->addText('city', 'Город:');
$form->addSelect('country', 'Страна:', $countries);
```


Атрибуты HTML
=============

Вы можете установить любые атрибуты HTML для элементов управления формы, используя `setHtmlAttribute(string $name, $value = true)`:

```php
$form->addInteger('number', 'Количество:')
	->setHtmlAttribute('class', 'bigNumbers');

$form->addSelect('rank', 'Заказать:', ['price', 'name'])
	->setHtmlAttribute('onchange', 'submit()'); // вызывает JS-функцию submit() при изменении


// применяется на <form>
$form->setHtmlAttribute('id', 'myForm');
```

Установка типа входа:

```php
$form->addText('tel', 'Ваш телефон:')
	->setHtmlType('tel')
	->setHtmlAttribute('placeholder', 'Пожалуйста, заполните ваш телефон');
```

Мы можем установить HTML-атрибут для отдельных элементов в списках радио- или чекбоксов с разными значениями для каждого из них.
Обратите внимание на двоеточие после `style:`, чтобы убедиться, что значение выбирается по ключу:

```php
$colors = ['r' => 'red', 'g' => 'green', 'b' => 'blue'];
$styles = ['r' => 'background:red', 'g' => 'background:green'];
$form->addCheckboxList('colors', 'Цвета:', $colors)
	->setHtmlAttribute('style:', $styles);
```

Отображается как:

```latte
<label><input type="checkbox" name="colors[]" style="background:red" value="r">red</label>
<label><input type="checkbox" name="colors[]" style="background:green" value="g">green</label>
<label><input type="checkbox" name="colors[]" value="b">blue</label>
```

Для логического атрибута HTML (который не имеет значения, например, `readonly`) можно использовать вопросительный знак:

```php
$colors = ['r' => 'red', 'g' => 'green', 'b' => 'blue'];
$form->addCheckboxList('colors', 'Цвета:', $colors)
	->setHtmlAttribute('readonly?', 'r'); // использовать массив для нескольких ключей, например ['r', 'g']
```

Отображается как:

```latte
<label><input type="checkbox" name="colors[]" readonly value="r">red</label>
<label><input type="checkbox" name="colors[]" value="g">green</label>
<label><input type="checkbox" name="colors[]" value="b">blue</label>
```

Для селекбоксов метод `setHtmlAttribute()` устанавливает атрибуты элемента `<select>`. Если мы хотим установить атрибуты для каждого
`<option>`, мы будем использовать метод `setOptionAttribute()`. Кроме того, двоеточие и вопросительный знак, использованные выше, работают:

```php
$form->addSelect('colors', 'Цвета:', $colors)
	->setOptionAttribute('style:', $styles);
```

Отображается как:

```latte
<select name="colors">
	<option value="r" style="background:red">red</option>
	<option value="g" style="background:green">green</option>
	<option value="b">blue</option>
</select>
```


Другие настройки
================

Описание настройки (по умолчанию отображается после ввода):

```php
$form->addText('phone', 'Номер:')
	->setOption('description', 'Этот номер останется скрытым');
```

Если мы хотим поместить в него HTML-контент, мы используем класс [Html |utils:html-elements].

```php
use Nette\Utils\Html;

$form->addText('phone', 'Телефон:')
	->setOption('description', Html::el('p')
		->setHtml('Этот номер остается скрытым. <a href="...">Условия предоставления услуг.</a>')
	);
```

.[tip]
Html-элемент также можно использовать вместо label: `$form->addCheckbox('conditions', $label)`.


Без Latte
=========

Каждый элемент имеет методы 'getLabel()' и 'getControl()', которые возвращают HTML-код метки и сам элемент. Nette предоставляет доступ к свойствам *getter* и *setter*, как если бы вы [обращались к самому атрибуту |utils:smartobject#Свойства, геттеры и сеттеры].

```php
<?php $form->render('begin') ?>
<?php $form->render('errors') ?>

<table>
<tr class="required">
	<th><?php echo $form['name']->label // Вызывает getLabel() ?></th>
	<td><?php echo $form['name']->control // Вызывает getControl()  ?></td>
</tr>

<tr class="required">
	<th><?php echo $form['age']->label ?></th>
	<td><?php echo $form['age']->control ?></td>
</tr>

// ...

</table>

<?php $form->render('end') ?>
```


Событие onRender
================

Непосредственно перед отображением формы мы можем вызвать наш код. Это может, например, добавить HTML-классы к элементам формы для правильного отображения. Добавим код в массив 'onRender':

```php
$form->onRender[] = function ($form) {
	BootstrapCSS::initialize($form);
};
```
