Formuláře samostatně
********************

.[perex]
Nette Forms zásadně usnadňují vytváření a zpracování webových formulářů ve vašich aplikacích. V této kapitole se seznámíte s používáním formulářů samostatně bez vazby na Nette Application.

Pokud ale používáte presentery a Nette Application, je pro vás určen návod pro [použití v presenterech|form-presenter].

Instalace:

```shell
composer require nette/forms
```

První formulář
==============

Zkusíme si napsat jednoduchý registrační formulář. Jeho kód bude vypadat takto:

```php
use Nette\Forms\Form;

$form = new Form;
$form->addText('name', 'Jméno:');
$form->addPassword('password', 'Heslo:');
$form->addSubmit('send', 'Registrovat');
```

Velmi snadno ho vykreslíme:

```php
$form->render();
```

a v prohlížeči bude vypadat takto:

[* form-cs.png *]

Teď formulář oživíme. Dotazem na `$form->isSuccess()` zjistíme, zda byl formulář odeslán a zda byl vyplněn korektně. Pokud bude formulář správně vyplněn, data vypíšeme do okna prohlížeče. Za definici formuláře tedy dopíšeme:

```php
if ($form->isSuccess()) {
	echo 'Formulář byl správně vyplněn a odeslán';
	$data = $form->getValues();
	// $data->name obsahuje jméno
	// $data->password obsahuje heslo
	var_dump($data);
}
```

Metoda `getValues()` vrací odeslaná data v podobě objektu [ArrayHash |arrays#ArrayHash]. Jak to změnit si ukážeme [později|#Mapování na třídy]. Proměnná `$data` obsahuje klíče `name` a `password` s údaji, které vyplnil uživatel. Obvykle data rovnou posíláme k dalšímu zpracování, jako je například vložení do databáze.

Po zpracování formuláře přesměrujeme na další stránku. Zabrání se tak nechtěnému opětovnému odeslání formuláře tlačítkem Obnovit, Zpět nebo pohybem v historii prohlížeče.

Formulář se standardně odesílá metodou POST na stejnou stránku. To se dá snadno změnit:

```php
$form->setAction('/submit.php');
$form->setMethod('GET');
```

A to je vlastně vše :-) Máme funkční a perfektně [zabezpečený|#Ochrana před zranitelnostmi] formulář.


Přístup k prvkům
================

Formulář i jednotlivé jeho prvky nazýváme komponenty. Tvoří komponentový strom, kde kořenem je právě formulář. K jednotlivým prvkům formuláře se dostanete tímto způsobem:

```php
$input = $form->getComponent('name');
// alternativní syntax: $input = $form['name'];

$button = $form->getComponent('send');
// alternativní syntax: $button = $form['send'];
```


Validační pravidla
==================

Několikrát tu padlo slovo *validní,* ale formulář zatím žádná validační pravidla nemá. Pojďme to napravit.

Jméno bude povinné, proto je označíme metodou `setRequired()`, jejíž volitelný argument je vlastní text chybové hlášky, která se zobrazí, pokud uživatel jméno nevyplní. Pokud argument neuvedeme, použije se výchozí chybová hláška.

```php
$form->addText('name', 'Jméno:')
	->setRequired('Zadejte prosím jméno');
```

Zkuste si odeslat formulář bez vyplněného jména a uvidíte, že se zobrazí chybová hláška a prohlížeč či server jej bude odmítat do té doby, dokud políčko nevyplníte.

Zároveň systém neošidíte tím, že do políčka napíšete třeba jen mezery. Kdepak. Nette levo- i pravostranné mezery automaticky odstraňuje. Vyzkoušejte si to. Je to věc, kterou byste měli s každým jednořádkovým inputem vždy udělat, ale často se na to zapomíná. Nette to dělá automaticky.

Formulář se vždy validuje na straně serveru, ale také generuje JavaScriptovou validaci na straně prohlížeče, která proběhne bleskově a uživatel se o chybě dozví okamžitě, bez nutnosti formulář odesílat na server. Tohle má na starosti skript `netteForms.js`.
Vložte jej do stránky:

```html
<script src="https://nette.github.io/resources/js/3/netteForms.min.js"></script>
```

Pokud se podíváte do zdrojového kódu stránky, můžete si všimnout, že Nette povinné prvky vkládá do elementu s CSS třídou `required`. Zkuste přidat do šablony následující stylopis a popiska „Jméno“ bude červená. Elegantně tak uživateli označíme povinné prvky:

```html
<style>
.required label { color: maroon }
</style>
```

Další validační pravidla přidáme metodou `addRule()`. První parametr je [pravidlo|form-validation#pravidla], druhý je opět vlastní text chybové hlášky a může ještě následovat argument validačního pravidla.

Formulář rozšíříme o nové nepovinné políčko „věk“, které musí být celé číslo (`addInteger()`) a navíc v povoleném rozsahu (`$form::RANGE`). Zde využijeme třetí parametr metody `addRule()`, kterým předáme validátoru požadovaný rozsah jako dvojici `[od, do]`:

```php
$form->addInteger('age', 'Věk:')
	->addRule($form::RANGE, 'Věk musí být od 18 do 120', [18, 120]);
```

.[tip]
Pokud uživatel políčko nevyplní, nebudou se validační pravidla ověřovat, neboť prvek je nepovinný.

Zde vzniká prostor pro drobný refactoring. V chybové hlášce a ve třetím parametru jsou čísla uvedená duplicitně, což není ideální. Pokud bychom tvořili [vícejazyčné formuláře |translations] a hláška obsahující čísla by se musela přeložit do více jazyků, ztížila by se pozdější změna hodnot. Z toho důvodu je možné použít zástupné znaky `%d` a Nette hodnoty doplní:

```php
	->addRule($form::RANGE, 'Věk musí být od %d do %d let', [18, 120]);
```

Vraťme se k prvku `password`, který taktéž učiníme povinným a ještě ověříme minimální délku hesla (`$form::MIN_LENGTH`), opět s využitím zástupného znaku:

```php
$form->addPassword('password', 'Heslo:')
	->setRequired('Zvolte si heslo')
	->addRule($form::MIN_LENGTH, 'Heslo musí mít alespoň %d znaků', 8);
```

Přidáme do formuláře ještě políčko `passwordVerify`, kde uživatel zadá heslo ještě jednou, pro kontrolu. Pomocí validačních pravidel zkontrolujeme, zda jsou obě hesla stejná (`$form::EQUAL`). Všimněte si dynamické odvolávky na první heslo pomocí [hranatých závorek|#Přístup k prvkům]:

```php
$form->addPassword('passwordVerify', 'Heslo pro kontrolu:')
	->setRequired('Zadejte prosím heslo ještě jednou pro kontrolu')
	->addRule($form::EQUAL, 'Hesla se neshodují', $form['password'])
	->setOmitted(); // po validaci údaj zahodí a nepředá do $data
```

Tímto máme hotový plně funkční formulář, který disponuje na chlup stejnou validací na straně prohlížeče i serveru. Automaticky ošetřuje zda útočník neposílá nevalidní UTF-8 řetězce apod., nepodvrhuje formulář z jiné domény, atd. Na tyto věci prostě nemusíte myslet, dělá je Nette za vás.

Zkuste si přidat i další [formulářové prvky|form-fields]. Inspiraci najdete také v distribuci v adresáři [examples|https://github.com/nette/forms/tree/master/examples].


Výchozí hodnoty
===============

Prvkům formuláře běžne nastavujeme výchozí hodnoty. Třeba když formulář slouží k editaci záznamů. Přečteme jej z databáze a předáme formuláři jako pole výchozích hodnot:

```php
$items = [
	'name' => 'John',
	'age' => '33'
];
$form->setDefaults($items);
```

Volejte `setDefaults()` až po definici prvků.

Metodou `setDefaultValue()` lze nastavit výchozí hodnotu jednotlivým prvkům:

```php
$form->addEmail('email', 'E-mail')
	->setDefaultValue('user@example.com');
```


Vykreslení formuláře
====================

Standardně se formulář vykreslí jako tabulka. Jednotlivé prvky splňují základní pravidlo přístupnosti - všechny popisky jsou zapsány jako `<label>` a provázané s příslušným formulářovým prvkem. Při kliknutí na popisku se kurzor automaticky objeví ve formulářovém políčku.

Každému prvku můžeme nastavovat libovolné HTML atributy. Třeba přidat placeholder:

```php
$form->addInteger('age', 'Věk:')
	->setHtmlAttribute('placeholder', 'Prosím vyplňte věk');
```

Způsobů, jak vykreslit formulář, je opravdu velké množství, takže je tomu věnována [samostatná kapitola o vykreslování|form-rendering].


Mapování na třídy
=================

Vraťme se ke zpracování formulářových dat. Metoda `getValues()` nám vracela objekt `ArrayHash` s odeslanými daty. Protože jde o generický objekt, něco jako `stdClass`, nebude nám samozřejmě fungovat našeptávání nebo [statická analýza kódu|editors-and-tools#PHPStan].
Šikovnější by proto bylo vytvořit si pro každý formulář třídu, kde properties představují jednotlivé prvky. Např.:

```php
class RegistrationFormData
{
	/** @var string */
	public $name;
	/** @var int */
	public $age;
	/** @var string */
	public $password;
}
```

Nyní nám stačí tuto třídu uvést jako parametr `getValue()` a ejhle, Nette vytvoří a vrátí právě tento objekt:

```php
$data = $form->getValues(RegistrationFormData::class);
$name = $data->name;
```

Naopak pokud by vám více vyhovovalo získat data jako čisté pole, uveďte jako parametr `'array'`.


Více tlačítek
=============

Pokud má formulář více než jedno tlačítko, potřebujeme zpravidla rozlišit, které z nich bylo stlačeno. Tuto informaci nám vrátí metoda `isSubmittedBy()` tlačítka:

```php
$form->addSubmit('save', 'Uložit');
$form->addSubmit('delete', 'Smazat');

if ($form->isSuccess()) {
	if ($form['save']->isSubmittedBy()) {
		....
	}

	if ($form['delete']->isSubmittedBy()) {
		....
	}
}
```

Dotaz na `$form->isSuccess()` nevynechejte, ověříte tím, že data formuláře jsou validní.

Když se formulář odešle tlačítkem *enter*, za odesílací tlačítko se považuje to první.



Ochrana před zranitelnostmi
===========================

Nette Framework klade velký důraz na bezpečnost a proto úzkostlivě dbá i na dobré zabezpečení formulářů. Dělá to zcela transparentně a nevyžaduje manuálně nic nastavovat. Ochrání vaše aplikace před útokem [Cross Site Scripting (XSS) |vulnerability-protection#cross-site-scripting-xss] i [Cross-Site Request Forgery (CSRF)|vulnerability-protection#Cross-Site Request Forgery (CSRF)], odfiltruje ze vstupů kontrolní znaky, ověří validitu UTF-8 kódování nebo jestli nejsou položky vybrané v select boxech podvržené atd.

CSRF útok spočívá v tom, že útočník naláká oběť na stránku, která nenápadně v prohlížeči oběti vykoná požadavek na server, na kterém je oběť přihlášena, a server se domnívá, že požadavek vykonala oběť o své vůli. Doporučujeme takto chránit formuláře v administrační části webu, které mění citlivá data v aplikaci.

Ochranu přes CSRF útokem zajistí metoda `addProtection()`.

```php
$form->addProtection();
```

Framework se proti útoku CSRF brání vygenerováním a ověřováním autorizačního tokenu, který se ukládá do session. Proto je nutné před zobrazením formuláře mít otevřenou session. V administrační části webu obvykle už session nastartovaná je kvůli přihlášení uživatele.
Jinak session nastartujte metodou `Nette\Http\Session::start()`.


{{composer: nette/forms}}
