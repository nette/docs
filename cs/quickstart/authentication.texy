Přihlašování
************

Nette poskytuje základní postup, jak vyřešit přihlašování na vaší stránce, ale nelpí na konkrétní implementaci. Středobodem přihlašování je interface `Nette\Security\IAuthenticator`, kterému je potřeba definovat jedinou metodu `authenticate`.

Konkrétních implementací přihlašování uživatele je spousta. Nejběžnější z nich je jistě *přihlášení uživatelským jménem a heslem*, ale lze využít i jiné. Z mnoha webů určitě znáte tlačítko "Přihlásit přes Facebook", přihlašovat se lze i přes další webové služby, jako třeba Google, Twitter, Github... S Nette můžete využít kteroukoliv zmíněný (i nezmíněný) způsob přihlašování a dokonce můžete dát uživatelům na výběr, který způsob si vybrat. Je to jen na vás.

Na "běžném" webovém projektu byste si jistě chtěli napsat vlastní implementaci rozhraní, ale pro náš malý blog si vystačíme s třídou `SimpleAuthenticator`, která je součástí distribuce Nette. Třída poskytuje přihlášení jménem a heslem a seznam jmen a hesel je uložen v konfiguračním souboru.Do souboru `config.neon` přidejte sekci *security* (a nezapomeňte změnit heslo):


/--neon
	nette:
		security:
			users:
				admin: secret  # user 'admin', password 'secret'
\--

Nette automaticky vytvoří v DI kontejneru službu `authenticator`.

.[note]
V dokumentaci Nette se můžete více dozvědět o [Dependency Injection tady |cs/dependency-injection] a o [konfiguraci tady |cs/configuring]


Přihlašovací formulář
===

Máme připravené pozadí přihlašování, teď musíme uživatelům nabídnout místo, kde se budou moci přihlásit. Pojďme vytvořit presenter pojmenovaný *SignPresenter*, který:

- zobrazí přihlašovací formulář (kde bude uživatel moci zadat uživatelské jméno a heslo),
- ověří uživatelovy přihlašovací údaje po odeslání přihlašovacího formuláře,
- poskytne akci odhlášení uživatele.

To je ale náhoda, jeden takový je už připravený ve výchozím sandboxu! Tak ho prostě použijeme. Podívejme se, jak funguje:

Začněme přihlašovacím formulářem. Jak formuláře v presenteru fungují už víme. Otevřete si `SignPresenter` a najděte metodu `createComponentSignInForm`. Měla by vypadat takhle:

/--php
	protected function createComponentSignInForm()
	{
		$form = new Form;
		$form->addText('username', 'Username:')
			->setRequired('Please enter your username.');

		$form->addPassword('password', 'Password:')
			->setRequired('Please enter your password.');

		$form->addCheckbox('remember', 'Keep me signed in');

		$form->addSubmit('send', 'Sign in');

		// call method signInFormSucceeded() on success
		$form->onSuccess[] = $this->signInFormSucceeded;
		return $form;
	}
\--

Máme tu formulářová pole pro uživatelské jméno a heslo. Checkbox pro zapamatování uživatele můžete klidně smazat, pokud ho nebudete potřebovat.


View
---

Formulář se vykresluje v šabloně `app/templates/Sign/in.latte`

/--html
{block #content}
<h1 n:block=title>Sign in</h1>

{control signInForm}
\--


Zpracování přihlašování
----

V presenteru je připraven i *formulářový handler* pro přihlášení uživatele. Ten se volá hned po odeslání formuláře. Předpřipravená metoda také prodlouží platnost přihlášení, pokud uživatel zaškrtl checkbox "Remember" ve výchozím přihlašovacím formuláři.
Pokud jste výše checkbox smazali, odstraňte i řádky prodloužení platnosti.

Handler přepošle jméno a heslo které uživatel zadal službě authenticator, kterou jsme si nadefinovali výše. Pokud přihlášení prošlo úspěšně, přesměruje uživatele na hlavní stránku.

Nesmíme zapomenout na zpracování chyb při přihlášení. Všimněme si `try catch` bloku.
Metoda [User::login() | api:Nette\Security\User::login()] by měla vyhodit výjimku, pokud jméno nebo heslo neodpovídá tomu, co je nastaveno v konfiguraci. Jak víme, neodchycená výjimka by skončila červenou obrazovkou Tracy, nebo, v produkčním módu, zprávou s návratovým kódem 500 o chybě na straně serveru. To bychom jistě nechtěli. Proto musíme očekávanou výjimku odchytit a lidskou chybovou hlášku předat zpět do formuláře.

Jakmile ve formuláři dojde k chybě, stránka s ním se vykreslí znovu a nad formulářem se vypíše chybová hláška, která uživatele upozorní, že zadal špaté jméno nebo heslo.

/--php
	public function signInFormSucceeded($form)
	{
		$values = $form->values;

		try {
			$this->getUser()->login($values->username, $values->password);
			$this->redirect('Homepage:');

		} catch (Nette\Security\AuthenticationException $e) {
			$form->addError('Incorrect username or password.');
		}
	}
\--


Formulář příspěvku
===

Začněme ochranou formuláře, pomocí kterého přidáváme nové příspěvky. Ten je definován v presenteru `PostPresenter` a vykresluje se v souboru `app/templates/Post/create.latte`. Naším cílem je nedovolit nepřihlášeným uživatelům zobrazení stránky s formulářem.


Views presenteru
---

Vytvoříme *akční metodu* pojmenovanou `actionCreate`. Ta přesměruje nepřihlášeného uživatele na přihlašovací formulář a tím vynutí přihlášení, pokud chce uživatel přidávat příspěvky.

/--php
	public function actionCreate()
	{
		if (!$this->user->isLoggedIn()) {
			$this->redirect('Sign:in');
		}
	}
\--

Přidáním stejných tří řádek ochráníme editaci příspěvku.

/--php
	public function actionEdit($postId)
	{
		if (!$this->user->isLoggedIn()) {
			$this->redirect('Sign:in');
		}
\--


Skrytí odkazů
----

Nepřihlášený uživatel by určitě neměl vidět odkazy pro vytvoření a editaci příspěvků, ale stále by měl vidět odkazy sa příspěvky samotné. Pojďme "nepohodlné" odkazy nepřihlášeným uživatelům schovat.Jeden takový je v šabloně `app/templates/Homepage/default.latte`.

Schováme ho pomocí *n:makra* `n:if`. Toto makro skryje celý HTML element (v našem případě `<a>`), pokud je výraz uvnitř `false.

/--html
<a n:href="Post:create" n:if="$user->loggedIn">Create post</a>
\--

to celé je zkratka pro zápis

/--html
{if $user->loggedIn}<a n:href="Post:create">Create post</a>{/if}
\--

Stejným způsobem skryjte link na úpravu příspěvku v šabloně `app/templates/Post/show.latte`.


Formulářové handlery
---

Poslední, ale **nejdůležitější** část práce této kapitoly je **ochránění formulářových handlerů**. Protože komponenty, kterými jsou i formuláře, jsou znovupoužitelné, mohou být vykresleny ve více views. A protože mohou být vykresleny ve více views, mohou být taky odeslány ze všech views, kde jsou použity, dokonce i z views, které neexistují. To znamená, že i když se view `create` nevykreslí, změnou URL může útočník formulář stejně odeslat a tím přidávat/měnit příspěvky.

Tomu můžeme zabránit jednoduchým *if*em, který přidáme na začátek metody `postFormSucceeded`

/--php
	public function postFormSucceeded($form)
	{
		if (!$this->user->isLoggedIn()) {
			$this->error('You need to log in to create or edit posts');
		}
\--

Opravdu je to takhle jednoduché. Ale **nikdy to nesmíte zapomenout udělat**, pro ochránění vaší aplikace je to naprosto zásadní.


Odkaz na přihlášení
====

Jak se ale dostaneme na přihlašovací stránku, když na ni nevede žádný odkaz? Přidejme ho do šablony `app/templates/@layout.latte`. Můžete ho přidat kamkoliv, kde se vám bude nejvíce líbit.

/--html
<ul class="navig">
	<li><a n:href="Homepage:">Homepage</a></li>
	{if $user->loggedIn}
		<li><a n:href="Sign:out">Sign out</a></li>
	{else}
		<li><a n:href="Sign:in">Sign in</a></li>
	{/if}
</ul>
\--

Pokud uživatel ještě není přihlášený, zobrazíme mu odkaz na přihlášení. Jinak mu nabídneme odhlášení, o které se postará metoda SignPresenteru nadefinovaná ve výchozím sandboxu.

Odhlašovací metoda vypadá následovně (a protože hned po odhlášení uživatele přesměruje na hlavní stránku, nepotřebuje ani šablonu):

/--php
	public function actionOut()
	{
		$this->getUser()->logout();
		$this->flashMessage('You have been signed out.');
		$this->redirect('Homepage:');
	}
\--

Prostě uživatele odhlásí a na hlavní stránce mu to dá vědět pěknou hláškou.


Shrnutí
=======

Na každé stránce máme odkaz, který nepřihlášeného uživatele zavede na přihlašovací formulář. Zde uživatel zadá své přihlašovací údaje. Použili jsme implementaci *SimpleAuthenticator* a uživatelská jména a hesla máme uložená v konfiguračním souboru, protože je to pohodlné a zatím neřešíme dynamickou správu uživatelů. Také jsme ošetřili všechny vstupní body aplikace (stránky i formuláře), kam se nesmí dostat nepřihlášený uživatel, takže příspěvky může přidávat a upravovat jen ten, kdo se úspěšně přihlásí.
