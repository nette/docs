Global Durum ve Singleton'lar
*****************************

.[perex]
UyarÄ±: AÅŸaÄŸÄ±daki yapÄ±lar kÃ¶tÃ¼ tasarlanmÄ±ÅŸ kodun iÅŸaretidir:

- `Foo::getInstance()`
- `DB::insert(...)`
- `Article::setDb($db)`
- `ClassName::$var` veya `static::$var`

Bu yapÄ±lardan bazÄ±larÄ± kodunuzda bulunuyor mu? O zaman onu iyileÅŸtirme fÄ±rsatÄ±nÄ±z var. Belki de bunlarÄ±n, Ã§eÅŸitli kÃ¼tÃ¼phanelerin ve framework'lerin Ã¶rnek Ã§Ã¶zÃ¼mlerinde bile gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z yaygÄ±n yapÄ±lar olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorsunuzdur. EÄŸer durum buysa, o zaman kodlarÄ±nÄ±n tasarÄ±mÄ± iyi deÄŸildir.

Åimdi kesinlikle bir tÃ¼r akademik saflÄ±ktan bahsetmiyoruz. TÃ¼m bu yapÄ±larÄ±n ortak bir yanÄ± var: global durumu kullanÄ±yorlar. Ve bunun kod kalitesi Ã¼zerinde yÄ±kÄ±cÄ± bir etkisi var. SÄ±nÄ±flar baÄŸÄ±mlÄ±lÄ±klarÄ± hakkÄ±nda yalan sÃ¶ylÃ¼yor. Kod Ã¶ngÃ¶rÃ¼lemez hale geliyor. ProgramcÄ±larÄ± ÅŸaÅŸÄ±rtÄ±yor ve verimliliklerini dÃ¼ÅŸÃ¼rÃ¼yor.

Bu bÃ¶lÃ¼mde, neden bÃ¶yle olduÄŸunu ve global durumdan nasÄ±l kaÃ§Ä±nÄ±lacaÄŸÄ±nÄ± aÃ§Ä±klayacaÄŸÄ±z.


Global BaÄŸlantÄ±
---------------

Ä°deal bir dÃ¼nyada, bir nesne yalnÄ±zca [doÄŸrudan aktarÄ±lan |passing-dependencies] nesnelerle iletiÅŸim kurabilmelidir. EÄŸer iki `A` ve `B` nesnesi oluÅŸturursam ve aralarÄ±nda asla bir referans aktarmazsam, o zaman ne `A` ne de `B`, diÄŸer nesneye eriÅŸemez veya durumunu deÄŸiÅŸtiremez. Bu, kodun Ã§ok istenen bir Ã¶zelliÄŸidir. Bu, bir piliniz ve bir ampulÃ¼nÃ¼z olmasÄ±na benzer; ampulÃ¼ pille bir telle baÄŸlamadÄ±ÄŸÄ±nÄ±z sÃ¼rece yanmaz.

Ancak bu, global (statik) deÄŸiÅŸkenler veya singleton'lar iÃ§in geÃ§erli deÄŸildir. `A` nesnesi, `C::changeSomething()` Ã§aÄŸÄ±rarak herhangi bir referans aktarÄ±mÄ± olmadan *kablosuz olarak* `C` nesnesine eriÅŸebilir ve onu deÄŸiÅŸtirebilir. EÄŸer `B` nesnesi de global `C`'yi ele geÃ§irirse, o zaman `A` ve `B` birbirini `C` aracÄ±lÄ±ÄŸÄ±yla etkileyebilir.

Global deÄŸiÅŸkenlerin kullanÄ±mÄ±, sisteme dÄ±ÅŸarÄ±dan gÃ¶rÃ¼nmeyen yeni bir *kablosuz* baÄŸlantÄ± formu katar. Kodun anlaÅŸÄ±lmasÄ±nÄ± ve kullanÄ±lmasÄ±nÄ± zorlaÅŸtÄ±ran bir sis perdesi oluÅŸturur. GeliÅŸtiricilerin baÄŸÄ±mlÄ±lÄ±klarÄ± gerÃ§ekten anlamalarÄ± iÃ§in, kaynak kodunun her satÄ±rÄ±nÄ± okumalarÄ± gerekir. Sadece sÄ±nÄ±f arayÃ¼zleriyle tanÄ±ÅŸmak yerine. Ãœstelik bu tamamen gereksiz bir baÄŸlantÄ±dÄ±r. Global durum, her yerden kolayca eriÅŸilebilir olduÄŸu ve Ã¶rneÄŸin `DB::insert()` global (statik) metodu aracÄ±lÄ±ÄŸÄ±yla veritabanÄ±na yazmaya izin verdiÄŸi iÃ§in kullanÄ±lÄ±r. Ama gÃ¶stereceÄŸimiz gibi, bunun getirdiÄŸi avantaj Ã¶nemsizdir, aksine neden olduÄŸu komplikasyonlar Ã¶lÃ¼mcÃ¼ldÃ¼r.

.[note]
DavranÄ±ÅŸ aÃ§Ä±sÄ±ndan global ve statik deÄŸiÅŸken arasÄ±nda bir fark yoktur. EÅŸit derecede zararlÄ±dÄ±rlar.


Uzaktan ÃœrkÃ¼tÃ¼cÃ¼ Etki
---------------------

"Uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ etki" - 1935'te Albert Einstein, kuantum fiziÄŸinde tÃ¼ylerini diken diken eden bir olguyu bu ÅŸekilde Ã¼nlÃ¼ bir ÅŸekilde adlandÄ±rdÄ±.
Bu, kuantum dolaÅŸÄ±klÄ±ÄŸÄ±dÄ±r ve Ã¶zelliÄŸi, bir parÃ§acÄ±k hakkÄ±ndaki bilgiyi Ã¶lÃ§tÃ¼ÄŸÃ¼nÃ¼zde, milyonlarca Ä±ÅŸÄ±k yÄ±lÄ± uzakta olsalar bile diÄŸer parÃ§acÄ±ÄŸÄ± anÄ±nda etkilemenizdir.
Bu, gÃ¶rÃ¼nÃ¼ÅŸte evrenin temel yasasÄ±nÄ±, yani hiÃ§bir ÅŸeyin Ä±ÅŸÄ±ktan daha hÄ±zlÄ± yayÄ±lamayacaÄŸÄ±nÄ± ihlal eder.

YazÄ±lÄ±m dÃ¼nyasÄ±nda, "uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ etki" olarak, izole olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼z (Ã§Ã¼nkÃ¼ ona hiÃ§bir referans aktarmadÄ±k) bir sÃ¼reci baÅŸlattÄ±ÄŸÄ±mÄ±zda, ancak sistemin uzak yerlerinde haberimiz olmayan beklenmedik etkileÅŸimlerin ve durum deÄŸiÅŸikliklerinin meydana geldiÄŸi durumu adlandÄ±rabiliriz. Bu, yalnÄ±zca global durum aracÄ±lÄ±ÄŸÄ±yla meydana gelebilir.

GeniÅŸ, olgun bir kod tabanÄ±na sahip bir projenin geliÅŸtirici ekibine katÄ±ldÄ±ÄŸÄ±nÄ±zÄ± hayal edin. Yeni yÃ¶neticiniz sizden yeni bir Ã¶zellik uygulamanÄ±zÄ± ister ve siz de doÄŸru bir geliÅŸtirici olarak test yazarak baÅŸlarsÄ±nÄ±z. Ama projede yeni olduÄŸunuz iÃ§in, "bu metodu Ã§aÄŸÄ±rÄ±rsam ne olur" tÃ¼rÃ¼nde bir sÃ¼rÃ¼ keÅŸif testi yaparsÄ±nÄ±z. Ve aÅŸaÄŸÄ±daki testi yazmayÄ± denersiniz:

```php
function testCreditCardCharge()
{
	$cc = new CreditCard('1234567890123456', 5, 2028); // kart numaranÄ±z
	$cc->charge(100);
}
```

Kodu Ã§alÄ±ÅŸtÄ±rÄ±rsÄ±nÄ±z, belki birkaÃ§ kez, ve bir sÃ¼re sonra cep telefonunuzda bankadan bildirimler fark edersiniz, her Ã§alÄ±ÅŸtÄ±rmada Ã¶deme kartÄ±nÄ±zdan 100 dolar Ã§ekildiÄŸini ğŸ¤¦â€â™‚ï¸

TanrÄ± aÅŸkÄ±na nasÄ±l test gerÃ§ek para Ã§ekme iÅŸlemine neden olabilir? Ã–deme kartÄ±yla iÅŸlem yapmak kolay deÄŸildir. ÃœÃ§Ã¼ncÃ¼ taraf bir web servisiyle iletiÅŸim kurmanÄ±z, bu web servisinin URL'sini bilmeniz, giriÅŸ yapmanÄ±z vb. gerekir.
Bu bilgilerin hiÃ§biri testte yer almaz. Daha da kÃ¶tÃ¼sÃ¼, bu bilgilerin nerede bulunduÄŸunu bile bilmiyorsunuz ve dolayÄ±sÄ±yla her Ã§alÄ±ÅŸtÄ±rmanÄ±n tekrar 100 dolar Ã§ekilmesine yol aÃ§mamasÄ± iÃ§in dÄ±ÅŸ baÄŸÄ±mlÄ±lÄ±klarÄ± nasÄ±l mocklayacaÄŸÄ±nÄ±zÄ± da bilmiyorsunuz. Ve yeni bir geliÅŸtirici olarak, yapmaya hazÄ±rlandÄ±ÄŸÄ±nÄ±z ÅŸeyin sizi 100 dolar daha fakir yapacaÄŸÄ±nÄ± nasÄ±l bilmeliydiniz?

Bu uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ etki!

Yapmaktan baÅŸka Ã§areniz yok, uzun sÃ¼re bir sÃ¼rÃ¼ kaynak kodunu eÅŸelemek, daha yaÅŸlÄ± ve deneyimli meslektaÅŸlara sormak, projedeki baÄŸlantÄ±larÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlayana kadar.
Bu, `CreditCard` sÄ±nÄ±fÄ±nÄ±n arayÃ¼zÃ¼ne bakÄ±ldÄ±ÄŸÄ±nda, baÅŸlatÄ±lmasÄ± gereken global durumu tespit etmenin mÃ¼mkÃ¼n olmamasÄ±ndan kaynaklanmaktadÄ±r. Hatta sÄ±nÄ±fÄ±n kaynak koduna bakmak bile hangi baÅŸlatma metodunu Ã§aÄŸÄ±rmanÄ±z gerektiÄŸini aÃ§Ä±ÄŸa Ã§Ä±karmaz. En iyi durumda, eriÅŸilen bir global deÄŸiÅŸken bulabilir ve ondan nasÄ±l baÅŸlatÄ±lacaÄŸÄ±nÄ± tahmin etmeye Ã§alÄ±ÅŸabilirsiniz.

BÃ¶yle bir projedeki sÄ±nÄ±flar patolojik yalancÄ±lardÄ±r. Ã–deme kartÄ±, sadece Ã¶rneklenip `charge()` metodunun Ã§aÄŸrÄ±lmasÄ±nÄ±n yeterliymiÅŸ gibi davranÄ±r. Ancak gizlice, Ã¶deme aÄŸ geÃ§idini temsil eden baÅŸka bir `PaymentGateway` sÄ±nÄ±fÄ±yla iÅŸbirliÄŸi yapar. Onun arayÃ¼zÃ¼ de baÄŸÄ±msÄ±z olarak baÅŸlatÄ±labileceÄŸini sÃ¶yler, ancak gerÃ§ekte kimlik bilgilerini bir yapÄ±landÄ±rma dosyasÄ±ndan Ã§eker vb.
Bu kodu yazan geliÅŸtiricilere, `CreditCard`'Ä±n `PaymentGateway`'e ihtiyaÃ§ duyduÄŸu aÃ§Ä±ktÄ±r. Kodu bu ÅŸekilde yazdÄ±lar. Ama projede yeni olan herkes iÃ§in bu tam bir gizemdir ve Ã¶ÄŸrenmeyi engeller.

Durum nasÄ±l dÃ¼zeltilir? Kolayca. **API'nin baÄŸÄ±mlÄ±lÄ±klarÄ± bildirmesine izin verin.**

```php
function testCreditCardCharge()
{
	$gateway = new PaymentGateway(/* ... */);
	$cc = new CreditCard('1234567890123456', 5, 2028);
	$cc->charge($gateway, 100);
}
```

Kod iÃ§indeki baÄŸlantÄ±larÄ±n nasÄ±l birdenbire aÃ§Ä±k hale geldiÄŸine dikkat edin. `charge()` metodunun `PaymentGateway`'e ihtiyaÃ§ duyduÄŸunu bildirmesiyle, kodun nasÄ±l baÄŸlantÄ±lÄ± olduÄŸunu kimseye sormanÄ±za gerek kalmaz. Bir Ã¶rnek oluÅŸturmanÄ±z gerektiÄŸini bilirsiniz ve bunu denediÄŸinizde, eriÅŸim parametrelerini saÄŸlamanÄ±z gerektiÄŸiyle karÅŸÄ±laÅŸÄ±rsÄ±nÄ±z. Onlar olmadan kod Ã§alÄ±ÅŸtÄ±rÄ±lamazdÄ± bile.

Ve en Ã¶nemlisi, ÅŸimdi Ã¶deme aÄŸ geÃ§idini mocklayabilirsiniz, bÃ¶ylece testin her Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nda size 100 dolar fatura edilmeyecek.

Global durum, nesnelerinizin API'lerinde bildirilmemiÅŸ ÅŸeylere gizlice eriÅŸebilmesine neden olur ve sonuÃ§ olarak API'lerinizi patolojik yalancÄ±lara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

Belki de daha Ã¶nce bu ÅŸekilde dÃ¼ÅŸÃ¼nmediniz, ancak ne zaman global durumu kullanÄ±rsanÄ±z, gizli kablosuz iletiÅŸim kanallarÄ± oluÅŸturursunuz. Uzaktan Ã¼rkÃ¼tÃ¼cÃ¼ eylem, geliÅŸtiricileri potansiyel etkileÅŸimleri anlamak iÃ§in kodun her satÄ±rÄ±nÄ± okumaya zorlar, geliÅŸtirici Ã¼retkenliÄŸini dÃ¼ÅŸÃ¼rÃ¼r ve yeni takÄ±m Ã¼yelerini ÅŸaÅŸÄ±rtÄ±r.
EÄŸer kodu oluÅŸturan sizseniz, gerÃ§ek baÄŸÄ±mlÄ±lÄ±klarÄ± bilirsiniz, ama sizden sonra gelen herkes Ã§aresizdir.

Global durumu kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ±n aktarÄ±lmasÄ±na Ã¶ncelik verin. Yani baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


Global Durumun KÄ±rÄ±lganlÄ±ÄŸÄ±
---------------------------

Global durumu ve singleton'larÄ± kullanan kodda, bu durumun ne zaman ve kim tarafÄ±ndan deÄŸiÅŸtirildiÄŸi asla emin deÄŸildir. Bu risk zaten baÅŸlatma sÄ±rasÄ±nda ortaya Ã§Ä±kar. AÅŸaÄŸÄ±daki kodun veritabanÄ± baÄŸlantÄ±sÄ± oluÅŸturmasÄ± ve Ã¶deme aÄŸ geÃ§idini baÅŸlatmasÄ± gerekiyor, ancak sÃ¼rekli istisna fÄ±rlatÄ±yor ve nedenini aramak son derece uzun sÃ¼rÃ¼yor:

```php
PaymentGateway::init();
DB::init('mysql:', 'user', 'password');
```

`PaymentGateway` nesnesinin kablosuz olarak diÄŸer nesnelere eriÅŸtiÄŸini ve bunlardan bazÄ±larÄ±nÄ±n veritabanÄ± baÄŸlantÄ±sÄ± gerektirdiÄŸini Ã¶ÄŸrenmek iÃ§in kodu ayrÄ±ntÄ±lÄ± olarak incelemeniz gerekir. Yani veritabanÄ±nÄ± `PaymentGateway`'den Ã¶nce baÅŸlatmak gereklidir. Ancak global durumun sis perdesi bunu sizden gizler. EÄŸer bireysel sÄ±nÄ±flarÄ±n API'leri aldatmasaydÄ± ve baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± bildirseydi ne kadar zaman kazanÄ±rdÄ±nÄ±z?

```php
$db = new DB('mysql:', 'user', 'password');
$gateway = new PaymentGateway($db, ...);
```

Benzer bir sorun, veritabanÄ± baÄŸlantÄ±sÄ±na global eriÅŸim kullanÄ±ldÄ±ÄŸÄ±nda da ortaya Ã§Ä±kar:

```php
use Illuminate\Support\Facades\DB;

class Article
{
	public function save(): void
	{
		DB::insert(/* ... */);
	}
}
```

`save()` metodu Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, veritabanÄ± baÄŸlantÄ±sÄ±nÄ±n zaten oluÅŸturulup oluÅŸturulmadÄ±ÄŸÄ± ve onun oluÅŸturulmasÄ±ndan kimin sorumlu olduÄŸu emin deÄŸildir. EÄŸer Ã¶rneÄŸin testler iÃ§in Ã§alÄ±ÅŸma zamanÄ±nda veritabanÄ± baÄŸlantÄ±sÄ±nÄ± deÄŸiÅŸtirmek istersek, muhtemelen `DB::reconnect(...)` veya `DB::reconnectForTest()` gibi baÅŸka metotlar oluÅŸturmamÄ±z gerekirdi.

Bir Ã¶rnek dÃ¼ÅŸÃ¼nelim:

```php
$article = new Article;
// ...
DB::reconnectForTest();
Foo::doSomething();
$article->save();
```

`$article->save()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda test veritabanÄ±nÄ±n gerÃ§ekten kullanÄ±ldÄ±ÄŸÄ±na nerede emin olabiliriz? Ya `Foo::doSomething()` metodu global veritabanÄ± baÄŸlantÄ±sÄ±nÄ± deÄŸiÅŸtirdiyse? Ã–ÄŸrenmek iÃ§in `Foo` sÄ±nÄ±fÄ±nÄ±n kaynak kodunu ve muhtemelen birÃ§ok baÅŸka sÄ±nÄ±fÄ±n da kodunu incelememiz gerekirdi. Ancak bu yaklaÅŸÄ±m yalnÄ±zca kÄ±sa vadeli bir cevap getirirdi, Ã§Ã¼nkÃ¼ durum gelecekte deÄŸiÅŸebilir.

Ya veritabanÄ± baÄŸlantÄ±sÄ±nÄ± `Article` sÄ±nÄ±fÄ±nÄ±n iÃ§indeki bir statik deÄŸiÅŸkene taÅŸÄ±rsak?

```php
class Article
{
	private static DB $db;

	public static function setDb(DB $db): void
	{
		self::$db = $db;
	}

	public function save(): void
	{
		self::$db->insert(/* ... */);
	}
}
```

Bu hiÃ§bir ÅŸeyi deÄŸiÅŸtirmedi. Sorun global durumdur ve hangi sÄ±nÄ±fta saklandÄ±ÄŸÄ± hiÃ§ fark etmez. Bu durumda, Ã¶nceki gibi, `$article->save()` metodunu Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±zda hangi veritabanÄ±na yazÄ±lacaÄŸÄ±na dair hiÃ§bir ipucumuz yok. UygulamanÄ±n diÄŸer ucundaki herhangi biri, `Article::setDb()` kullanarak veritabanÄ±nÄ± herhangi bir zamanda deÄŸiÅŸtirebilirdi. Elimizin altÄ±nda.

Global durum uygulamamÄ±zÄ± **son derece kÄ±rÄ±lgan** yapar.

Ancak bu sorunla baÅŸa Ã§Ä±kmanÄ±n basit bir yolu var. Sadece API'nin baÄŸÄ±mlÄ±lÄ±klarÄ± bildirmesine izin vermek yeterlidir, bu da doÄŸru iÅŸlevselliÄŸi saÄŸlar.

```php
class Article
{
	public function __construct(
		private DB $db,
	) {
	}

	public function save(): void
	{
		$this->db->insert(/* ... */);
	}
}

$article = new Article($db);
// ...
Foo::doSomething();
$article->save();
```

Bu yaklaÅŸÄ±m sayesinde, veritabanÄ± baÄŸlantÄ±sÄ±ndaki gizli ve beklenmedik deÄŸiÅŸiklikler hakkÄ±nda endiÅŸe ortadan kalkar. Åimdi makalenin nereye kaydedildiÄŸinden eminiz ve baÅŸka iliÅŸkisiz bir sÄ±nÄ±fÄ±n iÃ§indeki kod dÃ¼zenlemeleri artÄ±k durumu deÄŸiÅŸtiremez. Kod artÄ±k kÄ±rÄ±lgan deÄŸil, ama kararlÄ±.

Global durumu kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ±n aktarÄ±lmasÄ±na Ã¶ncelik verin. Yani baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


Singleton
---------

Singleton, bilinen Gang of Four yayÄ±nÄ±ndan "tanÄ±ma gÃ¶re":https://en.wikipedia.org/wiki/Singleton_pattern, sÄ±nÄ±fÄ± tek bir Ã¶rneÄŸe sÄ±nÄ±rlayan ve ona global eriÅŸim sunan bir tasarÄ±m desenidir. Bu desenin uygulanmasÄ± genellikle aÅŸaÄŸÄ±daki koda benzer:

```php
class Singleton
{
	private static self $instance;

	public static function getInstance(): self
	{
		self::$instance ??= new self;
		return self::$instance;
	}

	// ve sÄ±nÄ±fÄ±n verilen iÅŸlevlerini yerine getiren diÄŸer metotlar
}
```

Maalesef, singleton uygulamaya global durum getirir. Ve yukarÄ±da gÃ¶sterdiÄŸimiz gibi, global durum istenmez. Bu yÃ¼zden singleton bir anti-desen olarak kabul edilir.

Kodunuzda singleton'larÄ± kullanmayÄ±n ve onlarÄ± baÅŸka mekanizmalarla deÄŸiÅŸtirin. Singleton'lara gerÃ§ekten ihtiyacÄ±nÄ±z yok. Ancak tÃ¼m uygulama iÃ§in sÄ±nÄ±fÄ±n tek bir Ã¶rneÄŸinin varlÄ±ÄŸÄ±nÄ± garanti etmeniz gerekiyorsa, bunu [DI konteynerine |container] bÄ±rakÄ±n.
BÃ¶ylece bir uygulama singleton'u, yani bir servis oluÅŸturun. Bu sayede sÄ±nÄ±f kendi benzersizliÄŸini saÄŸlamaya (yani `getInstance()` metodu ve statik deÄŸiÅŸkene sahip olmayacak) odaklanmayÄ± bÄ±rakÄ±r ve yalnÄ±zca kendi iÅŸlevlerini yerine getirir. BÃ¶ylece Tek Sorumluluk Ä°lkesi'ni ihlal etmeyi bÄ±rakÄ±r.


Global Durum ve Testler
-----------------------

Test yazarken, her testin izole bir birim olduÄŸunu ve ona hiÃ§bir dÄ±ÅŸ durumun girmediÄŸini varsayarÄ±z. Ve hiÃ§bir durum testlerden Ã§Ä±kmaz. Test tamamlandÄ±ktan sonra, testle ilgili tÃ¼m durumun Ã§Ã¶p toplayÄ±cÄ± (garbage collector) tarafÄ±ndan otomatik olarak kaldÄ±rÄ±lmasÄ± gerekir. Bu sayede testler izole edilmiÅŸtir. Bu yÃ¼zden testleri istenilen sÄ±rada Ã§alÄ±ÅŸtÄ±rabiliriz.

Ancak global durumlar/singleton'lar mevcutsa, tÃ¼m bu hoÅŸ varsayÄ±mlar parÃ§alanÄ±r. Durum teste girebilir ve ondan Ã§Ä±kabilir. Birdenbire testlerin sÄ±rasÄ± Ã¶nemli olabilir.

Singleton'larÄ± test edebilmek iÃ§in bile, geliÅŸtiriciler genellikle Ã¶zelliklerini gevÅŸetmek zorunda kalÄ±r, belki de Ã¶rneÄŸi baÅŸkasÄ±yla deÄŸiÅŸtirmeye izin vererek. BÃ¶yle Ã§Ã¶zÃ¼mler en iyi durumda bir hack'tir ve bakÄ±mÄ± zor, anlaÅŸÄ±lÄ±r olmayan kod oluÅŸturur. Herhangi bir global durumu etkileyen her test veya `tearDown()` metodu, bu deÄŸiÅŸiklikleri geri almalÄ±dÄ±r.

Global durum, birim testi sÄ±rasÄ±nda en bÃ¼yÃ¼k baÅŸ aÄŸrÄ±sÄ±dÄ±r!

Durum nasÄ±l dÃ¼zeltilir? Kolayca. Singleton'larÄ± kullanan kod yazmayÄ±n, baÄŸÄ±mlÄ±lÄ±klarÄ±n aktarÄ±lmasÄ±na Ã¶ncelik verin. Yani baÄŸÄ±mlÄ±lÄ±k enjeksiyonu.


Global Sabitler
---------------

Global durum yalnÄ±zca singleton'larÄ±n ve statik deÄŸiÅŸkenlerin kullanÄ±mÄ±yla sÄ±nÄ±rlÄ± deÄŸildir, aynÄ± zamanda global sabitlerle de ilgili olabilir.

DeÄŸeri bize yeni (`M_PI`) veya faydalÄ± (`PREG_BACKTRACK_LIMIT_ERROR`) bir bilgi getirmeyen sabitler kesinlikle sorunsuzdur.
Aksine, bilgiyi kodun iÃ§ine *kablosuz olarak* aktarmanÄ±n bir yolu olarak hizmet eden sabitler, gizli bir baÄŸÄ±mlÄ±lÄ±ktan baÅŸka bir ÅŸey deÄŸildir. AÅŸaÄŸÄ±daki Ã¶rnekteki `LOG_FILE` gibi.
`FILE_APPEND` sabitinin kullanÄ±mÄ± tamamen doÄŸrudur.

```php
const LOG_FILE = '...';

class Foo
{
	public function doSomething()
	{
		// ...
		file_put_contents(LOG_FILE, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Bu durumda, API'nin bir parÃ§asÄ± olmasÄ± iÃ§in sÄ±nÄ±fÄ±n kurucusunda bir parametre bildirmeliyiz `Foo`:

```php
class Foo
{
	public function __construct(
		private string $logFile,
	) {
	}

	public function doSomething()
	{
		// ...
		file_put_contents($this->logFile, $message . "\n", FILE_APPEND);
		// ...
	}
}
```

Åimdi kayÄ±t tutma iÃ§in dosya yolu bilgisini aktarabilir ve ihtiyaca gÃ¶re kolayca deÄŸiÅŸtirebiliriz, bu da kodun test edilmesini ve bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r.


Global Fonksiyonlar ve Statik Metotlar
--------------------------------------

Statik metotlarÄ±n ve global fonksiyonlarÄ±n kullanÄ±mÄ±nÄ±n kendisinin sorunlu olmadÄ±ÄŸÄ±nÄ± vurgulamak istiyoruz. `DB::insert()` ve benzeri metotlarÄ±n kullanÄ±mÄ±nÄ±n uygunsuzluÄŸunun ne iÃ§erdiÄŸini aÃ§Ä±kladÄ±k, ancak her zaman sadece bir statik deÄŸiÅŸkende saklanan global durum meselesiydi. `DB::insert()` metodu, iÃ§inde veritabanÄ± baÄŸlantÄ±sÄ± saklandÄ±ÄŸÄ± iÃ§in statik deÄŸiÅŸkenin varlÄ±ÄŸÄ±nÄ± gerektirir. Bu deÄŸiÅŸken olmadan metodu uygulamak imkansÄ±z olurdu.

`DateTime::createFromFormat()`, `Closure::fromCallable`, `strlen()` ve birÃ§ok diÄŸer gibi deterministik statik metotlarÄ±n ve fonksiyonlarÄ±n kullanÄ±mÄ±, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile tamamen uyumludur. Bu fonksiyonlar her zaman aynÄ± giriÅŸ parametrelerinden aynÄ± sonuÃ§larÄ± dÃ¶ndÃ¼rÃ¼rler ve bu yÃ¼zden Ã¶ngÃ¶rÃ¼lebilirler. HiÃ§bir global durum kullanmazlar.

Ancak PHP'de deterministik olmayan fonksiyonlar da vardÄ±r. Bunlara Ã¶rneÄŸin `htmlspecialchars()` fonksiyonu dahildir. ÃœÃ§Ã¼ncÃ¼ parametresi `$encoding`, eÄŸer belirtilmemiÅŸse, varsayÄ±lan deÄŸer olarak `ini_get('default_charset')` yapÄ±landÄ±rma seÃ§eneÄŸinin deÄŸerine sahiptir. Bu yÃ¼zden bu parametreyi her zaman belirtmek ve bÃ¶ylece fonksiyonun olasÄ± Ã¶ngÃ¶rÃ¼lemez davranÄ±ÅŸÄ±nÄ± Ã¶nlemek tavsiye edilir. Nette bunu tutarlÄ± bir ÅŸekilde yapar.

`strtolower()`, `strtoupper()` ve benzeri bazÄ± fonksiyonlar, yakÄ±n geÃ§miÅŸte deterministik olmayan ÅŸekilde davrandÄ±lar ve `setlocale()` ayarÄ±na baÄŸÄ±mlÄ±ydÄ±lar. Bu, en sÄ±k TÃ¼rkÃ§e dili ile Ã§alÄ±ÅŸÄ±rken birÃ§ok komplikasyona neden oldu.
Ã‡Ã¼nkÃ¼ o, noktalÄ± ve noktasÄ±z kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k `I` harfini ayÄ±rt eder. Yani `strtolower('I')` `Ä±` karakterini ve `strtoupper('i')` `Ä°` karakterini dÃ¶ndÃ¼rÃ¼yordu, bu da uygulamalarÄ±n bir dizi gizemli hataya neden olmaya baÅŸlamasÄ±na yol aÃ§tÄ±.
Ancak bu sorun PHP sÃ¼rÃ¼m 8.2'de kaldÄ±rÄ±ldÄ± ve fonksiyonlar artÄ±k yerel ayara baÄŸÄ±mlÄ± deÄŸil.

Bu, global durumun tÃ¼m dÃ¼nyada binlerce geliÅŸtiriciyi nasÄ±l rahatsÄ±z ettiÄŸinin gÃ¼zel bir Ã¶rneÄŸidir. Ã‡Ã¶zÃ¼m, onu baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile deÄŸiÅŸtirmekti.


Global Durum Ne Zaman KullanÄ±labilir?
-------------------------------------

Global durumu kullanmanÄ±n mÃ¼mkÃ¼n olduÄŸu belirli Ã¶zel durumlar vardÄ±r. Ã–rneÄŸin kod hata ayÄ±klarken, bir deÄŸiÅŸkenin deÄŸerini yazdÄ±rmanÄ±z veya programÄ±n belirli bir kÄ±smÄ±nÄ±n sÃ¼resini Ã¶lÃ§meniz gerektiÄŸinde. Bu gibi durumlarda, daha sonra koddan kaldÄ±rÄ±lacak geÃ§ici eylemlerle ilgili olanlarda, global olarak eriÅŸilebilir bir dumper veya kronometre kullanmak meÅŸru olarak mÃ¼mkÃ¼ndÃ¼r. Bu araÃ§lar Ã§Ã¼nkÃ¼ kod tasarÄ±mÄ±nÄ±n bir parÃ§asÄ± deÄŸildir.

BaÅŸka bir Ã¶rnek, dahili olarak derlenmiÅŸ dÃ¼zenli ifadeleri bellekteki statik Ã¶nbelleÄŸe saklayan `preg_*` dÃ¼zenli ifadelerle Ã§alÄ±ÅŸmak iÃ§in fonksiyonlardÄ±r. Yani aynÄ± dÃ¼zenli ifadeyi kodun farklÄ± yerlerinde birden Ã§ok kez Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zda, yalnÄ±zca bir kez derlenir. Ã–nbellek performanstan tasarruf saÄŸlar ve aynÄ± zamanda kullanÄ±cÄ± iÃ§in tamamen gÃ¶rÃ¼nmezdir, bu yÃ¼zden bÃ¶yle bir kullanÄ±m meÅŸru kabul edilebilir.


Ã–zet
----

Neden mantÄ±klÄ± olduÄŸunu ele aldÄ±k:

1) Koddan tÃ¼m statik deÄŸiÅŸkenleri kaldÄ±rmak
2) BaÄŸÄ±mlÄ±lÄ±klarÄ± bildirmek
3) Ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonu kullanmak

Kod tasarÄ±mÄ±nÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼nÃ¼zde, her `static $foo`'nun bir sorun teÅŸkil ettiÄŸini dÃ¼ÅŸÃ¼nÃ¼n. Kodunuzun DI'ye saygÄ± duyan bir ortam olmasÄ± iÃ§in, global durumu tamamen ortadan kaldÄ±rmak ve onu baÄŸÄ±mlÄ±lÄ±k enjeksiyonu kullanarak deÄŸiÅŸtirmek gereklidir.

Bu sÃ¼reÃ§ sÄ±rasÄ±nda, birden fazla sorumluluÄŸu olduÄŸu iÃ§in sÄ±nÄ±fÄ± bÃ¶lmek gerektiÄŸini keÅŸfedebilirsiniz. Bundan korkmayÄ±n; Tek Sorumluluk Ä°lkesi'ni hedefleyin.

*MiÅ¡ko Hevery'ye teÅŸekkÃ¼r etmek isterim, [Flaw: Brittle Global State & Singletons |https://web.archive.org/web/20230321084133/http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/] gibi makaleleri bu bÃ¶lÃ¼mÃ¼n temelini oluÅŸturur.*
