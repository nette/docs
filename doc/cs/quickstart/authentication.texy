Autentifikace
**************

Nette poskytuje způsob jak naprogramovat autentifikaci na našich stránkách, ale do ničeho nás nenutí. Implementace je pouze na nás. Nette obsahuje rozhraní `Nette\Security\IAuthenticator`, které vyžaduje pouze jednu metodu `authenticate`, která ověřuje uživatele jakkoliv budeme chtít.

Existuje mnoho možností, jak může být uživatel ověřen. Nejčastější způsob ověření je pomocí hesla (uživatel poskytne své jméno, nebo email a heslo), ale jsou zde i jiné způsoby. Možná znáte tlačítka typu "Přihlásit pomocí Facebooku", nebo přihlášení pomocí Google/Twitter/GitHub na některých stránkách. S Nette můžeme mít jakoukoliv přihlašovací metodu, nebo je klidně můžeme kombinovat. Je to jen na nás.

Obyčejně bychom si nejspíš napsali vlastní authenticator, ale pro tento jednoduchý malý blog použijeme `SimpleAuthenticator`, který je v Nette předpřipraven. Poskytuje přihlášení na základě hesla a uživatelského jména, které je uloženo v konfiguračním souboru. Přidáme tedy *security* sekci do souboru `config.neon` (a nezapomeneme změnit heslo):


/--neon
	security:
		users:
			admin: secret  # user 'admin', password 'secret'
\--


Nette automaticky vytvoří službu s názvem `authenticator` v DI kontejneru.

.[caution]
V Sandboxu již existuje složitější authenticator. Aby se "nehádal" s tím, který jsem právě vytvořili, je třeba smazat v `config.neon` řádek `- App\Model\UserManager` v sekci *services*.

.[note]
Více si můžete přečíst o [Dependency Injection zde |/dependency-injection] a o [konfiguraci zde |/configuring]


Přihlašovací formulář
===

Nyní máme autentifikaci připravenu a musíme připravit uživatelské rozhraní pro přihlášení. Vytvořme tedy nový presenter s názvem *SignPresenter*, který:

- zobrazí přihlašovací formulář (s přihlašovacím jménem a heslem)
- po odeslání formuláře ověří uživatele
- poskytne možnost odhlášení

To je ale náhodička, v Sandboxu již jeden takový presenter je připraven! Můžeme ho jednoduše použít. Pojďme si tedy projít, co obsahuje a jak funguje.

Začneme s přihlašovacím formulářem. Již víme jak formuláře v presenterech fungují. Otevřeme si tedy presenter `SignPresenter` a najdeme metodu `createComponentSignInForm`. Měl by vypadat nějak takto:

/--php
	protected function createComponentSignInForm()
	{
		$form = new Nette\Application\UI\Form;
		$form->addText('username', 'Uživatelské jméno:')
			->setRequired('Prosím vyplňte své uživatelské jméno.');

		$form->addPassword('password', 'Heslo:')
			->setRequired('Prosím vyplňte své heslo.');

		$form->addCheckbox('remember', 'Zůstat přihlášen');

		$form->addSubmit('send', 'Přihlásit');

		$form->onSuccess[] = array($this, 'signInFormSucceeded');
		return $form;
	}
\--

Je zde input pro uživatelské jméno a heslo. Můžeme smazat `remember` checkbox, pokud se nám nehodí.


View
---

Formulář se vykresluje v šabloně `app/presenters/templates/Sign/in.latte`:

/--html
{block content}
<h1 n:block=title>Přihlášení</h1>

{control signInForm}
\--


Přihlašovací callback
----

Jde zde také callback připravený pro přihlášení uživatele, který je volán hned po úspěšném odeslání formuláře. Současný callback prodlužuje platnost přihlášení, po kterou zůstane uživatel přihlášen. Nyní to však není potřeba, takže to můžeme smazat.

Callback pouze převezme uživatelské jméno a heslo, které uživatel vyplnil dříve a předá to authenticatoru. Po přihlášení dojde k přesměrování na úvodní stránku.

Je zde ještě jedna věc - je zde část kódu obalená do `try catch`. Metoda [User::login() | api:Nette\Security\User::login()] vyhodí výjimku, pokud uživatelské jméno a heslo nesouhlasí s údaji v konfiguračním souboru. Jak již víme, toto může vyústit v červenou chybovou stránku, nebo v produkčním módu ve zprávu informující o server erroru. To však nechceme. Proto tuto výjimku zachytíme a předáme hezkou, uživatelsky přívětivou chybovou zprávu do formuláře.

Jakmile dojde k chybě ve formuláři, stránka s formulářem se překreslí a nad formulářem se zobrazí hezká zpráva informující uživatele, že vyplnil špatné přihlašovací jméno nebo heslo.

/--php
	public function signInFormSucceeded($form)
	{
		$values = $form->values;

		try {
			$this->getUser()->login($values->username, $values->password);
			$this->redirect('Homepage:');

		} catch (Nette\Security\AuthenticationException $e) {
			$form->addError('Nesprávné přihlašovací jméno nebo heslo.');
		}
	}
\--


Formulář pro nové příspěvky
===

Prvně zabezpečíme formulář pro přidávání nových příspěvků. Ten je definován v presenteru `PostPresenter` a renderován v šabloně `app/presenters/templates/Post/create.latte`. Naším prvním cílem je znemožnit přístup na stránku uživatelům, kteří nejsou přihlášeni.


Šablony presenterů
---

Vytvoříme action metodu `actionCreate`, která přesměruje nepřihlášené uživatele na formulář s přihlášením.

/--php
	public function actionCreate()
	{
		if (!$this->getUser()->isLoggedIn()) {
			$this->redirect('Sign:in');
		}
	}
\--

Stejným způsobem zabezpečíme i editovací stránku, takže jednoduše přidáme tyto tři řádky také sem:

/--php
	public function actionEdit($postId)
	{
		if (!$this->getUser()->isLoggedIn()) {
			$this->redirect('Sign:in');
		}
\--


Skrytí odkazů
----

Neautorizovaný uživatel nemůže vidět stránku *create* ani *edit*, ale stále na ně může vidět odkazy. Ty bychom měli také schovat. Jeden takový odkaz je v šabloně `app/presenters/templates/Homepage/default.latte` a měl by být vidět pouze přihlášeným uživatelům.

Můžeme jej schovat využitím *n:makra* jménem `n:if`. Pokud je tato podmínka `false`, celý tag `<a>` včetně obsahu zůstane skrytý.

/--html
<a n:href="Post:create" n:if="$user->loggedIn">Vytvořit příspěvek</a>
\--

což je zkratka následujícího zápisu (neplést s `tag-if`)

/--html
{if $user->loggedIn}<a n:href="Post:create">Editovat příspěvek</a>{/if}
\--

Stejným způsobem skryjeme také odkaz v šabloně `app/presenters/templates/Post/show.latte`.


Callbacky formulářů
---

Poslední a **nejdůležitější věc** je **zabezpečit callbacky formulářů**. Protože jsou komponenty znovupoužitelné, mohou být vykresleny v mnoha pohledech. A protože mohou být vykresleny v jakémkoliv pohledu svého presenteru, mohou být také odeslány z kterékoliv akce a to i z těch, které ani nejsou definovány. To znamená, že i když pohled `create` není vykreslen, úpravou URL adresy může útočník formulář tak jako tak odeslat (a přidat/editovat příspěvek).

Tomu můžeme zabránit přidáním jednoduchého *if*, který přidáme na začátek metody `postFormSucceeded`:

/--php
	public function postFormSucceeded($form)
	{
		if (!$this->getUser()->isLoggedIn()) {
			$this->error('Pro vytvoření, nebo editování příspěvku se musíte přihlásit.');
		}
\--

Je to velmi jednoduché, ale nesmíme na to **nikdy zapomenout**, protože je opravdu kritické zabezpečení aplikace.


Odkaz na přihlášení
====

Jak se vlastně dostaneme na přihlašovací stránku? Není zde žádný odkaz, který by na ni vedl. Tak si ho tedy přidáme do šablony `app/presenters/templates/@layout.latte`. Pokuste se najít vhodné místo, může to být téměř kdekoliv.

/--html
<ul class="navig">
	<li><a n:href="Homepage:">Články</a></li>
	{if $user->loggedIn}
		<li><a n:href="Sign:out">Odhlásit</a></li>
	{else}
		<li><a n:href="Sign:in">Přihlásit</a></li>
	{/if}
</ul>
\--

Pokud není uživatel přihlášen, zobrazí se odkaz "Přihlásit". V opačném případě se zobrazí odkaz "Odhlásit". Tato akce je také připravena ve výchozím Sandboxu, takže ji můžeme jednoduše použít.

Jelikož uživatele po odhlášení okamžitě přesměrujeme, není potřeba žádná šablona. Odhlášení vypadá takto:

/--php
	public function actionOut()
	{
		$this->getUser()->logout();
		$this->flashMessage('Odhlášení bylo úspěšné.');
		$this->redirect('Homepage:');
	}
\--

Pouze se zavolá metoda `logout()` a následně se zobrazí hezká zpráva potvrzující úspěšné odhlášení.


Shrnutí
=======

Nyní máme odkaz odkazující na nový presenter, který požaduje od uživatelů přihlašovací údaje a umožňuje jim přihlásit se. K ověření uživatele jsme použili *SimpleAuthenticator* a přihlašovací údaje máme v konfiguračním souboru. Jelikož se jedná o velmi jednoduchou aplikaci, nepotřebujeme více účtů. Také jsme zabezpečili všechny akce a formuláře, takže přidávat a editovat příspěvky mohou pouze přihlášení uživatelé.

{{care: Filip Procházka|2117}}
{{care: Honza Doleček|3537}}
