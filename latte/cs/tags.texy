Latte tagy (makra)
******************

.[perex]
Přehled a popis všech tagů (neboli značek či maker) šablonovacího systému Latte, které jsou vám standardně k dispozici.

.[table-latte-summary language-latte]
|## Výpis proměnných a výrazů
| `{$variable}`                  | [vypíše escapovanou proměnnou |#vypsani-promenne]
| `{$variable\|noescape}`        | [vypíše proměnnou bez escapování |#vypsani-promenne]
| `{expression}`                 | [vypíše escapovaný výraz |#vypsani-promenne]
| `{=expression}`                | [vypíše escapovaný výraz |#vypsani-promenne]

.[table-latte-summary language-latte]
|## Podmínky
| `{if $cond} … {elseif $cond} …`<wbr> `{else} … {/if}`         | [podmínka if |#podminky]
| `{$cond ? $value1 : $value2}`                          | [ternární operátor |#podminky]
| `{$cond ? $value}`                                     | [zkrácený "ternární" operátor |#podminky]
| `{$a ?: $default}`                                     | vypíše `$a`, pokud je prázdné tak `$default`
| `{ifset $var} … {elseifset $var} …`<wbr> `{/ifset}`           | [podmínka if (isset()) |#podminky]
| `{ifchanged [$vars]} … {/ifchanged}`                          | [test zda se změnila proměnná |#podminky]
| `{switch $var} … {case value} …`<wbr> `{default} … {/switch}` | [volba podle hodnoty |#podminky]
| `{$obj?->prop}` `{$arr?['item']}`                             | různé formy [volitelného řetězení |#volitelné řetězení]

.[table-latte-summary language-latte]
|## Cykly
| `{foreach $arr as $item} … {/foreach}` | [cyklus foreach |#cykly]
| `{for expr; expr; expr} … {/for}`      | [cyklus for |#cykly]
| `{while expr} … {/while}`              | [cyklus while |#cykly]
| `{continueIf $cond}`                   | [podmíněný skok na další iteraci |#cykly]
| `{skipIf $cond}`                       | [podmíněný skok na další iteraci |#cykly]
| `{breakIf $cond}`                      | [podmíněné ukončení cyklu |#cykly]
| `{first [$mod]} … {/first}`            | [vypsat při prvním průchodu |#cykly]
| `{last [$mod]} … {/last}`              | [vypsat při posledním průchodu |#cykly]
| `{sep} … {/sep}`                       | [separátor |#cykly]

.[table-latte-summary language-latte]
|## Proměnné
| `{var $foo = value}`           | [vytvoří proměnnou |#deklarace-promennych]
| `{default $foo = value}`       | [vytvoří proměnnou, pokud neexistuje |#deklarace-promennych]
| `{capture $var} … {/capture}`  | [zachytí blok do proměnné |#zachytavani-do-promenne]

.[table-latte-summary language-latte]
|## Bloky, layouty, dědičnost šablon
| `{block block}`                | [definuje a hned vykreslí blok |#bloky]
| `{define block}`               | [definuje blok pro pozdější použití |#bloky]
| `{include block}`              | [vloží blok |#vkladani-bloku]
| `{include block from 'file.latte'}` | [vloží blok ze souboru |#vkladani-bloku]
| `{include 'file.latte'}`       | [načte šablonu z dalšího souboru |#vlozeni-souboru]
| `{import 'file.latte'}`        | načte bloky z externí šablony
| `{layout 'file.latte'}`        | [určuje soubor s layoutem |#rozsirovani-a-dedicnost]
| `{extends 'file.latte'}`       | [alias pro `{layout}` |#rozsirovani-a-dedicnost]
| `{embed 'file.latte'}`         | [načte šablonu a umožní přepsat bloky |#embed]
| `{ifset block} … {/ifset}`     | [podmínka, zda existuje blok |#bloky]

.[table-latte-summary language-latte]
|## Výjimky
| `{try} … {else} … {/try}`      | [zachycení výjimek |#exceptions]
| `{rollback}`                   | [zahození bloku try |#exceptions]

.[table-latte-summary language-latte]
|## Typy
| `{varType type $var}`          | [deklaruje typ proměnné |#Typy]
| `{varPrint [all]}`             | [navrhne typy proměnných |#Typy]
| `{templateType ClassName}`     | [deklaruje typy proměnných podle třídy |#Typy]
| `{templatePrint}`              | [navrhne třídu s typy proměnných |#Typy]

.[table-latte-summary language-latte]
|## Ostatní
| `{sandbox 'file.latte'}`       | [načte šablonu v sandbox režimu |#vlozeni-souboru]
| `{do expression}`              | [vyhodnotí výraz, ale nevypíše |#vyhodnoceni-kodu]
| `{* text komentáře *}`         | komentář, bude odstraněn
| `{l}` nebo `{r}`               | vypíše znak { nebo }
| `{syntax mode}`                | [změna syntaxe za běhu |#zmena-syntaxe]
| `{spaceless} … {/spaceless}`   | odstraní nadbytečné mezery, podobně jako filtr [strip |filters#strip]
| `{contentType $type}`          | [přepne escapování a pošle HTTP hlavičku |#hlavicka-contenttype]
| `{debugbreak $cond}`           | [umístí do kódu breakpoint |#break-point-debugbreak]

.[table-latte-summary language-latte]
|## Pomocníci HTML kodéra
| `n:class`                      |  [chytrý zápis HTML atributu class |#n:class]
| `n:attr`                       |  [chytrý zápis jakéhokoliv HTML atributu |#n:attr]
| `n:ifcontent`                  |  [Vynechá prázdný HTML tag |#n:ifcontent]
| `n:tag-if`                     |  Vynechá HTML tag, pokud je podmínka false

.[table-latte-summary language-latte]
|## Operátory
| `(expand)`                     | [rozbalení polí |#(expand)]


.[table-latte-summary language-latte]
|## Dostupné pouze v Nette Frameworku
| Odkazy ||
|---------------------------
| `n:href`                           | [odkaz používaný v HTML elementech `<a>` |doc:creating-links#V šabloně presenteru]
| `{link Presenter:action}`          | [vygeneruje odkaz |doc:creating-links#V šabloně presenteru]
| `{plink Presenter:action}`         | [vygeneruje odkaz na presenter |doc:creating-links#V šabloně presenteru]
|---------------------------
| Ovládací prvky a formuláře ||
|---------------------------
| `{control loginForm}`          | [vykreslí komponentu |#vykreslovani-komponent]
| `{form formName} … {/form}`    | [vykreslí značky formuláře |#formulare]
| `{label fieldName} … {/label}` | [vykreslí popisku formulářového prvku |#formulare]
| `{input fieldName}`            | [vykreslí formulářový prvek |#formulare]
| `{inputError fieldName}`       | [vypíše chybovou hlášku formulářového prvku |#formulare]
| `n:name`                       | [oživí formulářový prvek |#formulare]
| `{formPrint}`                  | [navrhne Latte kód pro formulář |#formulare]
| `{formContext formName} … {/formContext}` | [částečné kreslení formuláře |#formulare]
|---------------------------
| AJAX ||
|---------------------------
| `{snippet name} … {/snippet}`  | [výstřižek, který lze odeslat AJAXem |doc:ajax#tag-snippet]
| `{snippetArea name}`           | obálka pro výstřižky
|---------------------------
| Překlady ||
|---------------------------
| `{_}Text{/_}`                  | [přeloží text |#preklady]
| `{_expression}`                | [přeloží výraz a vypíše s escapováním |#preklady]
|---------------------------
| Ostatní ||
|---------------------------
| `{dump $variable}`             | [dumpuje proměnné do Tracy Bar |#dumpovani-promennych]
| `{cache $key} … {/cache}`      | [cachuje část šablony |doc:caching#cachovani-v-sablonach]


Vypsání proměnné nebo výrazu `{expression}` .{toc: Vypsání proměnné}
--------------------------------------------------------------------

**S escapováním:** (eliminuje riziko [Cross Site Scripting |doc:vulnerability-protection#cross-site-scripting-xss]):

```html
Jméno: {$name} {$surname}<br>
Věk: {date('Y') - $birth}<br>
```

**Bez escapování** uvedením modifikátoru `|noescape` (dříve se používal vykřičník):

```html
<div class="article">
	{$content|noescape}
	{nl2br($notes)|noescape}
</div>
```

Alternativně lze použit zápis s rovnítkem `{=expression}`. Ten se hodí v případech, kdy nemusí být zřejmé, že výraz je skutečně výrazem a nikoliv tag nebo JSON:

```html
Verze: {=PHP_VERSION}
Název: {="string"}
```

Díky technologií [Kontextově sensitivního escapování |safety-first#Kontextově sensitivní escapování] je mimo jiné možné nativně používat PHP proměnné uvnitř JavaScriptu:

```html
<script>
var pole = {$arr};
var name = {$name}; // pozor, zapisuje se bez uvozovek!
</script>
```


Podmínky `{if $cond} … {/if}`, `{$cond ? … : …}` .{toc: Podmínky}
-----------------------------------------------------------------

Podmínky se chovají stejně, jako jejich protějšky v PHP:

```html
{if $stock}
	Skladem
{elseif $onWay}
	Na cestě
{else}
	Není dostupné
{/if}
```

Lze použít i značku `{ifset}`, která kontroluje existenci proměnné a odpovídá zápisu `if (isset($var))`. Značku `{ifset}` lze také použít pro ověření existence [bloků |#bloky].


Výraz v podmínce `{if}` lze uvést také v ukončovací značce, což se hodí v situacích, kdy při otevírání podmínky ještě jeho výsledek neznáme:

```html
{if}
	<h1>Výpis řádků z databáze</h1>

	{foreach $database->table as $row} ... {/foreach}
{/if $row}
```

Blok `{if}` s podmínkou v ukončovací značce nepodporuje `{elseif}`, `{else}` použít lze.

```html
dostupnost: {$stock ? 'Skladem' : 'Není dostupné'}

zkráceně: {$stock ? 'Skladem'}
```

.{data-version:2.9}
`{ifchanged}` zkontroluje, zda se hodnota změnila od poslední iterace ve smyčce (for, foreach, while).

Pokud je dána jedna nebo více proměnných, zkontrolujte, zda se jakákoliv z nich změnila. Například následující příklad vypíše nadpis s prvním písmenem pokaždé, když se změní při výpisu jmen:

```html
{foreach ($names|sort) as $name}
    {ifchanged $name[0]} <h2>{$name[0]}</h2> {/ifchanged}

	<p>{$name}</p>
{/foreach}
```

Pokud není zadán žádný argument, kontroluje svůj vlastní vykreslený obsah oproti jeho předchozímu stavu a zobrazí jej, pouze pokud se změnil. V předchozím příkladu tedy můžeme argument vynechat. A můžeme také použít `n:atribut`:

```html
{foreach ($names|sort) as $name}
    <h2 n:ifchanged>{$name[0]}</h2>

	<p>{$name}</p>
{/foreach}
```

Značka `{ifchanged}` může mít také volitelnou klauzuli `{else}`, která se zobrazí, pokud se hodnota nezmění.


Opakující se výraz podmínky lze někdy zkrátit značkami `{switch}` a `{case}`. Latte **používá striktní porovnání** a nepotřebuje `break`. Je to tedy přesný ekvivalent pro strukturu `match` v PHP 8.
```html
{switch $transport}
	{case train}
		Vlakem
	{case plane}
		Letecky
	{default}
		Jinak
{/switch}
```

.{data-version:2.9}
Klauzule `{case}` může obsahovat více hodnot:

```html
{switch $status}
{case $status::NEW}<b>nová položka</b>
{case $status::SOLD, $status::UNKNOWN}<i>není dostupná</i>
{/switch}
```


.{data-version:2.6}
Volitelné řetězení (Nullsafe operators)
---------------------------------------

Volitelné řetězení umožňuje psát kód, kde Latte okamžitě zastaví vyhodnocování výrazů, pokud narazí na null. A to díky novému operátoru `?->` umožňujícímu volitelný přístup k proměnným nebo prvkům pole. Stejnou věc přináší PHP 8, nicméně v Latte ho můžete používat i v PHP 7.

Když píšeme kód jako:

```html
{$order?->id}
```

říkáme tím, že když `$order` není null, bude vypsán `$order->id`, ale když je `$order` null, zastaví se vyhodnocování a prostě se vrátí null.

Uvidíte, že pomocí `?->` nahradíte spoustu kódu, který by jinak opakovaně kontroloval null:

/--comment
Zatím nejde
{$order?->product?[2]->name}
// means ($order !== null) && ($order->product !== null) ? $order->product[2]->name : null
\--

```html
{$user?->address?->street}
// znamená cca ($user !== null) && ($user->address !== null) ? $user->address->street : null

{$items[2]?->count}
// zamená cca ($items[2] !== null) ? $items[2]->count : null

{$user->getIdentity()?->name}
// zamená cca $user->getIdentity() !== null ? $user->getIdentity()->name : null
```

Význam je "cca", protože ve skutečnosti se výraz vyhodnocuje důmyslněji a žádný krok se neopakuje. Například `$user->getIdentity()` se zavolá jen jednou, tedy nemůže nastat problém způsobený tím, že by v podmínce vrátilo objekt a následně pak null.

Výrazy s volitelným řetězením lze používat kdekoliv, například v podmínkách:

```html
{if $blogPost?->count('*')}
	// znamená if (isset($blogPost) && $blogPost->count('*'))
	...
{/if}
```


.{data-version:2.9}
Undefined safe operator
-----------------------

Undefined safe operator `??->` je obdoba nullsafe operatoru `?->`, avšak nevyvolá chybu, pokud proměnná, property nebo index v poli vůbec neexistuje.

```html
{$order??->id}
```

říkáme tím, že když existuje `$order` a není null, bude vypsán `$order->id`, ale když je `$order` null nebo neexistuje, zastaví se vyhodnocování a prostě se vrátí null.

```html
{$user??->address??->street}
// znamená cca isset($user) && isset($user->address) ? $user->address->street : null
```


Cykly `{foreach}`, `{for}`, `{while}`  .{toc: Cykly}
----------------------------------------------------

Cykly `foreach`, `for` a `while` se chovají stejně, jako jejich protějšky v PHP.

```html
{foreach $result as $row}
	<span>{$row->title}</span>
{/foreach}
```

```html
{while $row = $result->fetch()}
	<span>{$row->title}</span>
{/while}
```

```html
{for $i = 0; $i < 10; $i++}
	<span>Položka {$i}</span>
{/for}
```

 .{data-version:2.9}
Cyklus `foreach` může mít volitelnou klauzuli `{else}`, jejíž text se zobrazí, pokud je dané pole prázdné:

```html
<ul>
    {foreach $people as $person}
        <li>{$person->name}</li>
    {else}
        <li><em>Litujeme, v tomto seznamu nejsou žádní uživatelé</em></li>
    {/foreach}
</ul>
```

Uvnitř cyklu `foreach` je inicializovaná proměnná `$iterator`, díky které můžeme zjišťovat užitečné informace o probíhajícím cyklu. [Její API |api:Latte\Runtime\CachingIterator] disponuje čítačem průchodů a metodami zjišťujícími, zda je aktuální průchod sudý, lichý, první nebo poslední:

- `isFirst()` - prochází se cyklem poprvé?
- `isLast()` - jde o poslední průchod?
- `getCounter()` - čítač průchodů cyklem počítaný od jedničky
- `getCounter0()` - čítač průchodů cyklem počítaný od nuly .{data-version:2.9}
- `isOdd()` - jde o lichý průchod?
- `isEven()` - jde o sudý průchod?
- `getParent()` - iterátor obklopující aktuální .{data-version:2.9}

Objekt `$iterator` má [vlastnosti traity Nette\SmartObject |doc:smartobject#properties-gettery-a-settery], proto lze místo `$iterator->isFirst()` psát `$iterator->first` a podobně. Příklad:

```html
{foreach $rows as $row}
	{if $iterator->first}<table>{/if}

	<tr id="row-{$iterator->counter}">
		<td>{$row->name}</td>
		<td>{$row->email}</td>
	</tr>

	{if $iterator->last}</table>{/if}
{/foreach}
```

Konstrukci `{if $iterator->first}<table>{/if}` lze nahradit za ekvivalentní `{first}<table>{/first}`, obdobně podmínku s `last` lze zapsat jako `{last}</table>{/last}`. Značky `{first}` a `{last}` mají nepovinný parametr, který lze využít jako modulo.

```html
{foreach $rows as $row}
	{first}<table>{/first}
		{first 5}<tr>{/first} {* nový řádek po 5 záznamech *}
			<td>{$row->value}</td>
		{last 5}</tr>{/last}
	{last}</table>{/last}
{/foreach}
```

A nakonec, ekvivalentem `{if !$iterator->last} … {/if}` (tj. neposlední prvek) je značka `{sep} … {/sep}`. Obvykle jim označíme oddělovač, například čárku mezi vypisovanými položkami, čímž zajistíme, že se nevypíše přebývající pravostranná čárka:

```html
{foreach $items as $item} {$item} {sep}, {/sep} {/foreach}
```

Uvnitř jakéhokoliv cyklu lze používat tagy `{continueIf ?}` a `{breakIf ?}`, které přejdou na další prvek resp. ukončí cyklus při splnění podmínky:

```html
{foreach $rows as $row}
	{continueIf $row->parent === null}
	...
{/foreach}
```

 .{data-version:2.9}
Třetí značka `{skipIf?}` Je velmi podobná jako `{continueIf?}`, ale nepřičítá počítadlo. Takže při vypisování `$iterator->counter` a přeskočení některých položek nebudou v číslování žádné díry. A co je nejdůležitější, klauzule `{else}` se vykreslí, když přeskočíte všechny položky.

```html
<ul>
    {foreach $people as $person}
		{skipIf $person->age < 18}
        <li>{$iterator->counter}. {$person->name}</li>
    {else}
        <li><em>Litujeme, v tomto seznamu nejsou žádní dospělí</em></li>
    {/foreach}
</ul>
```

Definici cyklu lze sloučit s definicí obalujícího prvku HTML následujícím způsobem: (vypíše pro každou řádku element `div`)
```html
<div n:foreach="$rows as $row">
	...
</div>
```
Nebo pomocí vnitřního cyklu opakovat pouze vnitřek elementu: (`ul` zobrazí jednou, `li` pro každou řádku)
```html
<ul n:inner-foreach="$rows as $row">
	<li>
	...
	</li>
</ul>
```


Deklarace proměnných `{var}` a `{default}` .{toc: Deklarace proměnných}
-----------------------------------------------------------------------

Proměnné můžeme deklarovat přímo v šabloně značkou `{var}`:

```html
{var $name = 'John Smith'}
{var $age = 27}

{* Vícenásobná deklarace *}
{var $name = 'John Smith', $age = 27}
```

Značka `{default}` funguje podobně s tím rozdílem, že nastavuje hodnoty jen neexistujícím proměnným:

```html
{default $lang = 'cs'}
```

Od Latte 2.7 můžete deklarovat typ proměnných:

```html
{var string $name = $article->getTitle()}
```


Zachytávání do proměnné `{capture}` .{toc: Zachytávání do proměnné}
-------------------------------------------------------------------

Zachytí výstup do proměnné:

```html
{capture $var}
<ul>
	<li>Hello World</li>
</ul>
{/capture}

<p>Captured: {$var}</p>
```

Pokud chcete zachytit výstup jen proto, abyste na něj mohli aplikovat nějaký [filtr |guide#filtry], je jednodušší filtr aplikovat přímo na blok:

```html
{block|strip}
<ul>
	<li>Hello World</li>
</ul>
{/block}
```


Vložení souboru `{include}` a `{sandbox}` .{toc: Vložení souboru}
-----------------------------------------------------------------

Do šablony lze vložit jinou šablonu. Vložený soubor má k dispozici globální proměnné aktuální šablony a případné další parametry, které mu při volání předáme:

```html
{include 'basket.latte'}

// předání argumentů
{include 'menu.latte', level: 3, data: $menu}
// předání argumentů před Latte 2.9
{include 'menu.latte', level => 3, data => $menu}
```

.[note]
Značka `{include}` se kromě vkládání souborů používá i pro [#vkládání bloků].

Soubor lze vložit také v bezpečném [sandbox režimu |sandbox]. V tomto případě nemá vložený soubor přístup k žádným parametrům, jen těm, které explicitně předáte:

```html
{sandbox 'untrusted.latte', level: 3, data: $menu}
```


Vyhodnocení kódu `{do expression}` .{toc: Vyhodnocení kódu}
-----------------------------------------------------------

Vyhodnotí kód a nic nevypisuje. (Od Latte 2.8, ve starších verzích funguje `{php}`).


Hlavička `{contentType}`
------------------------

Přepne [Kontextově sensitivní escapování |guide#Kontextově sensitivní escapování] do kontextu určeného argumentem a všechny proměnné se escapují podle pravidel tohoto kontextu. Například `{contentType xml}` přepne do režimu XML, `{contentType text}` escapování zcela vypne.


Pokud je parametrem plnohodnotný MIME type, tak se navíc odešle jako HTTP hlavička do prohlížeče:

```html
{contentType application/xml}
<?xml version="1.0"?>
<rss version="2.0">
	<channel>
		<title>RSS feed</title>
		<item>
			...
		</item>
	</channel>
</rss>
```


Break point `{debugbreak}` .{toc: debugbreak}
---------------------------------------------

Určuje místo, kde dojde k zastavení vykonávání programu. Používá se při ladění, aby mohl programátor provést inspekci běhového prostředí a zjistil, zda program funguje podle očekávání. Podporován je [Xdebug |https://xdebug.org/] a [PhpEd |http://www.nusphere.com/products/php_debugger.htm]. Lze doplnit podmínku, která určuje, kdy má být program zastaven.

```html
{debugbreak} {* Zastaví program *}

{debugbreak $counter == 1}  {* Zastaví program při splnění podmínky *}
```


Změna syntaxe `{syntax}` .{toc: Změna syntaxe}
----------------------------------------------

Tagy nemusejí být uzavřeny výhradně do jednoduchých složených závorek. Můžeme si zvolit i jiný oddělovač a to dokonce za běhu. Slouží k tomu `{syntax …}`, kde jako parametr lze uvést:

- latte: `{...}`
- double: `{{...}}`
- off: vypne zpracování tagů

S využitím n:atributů lze vypnout Latte třeba jen jednomu bloku JavaScriptu:

```html
<script n:syntax="off">
	var obj = {var: 123}; // tohle už není tag
</script>
```

Latte je pohodlně použitelné i v JavaScriptu, jen se stačí vyhnout konstrukci uvedené v předchozím příkladu. Buď zápisem mezery za otevírací složenou závorku `{ var: 123}` nebo použitím uvozovek kolem identifikátoru `{'var': 123}`.

Pokud Latte vypnete pomocí `{syntax off}` (tj. značkou, nikoliv n:atributem), mějte na paměti, že ho již zpátky nemůžete zapnout pomocí `{/syntax}`. Žádné složené závorky se nezpracovávají, tudíž ani tag pro ukončení výjimky v syntaxi.


n:class
-------

Potřebujeme vyřešit běžný úkol: vypisujeme data z databáze jako elementy `<li>`, neznáme dopředu jejich počet a chceme, aby každý lichý řádek měl třídu `alt` a poslední třídu `last`. Pokud by byl poslední řádek lichý, má mít obě třídy. A protože jsme puntičkáři, nechceme v kódu žádné prázdné `<li class=" ">` apod.

Díky atributu `n:class` tohle zapíšeme neskutečně snadno:

```html
<ul>
	{foreach $data as $item}
	<li n:class="$iterator->odd ? alt, $iterator->last ? last">{$item}</li>
	{/foreach}
</ul>
```


Anebo potřebujete označit aktivní menu třídou `current`?
```html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:*') ? current">
```

Úžasné, že?

Pokud potřebujete přesnější detekci URL, tak metodě `isLinkCurrent()` lze předat i očekávaný parametr:

```html
<a href="#" n:class="$presenter->isLinkCurrent('Presenter:action', 'slug') ? current">
```


n:attr
------

Atribut `n:attr` umí s elegancí, podobnou [n:class |#n:class], generovat libovolné HTML atributy. Hodí se především v případech, kdy nevíme, které atributy budeme chtít vypsat a které ne.

```html
<input type="checkbox" n:attr="value: $value, checked: $checked">
```

Vypíše v závislosti na hodnotách proměnných `$value` nebo `$checked`:

```html
<input type="checkbox">

{* $value = 'Hello' *}
<input type="checkbox" value="Hello">

{* $checked = true *}
<input type="checkbox" value="Hello" checked>
```


n:ifcontent
-----------

`n:ifcontent` odstraní prázdný tag:

```html
<div>
	<div class="error" n:ifcontent>{$error}</div>
</div>
```

Vypíše v závislosti na hodnotě proměnné `$error`:

```html
{* $error = '' *}
<div>
</div>

{* $error = 'Required' *}
<div>
	<div class="error">Required</div>
</div>
```


Bloky `{block}` a `{define}`  .{toc: Bloky}
-------------------------------------------

Bloky slouží pro označení libovolné oblasti šablony. Třeba proto, abychom na ni aplikovali volání filtru (viz [příklad |#Zachytávání do proměnné]) nebo proto, abychom ji pojmenovali a mohli poté na jiném místě znovu vložit.

```html
{block sidebar}
	<h3>Menu</h3>
	...
{/block}
```

Bloky lze zanořovat do sebe. A pochopitelně je můžeme zapsat prostřednictvím n:atributu:

```html
{block sidebar}
	<h3>Menu</h3>
	...

	<ul n:block="menulist">
		...
	</ul>
{/block}
```

Blok se na svém místě vykreslí. Pokud bychom chtěli pojmenovaný blok jen definovat bez vykreslení, použijeme místo `{block}` značku `{define}`.
Ta umožňuje navíc přijímat parametry:

```html
{define card, $name, $collapsed}
	<h3>{$name}</h3>
	...
{/define}

{include card, $person->name, true}
```

Od Latte 2.7 lze deklarovat i typy parametrů: `{define sidebar, string $name, bool $mode}`.

Název bloku může být také určen proměnnou: `{block $var} … {/block}`.

Každý blok vidí proměnné ze svého okolí. Avšak vytvoření nebo změna hodnoty proměnné uvnitř bloku se projeví pouze v něm (a pochopitelně i ve vnořených blocích).

Existenci bloku můžeme ověřit pomocí `{ifset sidebar}` nebo `{ifset block $name}`.


Vkládání bloků `{include block}`  .{toc: Vkládání bloků}
--------------------------------------------------------

Vložení bloku zajistí `{include}`.

```html
{include sidebar}
```

Analogicky pro šablony:

```html
{include 'sidebar.latte'}
```

Je také možné předat další parametry:

```html
{include sidebar, id: 123, name: $value}

// před Latte 2.9:
{include sidebar, id => 123, name => $value}
```

Můžeme vložit i blok, jehož název je uložen v proměnné (abychom se odlišili od vkládání souboru, uvedeme před názvem bloku mřížku):

```html
{include block $blockname}
```

(Nebo `{include #$blockname}` před Latte 2.9)


V bloku lze vložit i sebe sama, což lze použít např. pro vykreslení stromového menu.

```html
{block menu}
<ul>
	{foreach $menu as $item}
	<li>{if is_array($item)}
		{include menu, menu: $item}
	{else}
		{$item}
	{/if}</li>
	{/foreach}
</ul>
{/block}
```

Místo `{include menu, ...}` lze psát také `{include this, ...}`.


Pokud je potřeba doplnit již definovaný blok (např. přidání nových stylů), není kvůli tomu potřeba kopírovat celý obsah tohoto bloku. Místo toho si nadefinujeme nový (stejně pojmenovaný) blok a uvnitř zavoláme `{include parent}`.

```html
{block styles}
	{include parent}
	<link href="http://url.to.styles.css" rel="stylesheet">
{/block}
```

Ze souboru můžete také vložit pouze jeden blok. Funguje také pro lokální bloky.

```html
{include sidebar from 'template.latte'}
```


Rozšiřování a dědičnost šablon `{layout}` .{toc: Rozšiřování a dědičnost}
-------------------------------------------------------------------------

Rozšiřování šablon (též dědičnost šablon) představuje mocný nástroj, který umožňuje snadnou a efektivní tvorbu i velmi komplikovaných layoutů bez nutnosti zbytečného opakování kódu.

Mějme dvě jednoduché stránky. První:

```html
<html>
	<head>
		<title>První stránka | Můj web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Lorem Gypsum...</p>
		</div>
	</body>
</html>
```

A druhou:

```html
<html>
	<head>
		<title>Druhá stránka | Můj web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">
			<p>Proin eu sem purus. Donec bibendum
			vestibulum...</p>
		</div>
	</body>
</html>
```

Stránky se liší pouze elementem `<title>` a `<div#content>`. Vytvoříme si proto layout, ve kterém budou všechny společné části, a vytvoříme tzv. placeholdery. Což kupodivu nebude nic jiného, než klasický blok:

Soubor `@layout.latte`:
```html
<html>
	<head>
		<title>{block title}{/block} | Můj web</title>
	</head>
	<body>
		<div id="sidebar">
			<ul>...</ul>
		</div>

		<div id="content">{block content}{/block}</div>
	</body>
</html>
```

V jednotlivých šablonách se nyní na layout odkážeme značkou `{layout}` a můžeme je redukovat na ony dva bloky:

```html
{layout '@layout.latte'}

{block title}První stránka{/block}

{block content}<p>Lorem Gypsum...</p>{/block}
```

Obdobně bude vypadat i stránka druhá.

Nejsme dokonce ani omezeni dvoustupňovým layoutem. Vrstev může být totiž tolik, kolik se nám hodí.

 .{data-version:2.9}
Někdy potřebujeme vytvořit blok (pomocí `{block}` nebo `{define}`), který by neměl být k dispozici v jiných šablonách, ani by neměl přepisovat další bloky, pokud se jejich názvy shodují. Tyto bloky označíme jako lokální pomocí klíčového slova `local` před jménem:

```html
{block local tree}
	Toto je lokální blok
{/block}
```


Načtení šablony s přepsáním bloků `{embed}`` .{toc: embed}{data-version:v2.9}
-----------------------------------------------------------------------------

Kombinace include + extends. Umožní vám vložit obsah jiné šablony a zároveň přepsat jakýkoliv bloky definované uvnitř ní, jako například při dědění šablon.

```html
{embed 'object.latte'}
    {* tyto bloky definované v object.latte přepíšeme právě tady: *}
    {block title}Hello{/block}

	{block description}
        Nějaký obsah pro popis
    {/block}
{/embed}
```

object.latte:

```html
<div class="media">
	<h1 class="media-title">{block title}výchozí obsah{/block}</h1>

	<div class="media-inner">
		{include description}
	</div>
</div>
```

Můžete také předat proměnné, např. `{embed template.latte, id: 10, name: $name}`, jako v případě `{include}`.


Výjimky `{try}`, `{rollback}` .{toc: Exceptions}{data-version:v2.9}
-------------------------------------------------------------------

Díky těmto značkám je extrémně snadné vytvářet robustní šablony. Pokud při vykreslování bloku `{try}` dojde k výjimce, celý blok bude přeskočen a vykreslování bude pokračovat až po něm:

```html
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
{/try}
```

Volitelná klauzule `{else}` je vykreslena při výjimku:

```html
{try}
	<ul>
		{foreach $twitter->loadTweets() as $tweet}
  			<li>{$tweet->text}</li>
		{/foreach}
	</ul>
	{else}
	<p>Je nám líto, nelze načíst tweety.</p>
{/try}
```

Blok `{try}` lze také zastavit a přeskočit ručně pomocí `{rollback}`. Nemusíte tak předem kontrolovat všechna vstupní data a až během vykreslování se můžete rozhodnout, zda má smysl objekt vykreslit:

```html
{try}
<ul>
    {foreach $people as $person}
 		{skipIf $person->age < 18}
       <li>{$person->name}</li>
    {else}
		{rollback}
    {/foreach}
</ul>
{/try}
```

Je také možné definovat vlastní obslužný program výjimek pro protokolování:

```php
$latte = new Latte\Engine;
$latte->setExceptionHandler(function (\Throwable $e) {
	...
});
```


Typové šablony `{varType}`, `{varPrint}`, `{templateType}`, `{templatePrint}` .{toc: Typy}{data-version:v2.7}
-------------------------------------------------------------------------------------------------------------

Typový systém je klíčový pro vývoj robustních aplikací. Díky tomu, že víme, jaký datový či objektový typ je v každé proměnné, může IDE správně našeptávat (viz [Typované šablony |type-system]).

Jak deklarovat typy proměnných? Přímo v šabloně k tomu slouží značky `{varType}` nebo [`{var}` |#Deklarace proměnných]:

```html
{varType Nette\Security\User $user}
{varType string $lang}
```

Značka `{varPrint}` vám ušetří čas se psaním. Pokud ji umístíte do šablony, místo běžného vykreslení se zobrazí návrh značek `{varType}` pro lokální proměnné. Kód pak stačí jedním kliknutím označit a zkopírovat do šablony.
Samotné `{varPrint}` vypisuje pouze lokální proměnné, které nejsou parametry šablony. Pokud chcete vypsat všechny proměnné, použijte `{varPrint all}`.

Typy parametrů předávaných do šablony lze [deklarovat pomocí třídy|type-system], kterou uvedeme na začátku šablony:

```html
{templateType MyApp\CatalogTemplate}
```

Třídu si také můžete nechat vygenerovat pomocí značky `{templatePrint}`. Pokud ji umístíte na začátek šablony, místo běžného vykreslení se zobrazí návrh třídy. Kód pak stačí jedním kliknutím označit a zkopírovat do projektu.


Vykreslování komponent `{control …}` .{toc: Vykreslování komponent}
-------------------------------------------------------------------

Slouží k vykreslování komponent presenteru. Pro lepší pochopení je dobré vědět, jak se tato značka přeloží do PHP.

```html
{control cartControl}		pro celý košík na stránce
{control cartControl:small}	pro malý náhledový košík
```

se přeloží jako:

```php
$control->getComponent('cartControl')->render();
$control->getComponent('cartControl')->renderSmall();
```

Metoda `getComponent()` vrací komponentu `cartControl` a nad touto komponentou volá metodu `render()`, resp. `renderSmall()` pokud je jiný způsob renderování uveden ve značce za dvojtečkou.

Lze použít i volání s parametry, které se předají render metodám, například:

```html
{control cartControl, $maxItems, $showSummary}
{control cartControl, maxItems: 5, showSummary: true}
{control cartControl, [maxItems => 5, showSummary => true]}
{control cartControl:small, $maxItems, $showSummary}
```

se přeloží jako:

```php
$control->getComponent('cartControl')->render($maxItems, $showSummary);
$control->getComponent('cartControl')->render(['maxItems' => 5, 'showSummary' => true]);
$control->getComponent('cartControl')->render([['maxItems' => 5, 'showSummary' => true]]);
$control->getComponent('cartControl')->renderSmall($maxItems, $showSummary);
```

.[caution]
Pokud se kdekoliv v parametrech objeví **`=>`**, všechny parametry budou zabaleny do pole a předány jako první argument.

Vykreslení sub-komponety:

```html
{control cartControl-someForm}
```

se přeloží jako:

```php
$control->getComponent("cartControl-someForm")->render();
```


Formuláře `{form}`, `{input}`, `{inputError}`,  `{label}` .{toc: Formuláře}
---------------------------------------------------------------------------

Usnadňují vykreslení [formulářů |doc:forms] a jejich prvků:

```html
{form myForm}
<table>
<tr n:foreach="$form->controls as $name => $field">
	<th>{label $name /}<th>
	<td>{input $name}</td>
	<td n:ifcontent>{inputError $name}</td>
</tr>
</table>
{/form}
```

Značka `{form}` nebo `<form n:name>` zahájí vykreslování formuláře. Zároveň vytvoří lokální proměnnou `$form` s objektem kresleného formuláře. Uzavírací značka `{/form}` nebo `</form>` před uzavřením formuláře ještě vykreslí všechny nevykreslené hidden prvky.

Značka `{input}` vykreslí jakýkoliv prvek, včetně select boxů nebo textarea. Tag `{label}` může být volitelně párové, např. `{label}Věk{/label}`, a ohraničený text bude u [vícejazyčných formulářů |doc:forms#vicejazycne-formulare] také přeložen. Pokud formulářový prvek obsahuje chybu, značka `{inputError}` ji vypíše.

Pokud potřebuje formuláře naroubovat na existující HTML kód, můžeme využít atribut `n:name`, které zaktivní existující prvky v šabloně:

```html
<form n:name=myForm>
	<p>Jméno: <input size="50" n:name="name"></p>
	<p>Heslo: <input size="30" n:name="password"></p>
</form>
```

Latte kód pro formulář si také můžete nechat vygenerovat pomocí značky `{formPrint}`. Pokud ji umístíte do šablony, místo běžného vykreslení se zobrazí návrh kódu. Ten pak stačí označit a zkopírovat do projektu.  .{data-version:nette/forms 3.0.5}

Pokud potřebujete vykreslit jen vnitřní část formuláře bez HTML značek `<form>` & `</form>`, například při AJAXovém požadavku, můžete formulář otevří a uzavřít do `{formContext formName} … {/formContext}`. Funguje podobně jako `{form}` v logickém smyslu, tady umožní používat ostatní značky pro kreslení prvků formuláře, ale přitom nic nevykreslí.  .{data-version:nette/forms 3.0.6}


Překlady `{_expression}` .{toc: Překlady}
-----------------------------------------

Usnadňuje automatizované překlady v šablonách. Pro její správnou funkčnost musí být nastaven překladač, viz [lokalizace |doc:translations#preklad-sablon]:

```php
$latte->addFilter('translate', new MyTranslator);
```

Poté bude jakýkoliv výraz zapsaný v tomto tagu automaticky přeložen:

```html
{_$variable}
```

Pro textové části šablony lze použít párovou variantu:

```html
{_}Text, který bude přeložen{/_}
```


Dumpování proměnných `{dump}` .{toc: Dumpování proměnných}
----------------------------------------------------------

Vyžaduje [Tracy|tracy:].

```html
{dump $name} {* Vypíše proměnnou $name *}

{dump}       {* Vypíše všechny aktuálně definované proměnné *}
```


Operátor rozbalení pole `(expand)` .{toc: (expand)}
---------------------------------------------------

Operátor `(expand)` umožňuje použití pole v místě, kde se očekává více argumentů. Jde o obdobu operátoru [`...` z PHP |https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list.new], na rozdíl od něj však zachovává i klíče.

Lze jej použít například pro předání argumentů do bloků nebo vkládaných šablon, pokud je máme v poli.

```html
{include 'foobar.latte' (expand) $args}     {* argumenty pro include *}
```

{{composer: latte/latte}}
